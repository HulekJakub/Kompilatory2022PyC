Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> s_prim
Rule 1     s_prim -> program
Rule 2     program -> program_component
Rule 3     program -> program_component program
Rule 4     program_component -> declaration_statement
Rule 5     program_component -> function_definition_statement
Rule 6     program_component -> COMMENT
Rule 7     program_component -> PREPROCESSOR_LINE
Rule 8     statement -> any_statement
Rule 9     statement -> COMMENT
Rule 10    statement -> SEMICOLON
Rule 11    statements -> statement
Rule 12    statements -> statement statements
Rule 13    opt_statements -> statements
Rule 14    opt_statements -> empty
Rule 15    statements_block -> L_BRACE opt_statements R_BRACE
Rule 16    any_statement -> declaration_statement
Rule 17    any_statement -> assign_statement
Rule 18    any_statement -> function_statement
Rule 19    any_statement -> return_statement
Rule 20    any_statement -> while_loop_statement
Rule 21    any_statement -> do_while_loop_statement
Rule 22    any_statement -> break_statement
Rule 23    any_statement -> for_loop_statement
Rule 24    any_statement -> if_statement_block
Rule 25    any_statement -> print_statement
Rule 26    any_statement -> scan_statement
Rule 27    declaration_statement -> opt_const type ID opt_array_mark
Rule 28    declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
Rule 29    assign_statement -> assign_expression SEMICOLON
Rule 30    function_statement -> function_expression SEMICOLON
Rule 31    return_statement -> RETURN value_expression SEMICOLON
Rule 32    break_statement -> BREAK SEMICOLON
Rule 33    function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block
Rule 34    while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block
Rule 35    do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON
Rule 36    for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block
Rule 37    decl_stat_or_sem -> declaration_statement
Rule 38    decl_stat_or_sem -> SEMICOLON
Rule 39    if_statement_block -> if_statement
Rule 40    if_statement_block -> if_statement else_else_if_statements_block
Rule 41    if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block
Rule 42    if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block
Rule 43    else_else_if_statements_block -> else_statement
Rule 44    else_else_if_statements_block -> else_if_statement else_else_if_statements_block
Rule 45    else_else_if_statements_block -> else_if_statement
Rule 46    else_statement -> ELSE statements_block
Rule 47    else_if_statement -> ELSE if_statement
Rule 48    print_statement -> PRINTF L_BRACKET value_expression R_BRACKET
Rule 49    scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET
Rule 50    declaration_value_expression -> value_expression
Rule 51    declaration_value_expression -> L_BRACE listed_values R_BRACE
Rule 52    declaration_value_expression -> L_BRACE declaration_value_expression R_BRACE
Rule 53    value_expression -> math_expression
Rule 54    value_expression -> function_expression
Rule 55    value_expression -> value
Rule 56    value_expression -> trinary_mark_expression
Rule 57    value_expression -> L_BRACKET value_expression R_BRACKET
Rule 58    opt_value_expression -> value_expression
Rule 59    opt_value_expression -> empty
Rule 60    math_expression -> L_BRACKET math_expression R_BRACKET
Rule 61    math_expression -> MINUS math_expression
Rule 62    math_expression -> MINUS value
Rule 63    math_expression -> value math_op value
Rule 64    logical_expression -> logical_expression bool_op logical_expression
Rule 65    logical_expression -> NEGATION logical_expression
Rule 66    logical_expression -> value_expression comparison_op value_expression
Rule 67    logical_expression -> L_BRACKET logical_expression R_BRACKET
Rule 68    function_expression -> ID L_BRACKET opt_listed_values R_BRACKET
Rule 69    trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression
Rule 70    assign_expression -> ID assign_op value_expression
Rule 71    assign_expression -> list_element_extraction assign_op value_expression
Rule 72    assign_expression -> unary_op ID
Rule 73    assign_expression -> ID unary_op
Rule 74    opt_logical_expression -> logical_expression
Rule 75    opt_logical_expression -> empty
Rule 76    opt_assign_expression -> assign_expression
Rule 77    opt_assign_expression -> empty
Rule 78    type -> INT
Rule 79    type -> FLOAT
Rule 80    type -> DOUBLE
Rule 81    type -> CHAR
Rule 82    type -> BOOL
Rule 83    type -> LONG
Rule 84    type -> VOID
Rule 85    value -> INTEGER
Rule 86    value -> DECIMAL
Rule 87    value -> CHARACTER
Rule 88    value -> STRING
Rule 89    value -> TRUE
Rule 90    value -> FALSE
Rule 91    value -> ID
Rule 92    value -> list_element_extraction
Rule 93    list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
Rule 94    listed_values -> value_expression COMMA value_expression
Rule 95    listed_values -> value_expression COMMA listed_values
Rule 96    math_op -> PLUS
Rule 97    math_op -> MINUS
Rule 98    math_op -> MUL
Rule 99    math_op -> DIV
Rule 100   math_op -> MOD
Rule 101   unary_op -> INCREMENT
Rule 102   unary_op -> DECREMENT
Rule 103   bool_op -> AND
Rule 104   bool_op -> OR
Rule 105   comparison_op -> EQUAL
Rule 106   comparison_op -> NOT_EQUAL
Rule 107   comparison_op -> GREATER
Rule 108   comparison_op -> GREATER_EQUAL
Rule 109   comparison_op -> LESSER
Rule 110   comparison_op -> LESSER_EQUAL
Rule 111   assign_op -> ASSIGN
Rule 112   assign_op -> PLUS_ASSIGN
Rule 113   assign_op -> MINUS_ASSIGN
Rule 114   assign_op -> MUL_ASSIGN
Rule 115   assign_op -> DIV_ASSIGN
Rule 116   assign_op -> MOD_ASSIGN
Rule 117   array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET
Rule 118   opt_const -> CONST
Rule 119   opt_const -> empty
Rule 120   opt_array_mark -> array_mark
Rule 121   opt_array_mark -> empty
Rule 122   opt_listed_values -> listed_values
Rule 123   opt_listed_values -> empty
Rule 124   args -> type ID
Rule 125   args -> type ID COMMA args
Rule 126   opt_args -> args
Rule 127   opt_args -> empty
Rule 128   empty -> <empty>

Terminals, with rules where they appear

AMPERSAND            : 49
AND                  : 103
ASSIGN               : 28 111
BOOL                 : 82
BREAK                : 32
CHAR                 : 81
CHARACTER            : 87
COLON                : 69
COMMA                : 94 95 125
COMMENT              : 6 9
CONST                : 118
DECIMAL              : 86
DECREMENT            : 102
DIV                  : 99
DIV_ASSIGN           : 115
DO                   : 35
DOUBLE               : 80
ELSE                 : 46 47
EQUAL                : 105
FALSE                : 90
FLOAT                : 79
FOR                  : 36
GREATER              : 107
GREATER_EQUAL        : 108
ID                   : 27 28 33 49 68 70 72 73 91 93 124 125
IF                   : 41 42
INCREMENT            : 101
INT                  : 78
INTEGER              : 85
LESSER               : 109
LESSER_EQUAL         : 110
LONG                 : 83
L_BRACE              : 15 51 52
L_BRACKET            : 33 34 35 36 41 42 48 49 57 60 67 68
L_SQUARE_BRACKET     : 93 117
MINUS                : 61 62 97
MINUS_ASSIGN         : 113
MOD                  : 100
MOD_ASSIGN           : 116
MUL                  : 98
MUL_ASSIGN           : 114
NEGATION             : 65
NOT_EQUAL            : 106
OR                   : 104
PLUS                 : 96
PLUS_ASSIGN          : 112
PREPROCESSOR_LINE    : 7
PRINTF               : 48
QUESTION_MARK        : 69
RETURN               : 31
R_BRACE              : 15 51 52
R_BRACKET            : 33 34 35 36 41 42 48 49 57 60 67 68
R_SQUARE_BRACKET     : 93 117
SCANF                : 49
SEMICOLON            : 10 28 29 30 31 32 35 36 38
STRING               : 88
TRUE                 : 89
VOID                 : 84
WHILE                : 34 35
error                : 

Nonterminals, with rules where they appear

any_statement        : 8
args                 : 125 126
array_mark           : 120
assign_expression    : 29 76
assign_op            : 70 71
assign_statement     : 17
bool_op              : 64
break_statement      : 22
comparison_op        : 66
decl_stat_or_sem     : 36
declaration_statement : 4 16 37
declaration_value_expression : 28 52
do_while_loop_statement : 21
else_else_if_statements_block : 40 44
else_if_statement    : 44 45
else_statement       : 43
empty                : 14 59 75 77 119 121 123 127
for_loop_statement   : 23
function_definition_statement : 5
function_expression  : 30 54
function_statement   : 18
if_statement         : 39 40 47
if_statement_block   : 24
list_element_extraction : 71 92
listed_values        : 51 95 122
logical_expression   : 34 35 41 64 64 65 67 69 74
math_expression      : 53 60 61
math_op              : 63
opt_args             : 33
opt_array_mark       : 27 28
opt_assign_expression : 36
opt_const            : 27 28
opt_listed_values    : 68
opt_logical_expression : 36
opt_statements       : 15
opt_value_expression : 117
print_statement      : 25
program              : 1 3
program_component    : 2 3
return_statement     : 19
s_prim               : 0
scan_statement       : 26
statement            : 11 12
statements           : 12 13
statements_block     : 33 34 35 36 41 42 46
trinary_mark_expression : 56
type                 : 27 28 33 124 125
unary_op             : 72 73
value                : 55 62 63 63
value_expression     : 31 42 48 50 57 58 66 66 69 69 70 71 93 94 94 95
while_loop_statement : 20

Parsing method: LALR

state 0

    (0) S' -> . s_prim
    (1) s_prim -> . program
    (2) program -> . program_component
    (3) program -> . program_component program
    (4) program_component -> . declaration_statement
    (5) program_component -> . function_definition_statement
    (6) program_component -> . COMMENT
    (7) program_component -> . PREPROCESSOR_LINE
    (27) declaration_statement -> . opt_const type ID opt_array_mark
    (28) declaration_statement -> . opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (33) function_definition_statement -> . type ID L_BRACKET opt_args R_BRACKET statements_block
    (118) opt_const -> . CONST
    (119) opt_const -> . empty
    (78) type -> . INT
    (79) type -> . FLOAT
    (80) type -> . DOUBLE
    (81) type -> . CHAR
    (82) type -> . BOOL
    (83) type -> . LONG
    (84) type -> . VOID
    (128) empty -> .

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LONG resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    COMMENT         shift and go to state 6
    PREPROCESSOR_LINE shift and go to state 7
    CONST           shift and go to state 10
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

  ! INT             [ reduce using rule 128 (empty -> .) ]
  ! FLOAT           [ reduce using rule 128 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 128 (empty -> .) ]
  ! CHAR            [ reduce using rule 128 (empty -> .) ]
  ! BOOL            [ reduce using rule 128 (empty -> .) ]
  ! LONG            [ reduce using rule 128 (empty -> .) ]
  ! VOID            [ reduce using rule 128 (empty -> .) ]

    s_prim                         shift and go to state 1
    program                        shift and go to state 2
    program_component              shift and go to state 3
    declaration_statement          shift and go to state 4
    function_definition_statement  shift and go to state 5
    opt_const                      shift and go to state 8
    type                           shift and go to state 9
    empty                          shift and go to state 11

state 1

    (0) S' -> s_prim .



state 2

    (1) s_prim -> program .

    $end            reduce using rule 1 (s_prim -> program .)


state 3

    (2) program -> program_component .
    (3) program -> program_component . program
    (2) program -> . program_component
    (3) program -> . program_component program
    (4) program_component -> . declaration_statement
    (5) program_component -> . function_definition_statement
    (6) program_component -> . COMMENT
    (7) program_component -> . PREPROCESSOR_LINE
    (27) declaration_statement -> . opt_const type ID opt_array_mark
    (28) declaration_statement -> . opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (33) function_definition_statement -> . type ID L_BRACKET opt_args R_BRACKET statements_block
    (118) opt_const -> . CONST
    (119) opt_const -> . empty
    (78) type -> . INT
    (79) type -> . FLOAT
    (80) type -> . DOUBLE
    (81) type -> . CHAR
    (82) type -> . BOOL
    (83) type -> . LONG
    (84) type -> . VOID
    (128) empty -> .

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LONG resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    $end            reduce using rule 2 (program -> program_component .)
    COMMENT         shift and go to state 6
    PREPROCESSOR_LINE shift and go to state 7
    CONST           shift and go to state 10
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

  ! INT             [ reduce using rule 128 (empty -> .) ]
  ! FLOAT           [ reduce using rule 128 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 128 (empty -> .) ]
  ! CHAR            [ reduce using rule 128 (empty -> .) ]
  ! BOOL            [ reduce using rule 128 (empty -> .) ]
  ! LONG            [ reduce using rule 128 (empty -> .) ]
  ! VOID            [ reduce using rule 128 (empty -> .) ]

    program_component              shift and go to state 3
    program                        shift and go to state 19
    declaration_statement          shift and go to state 4
    function_definition_statement  shift and go to state 5
    opt_const                      shift and go to state 8
    type                           shift and go to state 9
    empty                          shift and go to state 11

state 4

    (4) program_component -> declaration_statement .

    COMMENT         reduce using rule 4 (program_component -> declaration_statement .)
    PREPROCESSOR_LINE reduce using rule 4 (program_component -> declaration_statement .)
    CONST           reduce using rule 4 (program_component -> declaration_statement .)
    INT             reduce using rule 4 (program_component -> declaration_statement .)
    FLOAT           reduce using rule 4 (program_component -> declaration_statement .)
    DOUBLE          reduce using rule 4 (program_component -> declaration_statement .)
    CHAR            reduce using rule 4 (program_component -> declaration_statement .)
    BOOL            reduce using rule 4 (program_component -> declaration_statement .)
    LONG            reduce using rule 4 (program_component -> declaration_statement .)
    VOID            reduce using rule 4 (program_component -> declaration_statement .)
    $end            reduce using rule 4 (program_component -> declaration_statement .)


state 5

    (5) program_component -> function_definition_statement .

    COMMENT         reduce using rule 5 (program_component -> function_definition_statement .)
    PREPROCESSOR_LINE reduce using rule 5 (program_component -> function_definition_statement .)
    CONST           reduce using rule 5 (program_component -> function_definition_statement .)
    INT             reduce using rule 5 (program_component -> function_definition_statement .)
    FLOAT           reduce using rule 5 (program_component -> function_definition_statement .)
    DOUBLE          reduce using rule 5 (program_component -> function_definition_statement .)
    CHAR            reduce using rule 5 (program_component -> function_definition_statement .)
    BOOL            reduce using rule 5 (program_component -> function_definition_statement .)
    LONG            reduce using rule 5 (program_component -> function_definition_statement .)
    VOID            reduce using rule 5 (program_component -> function_definition_statement .)
    $end            reduce using rule 5 (program_component -> function_definition_statement .)


state 6

    (6) program_component -> COMMENT .

    COMMENT         reduce using rule 6 (program_component -> COMMENT .)
    PREPROCESSOR_LINE reduce using rule 6 (program_component -> COMMENT .)
    CONST           reduce using rule 6 (program_component -> COMMENT .)
    INT             reduce using rule 6 (program_component -> COMMENT .)
    FLOAT           reduce using rule 6 (program_component -> COMMENT .)
    DOUBLE          reduce using rule 6 (program_component -> COMMENT .)
    CHAR            reduce using rule 6 (program_component -> COMMENT .)
    BOOL            reduce using rule 6 (program_component -> COMMENT .)
    LONG            reduce using rule 6 (program_component -> COMMENT .)
    VOID            reduce using rule 6 (program_component -> COMMENT .)
    $end            reduce using rule 6 (program_component -> COMMENT .)


state 7

    (7) program_component -> PREPROCESSOR_LINE .

    COMMENT         reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    PREPROCESSOR_LINE reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    CONST           reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    INT             reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    FLOAT           reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    DOUBLE          reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    CHAR            reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    BOOL            reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    LONG            reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    VOID            reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    $end            reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)


state 8

    (27) declaration_statement -> opt_const . type ID opt_array_mark
    (28) declaration_statement -> opt_const . type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (78) type -> . INT
    (79) type -> . FLOAT
    (80) type -> . DOUBLE
    (81) type -> . CHAR
    (82) type -> . BOOL
    (83) type -> . LONG
    (84) type -> . VOID

    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

    type                           shift and go to state 20

state 9

    (33) function_definition_statement -> type . ID L_BRACKET opt_args R_BRACKET statements_block

    ID              shift and go to state 21


state 10

    (118) opt_const -> CONST .

    INT             reduce using rule 118 (opt_const -> CONST .)
    FLOAT           reduce using rule 118 (opt_const -> CONST .)
    DOUBLE          reduce using rule 118 (opt_const -> CONST .)
    CHAR            reduce using rule 118 (opt_const -> CONST .)
    BOOL            reduce using rule 118 (opt_const -> CONST .)
    LONG            reduce using rule 118 (opt_const -> CONST .)
    VOID            reduce using rule 118 (opt_const -> CONST .)


state 11

    (119) opt_const -> empty .

    INT             reduce using rule 119 (opt_const -> empty .)
    FLOAT           reduce using rule 119 (opt_const -> empty .)
    DOUBLE          reduce using rule 119 (opt_const -> empty .)
    CHAR            reduce using rule 119 (opt_const -> empty .)
    BOOL            reduce using rule 119 (opt_const -> empty .)
    LONG            reduce using rule 119 (opt_const -> empty .)
    VOID            reduce using rule 119 (opt_const -> empty .)


state 12

    (78) type -> INT .

    ID              reduce using rule 78 (type -> INT .)


state 13

    (79) type -> FLOAT .

    ID              reduce using rule 79 (type -> FLOAT .)


state 14

    (80) type -> DOUBLE .

    ID              reduce using rule 80 (type -> DOUBLE .)


state 15

    (81) type -> CHAR .

    ID              reduce using rule 81 (type -> CHAR .)


state 16

    (82) type -> BOOL .

    ID              reduce using rule 82 (type -> BOOL .)


state 17

    (83) type -> LONG .

    ID              reduce using rule 83 (type -> LONG .)


state 18

    (84) type -> VOID .

    ID              reduce using rule 84 (type -> VOID .)


state 19

    (3) program -> program_component program .

    $end            reduce using rule 3 (program -> program_component program .)


state 20

    (27) declaration_statement -> opt_const type . ID opt_array_mark
    (28) declaration_statement -> opt_const type . ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON

    ID              shift and go to state 22


state 21

    (33) function_definition_statement -> type ID . L_BRACKET opt_args R_BRACKET statements_block

    L_BRACKET       shift and go to state 23


state 22

    (27) declaration_statement -> opt_const type ID . opt_array_mark
    (28) declaration_statement -> opt_const type ID . opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (120) opt_array_mark -> . array_mark
    (121) opt_array_mark -> . empty
    (117) array_mark -> . L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET
    (128) empty -> .

    L_SQUARE_BRACKET shift and go to state 27
    ASSIGN          reduce using rule 128 (empty -> .)
    COMMENT         reduce using rule 128 (empty -> .)
    PREPROCESSOR_LINE reduce using rule 128 (empty -> .)
    CONST           reduce using rule 128 (empty -> .)
    INT             reduce using rule 128 (empty -> .)
    FLOAT           reduce using rule 128 (empty -> .)
    DOUBLE          reduce using rule 128 (empty -> .)
    CHAR            reduce using rule 128 (empty -> .)
    BOOL            reduce using rule 128 (empty -> .)
    LONG            reduce using rule 128 (empty -> .)
    VOID            reduce using rule 128 (empty -> .)
    $end            reduce using rule 128 (empty -> .)
    SEMICOLON       reduce using rule 128 (empty -> .)
    RETURN          reduce using rule 128 (empty -> .)
    WHILE           reduce using rule 128 (empty -> .)
    DO              reduce using rule 128 (empty -> .)
    BREAK           reduce using rule 128 (empty -> .)
    FOR             reduce using rule 128 (empty -> .)
    PRINTF          reduce using rule 128 (empty -> .)
    SCANF           reduce using rule 128 (empty -> .)
    ID              reduce using rule 128 (empty -> .)
    IF              reduce using rule 128 (empty -> .)
    INCREMENT       reduce using rule 128 (empty -> .)
    DECREMENT       reduce using rule 128 (empty -> .)
    R_BRACE         reduce using rule 128 (empty -> .)
    NEGATION        reduce using rule 128 (empty -> .)
    L_BRACKET       reduce using rule 128 (empty -> .)
    MINUS           reduce using rule 128 (empty -> .)
    INTEGER         reduce using rule 128 (empty -> .)
    DECIMAL         reduce using rule 128 (empty -> .)
    CHARACTER       reduce using rule 128 (empty -> .)
    STRING          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    opt_array_mark                 shift and go to state 24
    array_mark                     shift and go to state 25
    empty                          shift and go to state 26

state 23

    (33) function_definition_statement -> type ID L_BRACKET . opt_args R_BRACKET statements_block
    (126) opt_args -> . args
    (127) opt_args -> . empty
    (124) args -> . type ID
    (125) args -> . type ID COMMA args
    (128) empty -> .
    (78) type -> . INT
    (79) type -> . FLOAT
    (80) type -> . DOUBLE
    (81) type -> . CHAR
    (82) type -> . BOOL
    (83) type -> . LONG
    (84) type -> . VOID

    R_BRACKET       reduce using rule 128 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

    type                           shift and go to state 28
    opt_args                       shift and go to state 29
    args                           shift and go to state 30
    empty                          shift and go to state 31

state 24

    (27) declaration_statement -> opt_const type ID opt_array_mark .
    (28) declaration_statement -> opt_const type ID opt_array_mark . ASSIGN declaration_value_expression SEMICOLON

    COMMENT         reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    PREPROCESSOR_LINE reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    CONST           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    INT             reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    FLOAT           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    DOUBLE          reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    CHAR            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    BOOL            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    LONG            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    VOID            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    $end            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    SEMICOLON       reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    RETURN          reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    WHILE           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    DO              reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    BREAK           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    FOR             reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    PRINTF          reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    SCANF           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    ID              reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    IF              reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    INCREMENT       reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    DECREMENT       reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    R_BRACE         reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    NEGATION        reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    L_BRACKET       reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    MINUS           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    INTEGER         reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    DECIMAL         reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    CHARACTER       reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    STRING          reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    TRUE            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    FALSE           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    ASSIGN          shift and go to state 32


state 25

    (120) opt_array_mark -> array_mark .

    ASSIGN          reduce using rule 120 (opt_array_mark -> array_mark .)
    COMMENT         reduce using rule 120 (opt_array_mark -> array_mark .)
    PREPROCESSOR_LINE reduce using rule 120 (opt_array_mark -> array_mark .)
    CONST           reduce using rule 120 (opt_array_mark -> array_mark .)
    INT             reduce using rule 120 (opt_array_mark -> array_mark .)
    FLOAT           reduce using rule 120 (opt_array_mark -> array_mark .)
    DOUBLE          reduce using rule 120 (opt_array_mark -> array_mark .)
    CHAR            reduce using rule 120 (opt_array_mark -> array_mark .)
    BOOL            reduce using rule 120 (opt_array_mark -> array_mark .)
    LONG            reduce using rule 120 (opt_array_mark -> array_mark .)
    VOID            reduce using rule 120 (opt_array_mark -> array_mark .)
    $end            reduce using rule 120 (opt_array_mark -> array_mark .)
    SEMICOLON       reduce using rule 120 (opt_array_mark -> array_mark .)
    RETURN          reduce using rule 120 (opt_array_mark -> array_mark .)
    WHILE           reduce using rule 120 (opt_array_mark -> array_mark .)
    DO              reduce using rule 120 (opt_array_mark -> array_mark .)
    BREAK           reduce using rule 120 (opt_array_mark -> array_mark .)
    FOR             reduce using rule 120 (opt_array_mark -> array_mark .)
    PRINTF          reduce using rule 120 (opt_array_mark -> array_mark .)
    SCANF           reduce using rule 120 (opt_array_mark -> array_mark .)
    ID              reduce using rule 120 (opt_array_mark -> array_mark .)
    IF              reduce using rule 120 (opt_array_mark -> array_mark .)
    INCREMENT       reduce using rule 120 (opt_array_mark -> array_mark .)
    DECREMENT       reduce using rule 120 (opt_array_mark -> array_mark .)
    R_BRACE         reduce using rule 120 (opt_array_mark -> array_mark .)
    NEGATION        reduce using rule 120 (opt_array_mark -> array_mark .)
    L_BRACKET       reduce using rule 120 (opt_array_mark -> array_mark .)
    MINUS           reduce using rule 120 (opt_array_mark -> array_mark .)
    INTEGER         reduce using rule 120 (opt_array_mark -> array_mark .)
    DECIMAL         reduce using rule 120 (opt_array_mark -> array_mark .)
    CHARACTER       reduce using rule 120 (opt_array_mark -> array_mark .)
    STRING          reduce using rule 120 (opt_array_mark -> array_mark .)
    TRUE            reduce using rule 120 (opt_array_mark -> array_mark .)
    FALSE           reduce using rule 120 (opt_array_mark -> array_mark .)


state 26

    (121) opt_array_mark -> empty .

    ASSIGN          reduce using rule 121 (opt_array_mark -> empty .)
    COMMENT         reduce using rule 121 (opt_array_mark -> empty .)
    PREPROCESSOR_LINE reduce using rule 121 (opt_array_mark -> empty .)
    CONST           reduce using rule 121 (opt_array_mark -> empty .)
    INT             reduce using rule 121 (opt_array_mark -> empty .)
    FLOAT           reduce using rule 121 (opt_array_mark -> empty .)
    DOUBLE          reduce using rule 121 (opt_array_mark -> empty .)
    CHAR            reduce using rule 121 (opt_array_mark -> empty .)
    BOOL            reduce using rule 121 (opt_array_mark -> empty .)
    LONG            reduce using rule 121 (opt_array_mark -> empty .)
    VOID            reduce using rule 121 (opt_array_mark -> empty .)
    $end            reduce using rule 121 (opt_array_mark -> empty .)
    SEMICOLON       reduce using rule 121 (opt_array_mark -> empty .)
    RETURN          reduce using rule 121 (opt_array_mark -> empty .)
    WHILE           reduce using rule 121 (opt_array_mark -> empty .)
    DO              reduce using rule 121 (opt_array_mark -> empty .)
    BREAK           reduce using rule 121 (opt_array_mark -> empty .)
    FOR             reduce using rule 121 (opt_array_mark -> empty .)
    PRINTF          reduce using rule 121 (opt_array_mark -> empty .)
    SCANF           reduce using rule 121 (opt_array_mark -> empty .)
    ID              reduce using rule 121 (opt_array_mark -> empty .)
    IF              reduce using rule 121 (opt_array_mark -> empty .)
    INCREMENT       reduce using rule 121 (opt_array_mark -> empty .)
    DECREMENT       reduce using rule 121 (opt_array_mark -> empty .)
    R_BRACE         reduce using rule 121 (opt_array_mark -> empty .)
    NEGATION        reduce using rule 121 (opt_array_mark -> empty .)
    L_BRACKET       reduce using rule 121 (opt_array_mark -> empty .)
    MINUS           reduce using rule 121 (opt_array_mark -> empty .)
    INTEGER         reduce using rule 121 (opt_array_mark -> empty .)
    DECIMAL         reduce using rule 121 (opt_array_mark -> empty .)
    CHARACTER       reduce using rule 121 (opt_array_mark -> empty .)
    STRING          reduce using rule 121 (opt_array_mark -> empty .)
    TRUE            reduce using rule 121 (opt_array_mark -> empty .)
    FALSE           reduce using rule 121 (opt_array_mark -> empty .)


state 27

    (117) array_mark -> L_SQUARE_BRACKET . opt_value_expression R_SQUARE_BRACKET
    (58) opt_value_expression -> . value_expression
    (59) opt_value_expression -> . empty
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (128) empty -> .
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET

    L_BRACKET       shift and go to state 40
    R_SQUARE_BRACKET reduce using rule 128 (empty -> .)
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 51

    opt_value_expression           shift and go to state 33
    value_expression               shift and go to state 34
    empty                          shift and go to state 35
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49
    logical_expression             shift and go to state 50

state 28

    (124) args -> type . ID
    (125) args -> type . ID COMMA args

    ID              shift and go to state 52


state 29

    (33) function_definition_statement -> type ID L_BRACKET opt_args . R_BRACKET statements_block

    R_BRACKET       shift and go to state 53


state 30

    (126) opt_args -> args .

    R_BRACKET       reduce using rule 126 (opt_args -> args .)


state 31

    (127) opt_args -> empty .

    R_BRACKET       reduce using rule 127 (opt_args -> empty .)


state 32

    (28) declaration_statement -> opt_const type ID opt_array_mark ASSIGN . declaration_value_expression SEMICOLON
    (50) declaration_value_expression -> . value_expression
    (51) declaration_value_expression -> . L_BRACE listed_values R_BRACE
    (52) declaration_value_expression -> . L_BRACE declaration_value_expression R_BRACE
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET

    L_BRACE         shift and go to state 56
    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 51

    declaration_value_expression   shift and go to state 54
    value_expression               shift and go to state 55
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49
    logical_expression             shift and go to state 50

state 33

    (117) array_mark -> L_SQUARE_BRACKET opt_value_expression . R_SQUARE_BRACKET

    R_SQUARE_BRACKET shift and go to state 57


state 34

    (58) opt_value_expression -> value_expression .
    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

    R_SQUARE_BRACKET reduce using rule 58 (opt_value_expression -> value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

    comparison_op                  shift and go to state 58

state 35

    (59) opt_value_expression -> empty .

    R_SQUARE_BRACKET reduce using rule 59 (opt_value_expression -> empty .)


state 36

    (53) value_expression -> math_expression .

    EQUAL           reduce using rule 53 (value_expression -> math_expression .)
    NOT_EQUAL       reduce using rule 53 (value_expression -> math_expression .)
    GREATER         reduce using rule 53 (value_expression -> math_expression .)
    GREATER_EQUAL   reduce using rule 53 (value_expression -> math_expression .)
    LESSER          reduce using rule 53 (value_expression -> math_expression .)
    LESSER_EQUAL    reduce using rule 53 (value_expression -> math_expression .)
    R_SQUARE_BRACKET reduce using rule 53 (value_expression -> math_expression .)
    SEMICOLON       reduce using rule 53 (value_expression -> math_expression .)
    COMMA           reduce using rule 53 (value_expression -> math_expression .)
    R_BRACE         reduce using rule 53 (value_expression -> math_expression .)
    QUESTION_MARK   reduce using rule 53 (value_expression -> math_expression .)
    AND             reduce using rule 53 (value_expression -> math_expression .)
    OR              reduce using rule 53 (value_expression -> math_expression .)
    R_BRACKET       reduce using rule 53 (value_expression -> math_expression .)
    COLON           reduce using rule 53 (value_expression -> math_expression .)


state 37

    (54) value_expression -> function_expression .

    EQUAL           reduce using rule 54 (value_expression -> function_expression .)
    NOT_EQUAL       reduce using rule 54 (value_expression -> function_expression .)
    GREATER         reduce using rule 54 (value_expression -> function_expression .)
    GREATER_EQUAL   reduce using rule 54 (value_expression -> function_expression .)
    LESSER          reduce using rule 54 (value_expression -> function_expression .)
    LESSER_EQUAL    reduce using rule 54 (value_expression -> function_expression .)
    R_SQUARE_BRACKET reduce using rule 54 (value_expression -> function_expression .)
    SEMICOLON       reduce using rule 54 (value_expression -> function_expression .)
    R_BRACKET       reduce using rule 54 (value_expression -> function_expression .)
    COMMA           reduce using rule 54 (value_expression -> function_expression .)
    R_BRACE         reduce using rule 54 (value_expression -> function_expression .)
    QUESTION_MARK   reduce using rule 54 (value_expression -> function_expression .)
    AND             reduce using rule 54 (value_expression -> function_expression .)
    OR              reduce using rule 54 (value_expression -> function_expression .)
    COLON           reduce using rule 54 (value_expression -> function_expression .)


state 38

    (55) value_expression -> value .
    (63) math_expression -> value . math_op value
    (96) math_op -> . PLUS
    (97) math_op -> . MINUS
    (98) math_op -> . MUL
    (99) math_op -> . DIV
    (100) math_op -> . MOD

    EQUAL           reduce using rule 55 (value_expression -> value .)
    NOT_EQUAL       reduce using rule 55 (value_expression -> value .)
    GREATER         reduce using rule 55 (value_expression -> value .)
    GREATER_EQUAL   reduce using rule 55 (value_expression -> value .)
    LESSER          reduce using rule 55 (value_expression -> value .)
    LESSER_EQUAL    reduce using rule 55 (value_expression -> value .)
    R_SQUARE_BRACKET reduce using rule 55 (value_expression -> value .)
    SEMICOLON       reduce using rule 55 (value_expression -> value .)
    R_BRACKET       reduce using rule 55 (value_expression -> value .)
    COMMA           reduce using rule 55 (value_expression -> value .)
    R_BRACE         reduce using rule 55 (value_expression -> value .)
    QUESTION_MARK   reduce using rule 55 (value_expression -> value .)
    AND             reduce using rule 55 (value_expression -> value .)
    OR              reduce using rule 55 (value_expression -> value .)
    COLON           reduce using rule 55 (value_expression -> value .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    MUL             shift and go to state 68
    DIV             shift and go to state 69
    MOD             shift and go to state 70

    math_op                        shift and go to state 65

state 39

    (56) value_expression -> trinary_mark_expression .

    EQUAL           reduce using rule 56 (value_expression -> trinary_mark_expression .)
    NOT_EQUAL       reduce using rule 56 (value_expression -> trinary_mark_expression .)
    GREATER         reduce using rule 56 (value_expression -> trinary_mark_expression .)
    GREATER_EQUAL   reduce using rule 56 (value_expression -> trinary_mark_expression .)
    LESSER          reduce using rule 56 (value_expression -> trinary_mark_expression .)
    LESSER_EQUAL    reduce using rule 56 (value_expression -> trinary_mark_expression .)
    R_SQUARE_BRACKET reduce using rule 56 (value_expression -> trinary_mark_expression .)
    SEMICOLON       reduce using rule 56 (value_expression -> trinary_mark_expression .)
    R_BRACKET       reduce using rule 56 (value_expression -> trinary_mark_expression .)
    COMMA           reduce using rule 56 (value_expression -> trinary_mark_expression .)
    R_BRACE         reduce using rule 56 (value_expression -> trinary_mark_expression .)
    QUESTION_MARK   reduce using rule 56 (value_expression -> trinary_mark_expression .)
    AND             reduce using rule 56 (value_expression -> trinary_mark_expression .)
    OR              reduce using rule 56 (value_expression -> trinary_mark_expression .)
    COLON           reduce using rule 56 (value_expression -> trinary_mark_expression .)


state 40

    (57) value_expression -> L_BRACKET . value_expression R_BRACKET
    (60) math_expression -> L_BRACKET . math_expression R_BRACKET
    (67) logical_expression -> L_BRACKET . logical_expression R_BRACKET
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    NEGATION        shift and go to state 51
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48

    value_expression               shift and go to state 71
    math_expression                shift and go to state 72
    logical_expression             shift and go to state 73
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49

state 41

    (61) math_expression -> MINUS . math_expression
    (62) math_expression -> MINUS . value
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    L_BRACKET       shift and go to state 76
    MINUS           shift and go to state 41
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    ID              shift and go to state 77

    math_expression                shift and go to state 74
    value                          shift and go to state 75
    list_element_extraction        shift and go to state 49

state 42

    (68) function_expression -> ID . L_BRACKET opt_listed_values R_BRACKET
    (91) value -> ID .
    (93) list_element_extraction -> ID . L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    L_BRACKET       shift and go to state 78
    PLUS            reduce using rule 91 (value -> ID .)
    MINUS           reduce using rule 91 (value -> ID .)
    MUL             reduce using rule 91 (value -> ID .)
    DIV             reduce using rule 91 (value -> ID .)
    MOD             reduce using rule 91 (value -> ID .)
    EQUAL           reduce using rule 91 (value -> ID .)
    NOT_EQUAL       reduce using rule 91 (value -> ID .)
    GREATER         reduce using rule 91 (value -> ID .)
    GREATER_EQUAL   reduce using rule 91 (value -> ID .)
    LESSER          reduce using rule 91 (value -> ID .)
    LESSER_EQUAL    reduce using rule 91 (value -> ID .)
    R_SQUARE_BRACKET reduce using rule 91 (value -> ID .)
    SEMICOLON       reduce using rule 91 (value -> ID .)
    R_BRACKET       reduce using rule 91 (value -> ID .)
    COMMA           reduce using rule 91 (value -> ID .)
    R_BRACE         reduce using rule 91 (value -> ID .)
    QUESTION_MARK   reduce using rule 91 (value -> ID .)
    AND             reduce using rule 91 (value -> ID .)
    OR              reduce using rule 91 (value -> ID .)
    COLON           reduce using rule 91 (value -> ID .)
    L_SQUARE_BRACKET shift and go to state 79


state 43

    (85) value -> INTEGER .

    PLUS            reduce using rule 85 (value -> INTEGER .)
    MINUS           reduce using rule 85 (value -> INTEGER .)
    MUL             reduce using rule 85 (value -> INTEGER .)
    DIV             reduce using rule 85 (value -> INTEGER .)
    MOD             reduce using rule 85 (value -> INTEGER .)
    EQUAL           reduce using rule 85 (value -> INTEGER .)
    NOT_EQUAL       reduce using rule 85 (value -> INTEGER .)
    GREATER         reduce using rule 85 (value -> INTEGER .)
    GREATER_EQUAL   reduce using rule 85 (value -> INTEGER .)
    LESSER          reduce using rule 85 (value -> INTEGER .)
    LESSER_EQUAL    reduce using rule 85 (value -> INTEGER .)
    R_SQUARE_BRACKET reduce using rule 85 (value -> INTEGER .)
    SEMICOLON       reduce using rule 85 (value -> INTEGER .)
    R_BRACKET       reduce using rule 85 (value -> INTEGER .)
    COMMA           reduce using rule 85 (value -> INTEGER .)
    R_BRACE         reduce using rule 85 (value -> INTEGER .)
    QUESTION_MARK   reduce using rule 85 (value -> INTEGER .)
    AND             reduce using rule 85 (value -> INTEGER .)
    OR              reduce using rule 85 (value -> INTEGER .)
    COLON           reduce using rule 85 (value -> INTEGER .)


state 44

    (86) value -> DECIMAL .

    PLUS            reduce using rule 86 (value -> DECIMAL .)
    MINUS           reduce using rule 86 (value -> DECIMAL .)
    MUL             reduce using rule 86 (value -> DECIMAL .)
    DIV             reduce using rule 86 (value -> DECIMAL .)
    MOD             reduce using rule 86 (value -> DECIMAL .)
    EQUAL           reduce using rule 86 (value -> DECIMAL .)
    NOT_EQUAL       reduce using rule 86 (value -> DECIMAL .)
    GREATER         reduce using rule 86 (value -> DECIMAL .)
    GREATER_EQUAL   reduce using rule 86 (value -> DECIMAL .)
    LESSER          reduce using rule 86 (value -> DECIMAL .)
    LESSER_EQUAL    reduce using rule 86 (value -> DECIMAL .)
    R_SQUARE_BRACKET reduce using rule 86 (value -> DECIMAL .)
    SEMICOLON       reduce using rule 86 (value -> DECIMAL .)
    R_BRACKET       reduce using rule 86 (value -> DECIMAL .)
    COMMA           reduce using rule 86 (value -> DECIMAL .)
    R_BRACE         reduce using rule 86 (value -> DECIMAL .)
    QUESTION_MARK   reduce using rule 86 (value -> DECIMAL .)
    AND             reduce using rule 86 (value -> DECIMAL .)
    OR              reduce using rule 86 (value -> DECIMAL .)
    COLON           reduce using rule 86 (value -> DECIMAL .)


state 45

    (87) value -> CHARACTER .

    PLUS            reduce using rule 87 (value -> CHARACTER .)
    MINUS           reduce using rule 87 (value -> CHARACTER .)
    MUL             reduce using rule 87 (value -> CHARACTER .)
    DIV             reduce using rule 87 (value -> CHARACTER .)
    MOD             reduce using rule 87 (value -> CHARACTER .)
    EQUAL           reduce using rule 87 (value -> CHARACTER .)
    NOT_EQUAL       reduce using rule 87 (value -> CHARACTER .)
    GREATER         reduce using rule 87 (value -> CHARACTER .)
    GREATER_EQUAL   reduce using rule 87 (value -> CHARACTER .)
    LESSER          reduce using rule 87 (value -> CHARACTER .)
    LESSER_EQUAL    reduce using rule 87 (value -> CHARACTER .)
    R_SQUARE_BRACKET reduce using rule 87 (value -> CHARACTER .)
    SEMICOLON       reduce using rule 87 (value -> CHARACTER .)
    R_BRACKET       reduce using rule 87 (value -> CHARACTER .)
    COMMA           reduce using rule 87 (value -> CHARACTER .)
    R_BRACE         reduce using rule 87 (value -> CHARACTER .)
    QUESTION_MARK   reduce using rule 87 (value -> CHARACTER .)
    AND             reduce using rule 87 (value -> CHARACTER .)
    OR              reduce using rule 87 (value -> CHARACTER .)
    COLON           reduce using rule 87 (value -> CHARACTER .)


state 46

    (88) value -> STRING .

    PLUS            reduce using rule 88 (value -> STRING .)
    MINUS           reduce using rule 88 (value -> STRING .)
    MUL             reduce using rule 88 (value -> STRING .)
    DIV             reduce using rule 88 (value -> STRING .)
    MOD             reduce using rule 88 (value -> STRING .)
    EQUAL           reduce using rule 88 (value -> STRING .)
    NOT_EQUAL       reduce using rule 88 (value -> STRING .)
    GREATER         reduce using rule 88 (value -> STRING .)
    GREATER_EQUAL   reduce using rule 88 (value -> STRING .)
    LESSER          reduce using rule 88 (value -> STRING .)
    LESSER_EQUAL    reduce using rule 88 (value -> STRING .)
    R_SQUARE_BRACKET reduce using rule 88 (value -> STRING .)
    SEMICOLON       reduce using rule 88 (value -> STRING .)
    R_BRACKET       reduce using rule 88 (value -> STRING .)
    COMMA           reduce using rule 88 (value -> STRING .)
    R_BRACE         reduce using rule 88 (value -> STRING .)
    QUESTION_MARK   reduce using rule 88 (value -> STRING .)
    AND             reduce using rule 88 (value -> STRING .)
    OR              reduce using rule 88 (value -> STRING .)
    COLON           reduce using rule 88 (value -> STRING .)


state 47

    (89) value -> TRUE .

    PLUS            reduce using rule 89 (value -> TRUE .)
    MINUS           reduce using rule 89 (value -> TRUE .)
    MUL             reduce using rule 89 (value -> TRUE .)
    DIV             reduce using rule 89 (value -> TRUE .)
    MOD             reduce using rule 89 (value -> TRUE .)
    EQUAL           reduce using rule 89 (value -> TRUE .)
    NOT_EQUAL       reduce using rule 89 (value -> TRUE .)
    GREATER         reduce using rule 89 (value -> TRUE .)
    GREATER_EQUAL   reduce using rule 89 (value -> TRUE .)
    LESSER          reduce using rule 89 (value -> TRUE .)
    LESSER_EQUAL    reduce using rule 89 (value -> TRUE .)
    R_SQUARE_BRACKET reduce using rule 89 (value -> TRUE .)
    SEMICOLON       reduce using rule 89 (value -> TRUE .)
    R_BRACKET       reduce using rule 89 (value -> TRUE .)
    COMMA           reduce using rule 89 (value -> TRUE .)
    R_BRACE         reduce using rule 89 (value -> TRUE .)
    QUESTION_MARK   reduce using rule 89 (value -> TRUE .)
    AND             reduce using rule 89 (value -> TRUE .)
    OR              reduce using rule 89 (value -> TRUE .)
    COLON           reduce using rule 89 (value -> TRUE .)


state 48

    (90) value -> FALSE .

    PLUS            reduce using rule 90 (value -> FALSE .)
    MINUS           reduce using rule 90 (value -> FALSE .)
    MUL             reduce using rule 90 (value -> FALSE .)
    DIV             reduce using rule 90 (value -> FALSE .)
    MOD             reduce using rule 90 (value -> FALSE .)
    EQUAL           reduce using rule 90 (value -> FALSE .)
    NOT_EQUAL       reduce using rule 90 (value -> FALSE .)
    GREATER         reduce using rule 90 (value -> FALSE .)
    GREATER_EQUAL   reduce using rule 90 (value -> FALSE .)
    LESSER          reduce using rule 90 (value -> FALSE .)
    LESSER_EQUAL    reduce using rule 90 (value -> FALSE .)
    R_SQUARE_BRACKET reduce using rule 90 (value -> FALSE .)
    SEMICOLON       reduce using rule 90 (value -> FALSE .)
    R_BRACKET       reduce using rule 90 (value -> FALSE .)
    COMMA           reduce using rule 90 (value -> FALSE .)
    R_BRACE         reduce using rule 90 (value -> FALSE .)
    QUESTION_MARK   reduce using rule 90 (value -> FALSE .)
    AND             reduce using rule 90 (value -> FALSE .)
    OR              reduce using rule 90 (value -> FALSE .)
    COLON           reduce using rule 90 (value -> FALSE .)


state 49

    (92) value -> list_element_extraction .

    PLUS            reduce using rule 92 (value -> list_element_extraction .)
    MINUS           reduce using rule 92 (value -> list_element_extraction .)
    MUL             reduce using rule 92 (value -> list_element_extraction .)
    DIV             reduce using rule 92 (value -> list_element_extraction .)
    MOD             reduce using rule 92 (value -> list_element_extraction .)
    EQUAL           reduce using rule 92 (value -> list_element_extraction .)
    NOT_EQUAL       reduce using rule 92 (value -> list_element_extraction .)
    GREATER         reduce using rule 92 (value -> list_element_extraction .)
    GREATER_EQUAL   reduce using rule 92 (value -> list_element_extraction .)
    LESSER          reduce using rule 92 (value -> list_element_extraction .)
    LESSER_EQUAL    reduce using rule 92 (value -> list_element_extraction .)
    R_SQUARE_BRACKET reduce using rule 92 (value -> list_element_extraction .)
    SEMICOLON       reduce using rule 92 (value -> list_element_extraction .)
    R_BRACKET       reduce using rule 92 (value -> list_element_extraction .)
    COMMA           reduce using rule 92 (value -> list_element_extraction .)
    R_BRACE         reduce using rule 92 (value -> list_element_extraction .)
    QUESTION_MARK   reduce using rule 92 (value -> list_element_extraction .)
    AND             reduce using rule 92 (value -> list_element_extraction .)
    OR              reduce using rule 92 (value -> list_element_extraction .)
    COLON           reduce using rule 92 (value -> list_element_extraction .)


state 50

    (69) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (103) bool_op -> . AND
    (104) bool_op -> . OR

    QUESTION_MARK   shift and go to state 80
    AND             shift and go to state 82
    OR              shift and go to state 83

    bool_op                        shift and go to state 81

state 51

    (65) logical_expression -> NEGATION . logical_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    NEGATION        shift and go to state 51
    L_BRACKET       shift and go to state 86
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48

    logical_expression             shift and go to state 84
    value_expression               shift and go to state 85
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49

state 52

    (124) args -> type ID .
    (125) args -> type ID . COMMA args

    R_BRACKET       reduce using rule 124 (args -> type ID .)
    COMMA           shift and go to state 87


state 53

    (33) function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 89

    statements_block               shift and go to state 88

state 54

    (28) declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression . SEMICOLON

    SEMICOLON       shift and go to state 90


state 55

    (50) declaration_value_expression -> value_expression .
    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

    SEMICOLON       reduce using rule 50 (declaration_value_expression -> value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

    comparison_op                  shift and go to state 58

state 56

    (51) declaration_value_expression -> L_BRACE . listed_values R_BRACE
    (52) declaration_value_expression -> L_BRACE . declaration_value_expression R_BRACE
    (94) listed_values -> . value_expression COMMA value_expression
    (95) listed_values -> . value_expression COMMA listed_values
    (50) declaration_value_expression -> . value_expression
    (51) declaration_value_expression -> . L_BRACE listed_values R_BRACE
    (52) declaration_value_expression -> . L_BRACE declaration_value_expression R_BRACE
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET

    L_BRACE         shift and go to state 56
    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 51

    listed_values                  shift and go to state 91
    declaration_value_expression   shift and go to state 92
    value_expression               shift and go to state 93
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49
    logical_expression             shift and go to state 50

state 57

    (117) array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .

    ASSIGN          reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    COMMENT         reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    PREPROCESSOR_LINE reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    CONST           reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    INT             reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    FLOAT           reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    DOUBLE          reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    CHAR            reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    BOOL            reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    LONG            reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    VOID            reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    $end            reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    SEMICOLON       reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    RETURN          reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    WHILE           reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    DO              reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    BREAK           reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    FOR             reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    PRINTF          reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    SCANF           reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    ID              reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    IF              reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    INCREMENT       reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    DECREMENT       reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    R_BRACE         reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    NEGATION        reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    L_BRACKET       reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    MINUS           reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    INTEGER         reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    DECIMAL         reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    CHARACTER       reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    STRING          reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    TRUE            reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    FALSE           reduce using rule 117 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)


state 58

    (66) logical_expression -> value_expression comparison_op . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 51

    value_expression               shift and go to state 94
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49
    logical_expression             shift and go to state 50

state 59

    (105) comparison_op -> EQUAL .

    L_BRACKET       reduce using rule 105 (comparison_op -> EQUAL .)
    MINUS           reduce using rule 105 (comparison_op -> EQUAL .)
    ID              reduce using rule 105 (comparison_op -> EQUAL .)
    INTEGER         reduce using rule 105 (comparison_op -> EQUAL .)
    DECIMAL         reduce using rule 105 (comparison_op -> EQUAL .)
    CHARACTER       reduce using rule 105 (comparison_op -> EQUAL .)
    STRING          reduce using rule 105 (comparison_op -> EQUAL .)
    TRUE            reduce using rule 105 (comparison_op -> EQUAL .)
    FALSE           reduce using rule 105 (comparison_op -> EQUAL .)
    NEGATION        reduce using rule 105 (comparison_op -> EQUAL .)


state 60

    (106) comparison_op -> NOT_EQUAL .

    L_BRACKET       reduce using rule 106 (comparison_op -> NOT_EQUAL .)
    MINUS           reduce using rule 106 (comparison_op -> NOT_EQUAL .)
    ID              reduce using rule 106 (comparison_op -> NOT_EQUAL .)
    INTEGER         reduce using rule 106 (comparison_op -> NOT_EQUAL .)
    DECIMAL         reduce using rule 106 (comparison_op -> NOT_EQUAL .)
    CHARACTER       reduce using rule 106 (comparison_op -> NOT_EQUAL .)
    STRING          reduce using rule 106 (comparison_op -> NOT_EQUAL .)
    TRUE            reduce using rule 106 (comparison_op -> NOT_EQUAL .)
    FALSE           reduce using rule 106 (comparison_op -> NOT_EQUAL .)
    NEGATION        reduce using rule 106 (comparison_op -> NOT_EQUAL .)


state 61

    (107) comparison_op -> GREATER .

    L_BRACKET       reduce using rule 107 (comparison_op -> GREATER .)
    MINUS           reduce using rule 107 (comparison_op -> GREATER .)
    ID              reduce using rule 107 (comparison_op -> GREATER .)
    INTEGER         reduce using rule 107 (comparison_op -> GREATER .)
    DECIMAL         reduce using rule 107 (comparison_op -> GREATER .)
    CHARACTER       reduce using rule 107 (comparison_op -> GREATER .)
    STRING          reduce using rule 107 (comparison_op -> GREATER .)
    TRUE            reduce using rule 107 (comparison_op -> GREATER .)
    FALSE           reduce using rule 107 (comparison_op -> GREATER .)
    NEGATION        reduce using rule 107 (comparison_op -> GREATER .)


state 62

    (108) comparison_op -> GREATER_EQUAL .

    L_BRACKET       reduce using rule 108 (comparison_op -> GREATER_EQUAL .)
    MINUS           reduce using rule 108 (comparison_op -> GREATER_EQUAL .)
    ID              reduce using rule 108 (comparison_op -> GREATER_EQUAL .)
    INTEGER         reduce using rule 108 (comparison_op -> GREATER_EQUAL .)
    DECIMAL         reduce using rule 108 (comparison_op -> GREATER_EQUAL .)
    CHARACTER       reduce using rule 108 (comparison_op -> GREATER_EQUAL .)
    STRING          reduce using rule 108 (comparison_op -> GREATER_EQUAL .)
    TRUE            reduce using rule 108 (comparison_op -> GREATER_EQUAL .)
    FALSE           reduce using rule 108 (comparison_op -> GREATER_EQUAL .)
    NEGATION        reduce using rule 108 (comparison_op -> GREATER_EQUAL .)


state 63

    (109) comparison_op -> LESSER .

    L_BRACKET       reduce using rule 109 (comparison_op -> LESSER .)
    MINUS           reduce using rule 109 (comparison_op -> LESSER .)
    ID              reduce using rule 109 (comparison_op -> LESSER .)
    INTEGER         reduce using rule 109 (comparison_op -> LESSER .)
    DECIMAL         reduce using rule 109 (comparison_op -> LESSER .)
    CHARACTER       reduce using rule 109 (comparison_op -> LESSER .)
    STRING          reduce using rule 109 (comparison_op -> LESSER .)
    TRUE            reduce using rule 109 (comparison_op -> LESSER .)
    FALSE           reduce using rule 109 (comparison_op -> LESSER .)
    NEGATION        reduce using rule 109 (comparison_op -> LESSER .)


state 64

    (110) comparison_op -> LESSER_EQUAL .

    L_BRACKET       reduce using rule 110 (comparison_op -> LESSER_EQUAL .)
    MINUS           reduce using rule 110 (comparison_op -> LESSER_EQUAL .)
    ID              reduce using rule 110 (comparison_op -> LESSER_EQUAL .)
    INTEGER         reduce using rule 110 (comparison_op -> LESSER_EQUAL .)
    DECIMAL         reduce using rule 110 (comparison_op -> LESSER_EQUAL .)
    CHARACTER       reduce using rule 110 (comparison_op -> LESSER_EQUAL .)
    STRING          reduce using rule 110 (comparison_op -> LESSER_EQUAL .)
    TRUE            reduce using rule 110 (comparison_op -> LESSER_EQUAL .)
    FALSE           reduce using rule 110 (comparison_op -> LESSER_EQUAL .)
    NEGATION        reduce using rule 110 (comparison_op -> LESSER_EQUAL .)


state 65

    (63) math_expression -> value math_op . value
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    ID              shift and go to state 77

    value                          shift and go to state 95
    list_element_extraction        shift and go to state 49

state 66

    (96) math_op -> PLUS .

    INTEGER         reduce using rule 96 (math_op -> PLUS .)
    DECIMAL         reduce using rule 96 (math_op -> PLUS .)
    CHARACTER       reduce using rule 96 (math_op -> PLUS .)
    STRING          reduce using rule 96 (math_op -> PLUS .)
    TRUE            reduce using rule 96 (math_op -> PLUS .)
    FALSE           reduce using rule 96 (math_op -> PLUS .)
    ID              reduce using rule 96 (math_op -> PLUS .)


state 67

    (97) math_op -> MINUS .

    INTEGER         reduce using rule 97 (math_op -> MINUS .)
    DECIMAL         reduce using rule 97 (math_op -> MINUS .)
    CHARACTER       reduce using rule 97 (math_op -> MINUS .)
    STRING          reduce using rule 97 (math_op -> MINUS .)
    TRUE            reduce using rule 97 (math_op -> MINUS .)
    FALSE           reduce using rule 97 (math_op -> MINUS .)
    ID              reduce using rule 97 (math_op -> MINUS .)


state 68

    (98) math_op -> MUL .

    INTEGER         reduce using rule 98 (math_op -> MUL .)
    DECIMAL         reduce using rule 98 (math_op -> MUL .)
    CHARACTER       reduce using rule 98 (math_op -> MUL .)
    STRING          reduce using rule 98 (math_op -> MUL .)
    TRUE            reduce using rule 98 (math_op -> MUL .)
    FALSE           reduce using rule 98 (math_op -> MUL .)
    ID              reduce using rule 98 (math_op -> MUL .)


state 69

    (99) math_op -> DIV .

    INTEGER         reduce using rule 99 (math_op -> DIV .)
    DECIMAL         reduce using rule 99 (math_op -> DIV .)
    CHARACTER       reduce using rule 99 (math_op -> DIV .)
    STRING          reduce using rule 99 (math_op -> DIV .)
    TRUE            reduce using rule 99 (math_op -> DIV .)
    FALSE           reduce using rule 99 (math_op -> DIV .)
    ID              reduce using rule 99 (math_op -> DIV .)


state 70

    (100) math_op -> MOD .

    INTEGER         reduce using rule 100 (math_op -> MOD .)
    DECIMAL         reduce using rule 100 (math_op -> MOD .)
    CHARACTER       reduce using rule 100 (math_op -> MOD .)
    STRING          reduce using rule 100 (math_op -> MOD .)
    TRUE            reduce using rule 100 (math_op -> MOD .)
    FALSE           reduce using rule 100 (math_op -> MOD .)
    ID              reduce using rule 100 (math_op -> MOD .)


state 71

    (57) value_expression -> L_BRACKET value_expression . R_BRACKET
    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

    R_BRACKET       shift and go to state 96
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

    comparison_op                  shift and go to state 58

state 72

    (60) math_expression -> L_BRACKET math_expression . R_BRACKET
    (53) value_expression -> math_expression .

  ! shift/reduce conflict for R_BRACKET resolved as shift
    R_BRACKET       shift and go to state 97
    EQUAL           reduce using rule 53 (value_expression -> math_expression .)
    NOT_EQUAL       reduce using rule 53 (value_expression -> math_expression .)
    GREATER         reduce using rule 53 (value_expression -> math_expression .)
    GREATER_EQUAL   reduce using rule 53 (value_expression -> math_expression .)
    LESSER          reduce using rule 53 (value_expression -> math_expression .)
    LESSER_EQUAL    reduce using rule 53 (value_expression -> math_expression .)

  ! R_BRACKET       [ reduce using rule 53 (value_expression -> math_expression .) ]


state 73

    (67) logical_expression -> L_BRACKET logical_expression . R_BRACKET
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (69) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (103) bool_op -> . AND
    (104) bool_op -> . OR

    R_BRACKET       shift and go to state 98
    QUESTION_MARK   shift and go to state 80
    AND             shift and go to state 82
    OR              shift and go to state 83

    bool_op                        shift and go to state 81

state 74

    (61) math_expression -> MINUS math_expression .

    EQUAL           reduce using rule 61 (math_expression -> MINUS math_expression .)
    NOT_EQUAL       reduce using rule 61 (math_expression -> MINUS math_expression .)
    GREATER         reduce using rule 61 (math_expression -> MINUS math_expression .)
    GREATER_EQUAL   reduce using rule 61 (math_expression -> MINUS math_expression .)
    LESSER          reduce using rule 61 (math_expression -> MINUS math_expression .)
    LESSER_EQUAL    reduce using rule 61 (math_expression -> MINUS math_expression .)
    R_SQUARE_BRACKET reduce using rule 61 (math_expression -> MINUS math_expression .)
    SEMICOLON       reduce using rule 61 (math_expression -> MINUS math_expression .)
    R_BRACKET       reduce using rule 61 (math_expression -> MINUS math_expression .)
    COMMA           reduce using rule 61 (math_expression -> MINUS math_expression .)
    R_BRACE         reduce using rule 61 (math_expression -> MINUS math_expression .)
    QUESTION_MARK   reduce using rule 61 (math_expression -> MINUS math_expression .)
    AND             reduce using rule 61 (math_expression -> MINUS math_expression .)
    OR              reduce using rule 61 (math_expression -> MINUS math_expression .)
    COLON           reduce using rule 61 (math_expression -> MINUS math_expression .)


state 75

    (62) math_expression -> MINUS value .
    (63) math_expression -> value . math_op value
    (96) math_op -> . PLUS
    (97) math_op -> . MINUS
    (98) math_op -> . MUL
    (99) math_op -> . DIV
    (100) math_op -> . MOD

    EQUAL           reduce using rule 62 (math_expression -> MINUS value .)
    NOT_EQUAL       reduce using rule 62 (math_expression -> MINUS value .)
    GREATER         reduce using rule 62 (math_expression -> MINUS value .)
    GREATER_EQUAL   reduce using rule 62 (math_expression -> MINUS value .)
    LESSER          reduce using rule 62 (math_expression -> MINUS value .)
    LESSER_EQUAL    reduce using rule 62 (math_expression -> MINUS value .)
    R_SQUARE_BRACKET reduce using rule 62 (math_expression -> MINUS value .)
    SEMICOLON       reduce using rule 62 (math_expression -> MINUS value .)
    R_BRACKET       reduce using rule 62 (math_expression -> MINUS value .)
    COMMA           reduce using rule 62 (math_expression -> MINUS value .)
    R_BRACE         reduce using rule 62 (math_expression -> MINUS value .)
    QUESTION_MARK   reduce using rule 62 (math_expression -> MINUS value .)
    AND             reduce using rule 62 (math_expression -> MINUS value .)
    OR              reduce using rule 62 (math_expression -> MINUS value .)
    COLON           reduce using rule 62 (math_expression -> MINUS value .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    MUL             shift and go to state 68
    DIV             shift and go to state 69
    MOD             shift and go to state 70

    math_op                        shift and go to state 65

state 76

    (60) math_expression -> L_BRACKET . math_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    L_BRACKET       shift and go to state 76
    MINUS           shift and go to state 41
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    ID              shift and go to state 77

    math_expression                shift and go to state 99
    value                          shift and go to state 100
    list_element_extraction        shift and go to state 49

state 77

    (91) value -> ID .
    (93) list_element_extraction -> ID . L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    PLUS            reduce using rule 91 (value -> ID .)
    MINUS           reduce using rule 91 (value -> ID .)
    MUL             reduce using rule 91 (value -> ID .)
    DIV             reduce using rule 91 (value -> ID .)
    MOD             reduce using rule 91 (value -> ID .)
    EQUAL           reduce using rule 91 (value -> ID .)
    NOT_EQUAL       reduce using rule 91 (value -> ID .)
    GREATER         reduce using rule 91 (value -> ID .)
    GREATER_EQUAL   reduce using rule 91 (value -> ID .)
    LESSER          reduce using rule 91 (value -> ID .)
    LESSER_EQUAL    reduce using rule 91 (value -> ID .)
    R_SQUARE_BRACKET reduce using rule 91 (value -> ID .)
    SEMICOLON       reduce using rule 91 (value -> ID .)
    R_BRACKET       reduce using rule 91 (value -> ID .)
    COMMA           reduce using rule 91 (value -> ID .)
    R_BRACE         reduce using rule 91 (value -> ID .)
    QUESTION_MARK   reduce using rule 91 (value -> ID .)
    AND             reduce using rule 91 (value -> ID .)
    OR              reduce using rule 91 (value -> ID .)
    COLON           reduce using rule 91 (value -> ID .)
    L_SQUARE_BRACKET shift and go to state 79


state 78

    (68) function_expression -> ID L_BRACKET . opt_listed_values R_BRACKET
    (122) opt_listed_values -> . listed_values
    (123) opt_listed_values -> . empty
    (94) listed_values -> . value_expression COMMA value_expression
    (95) listed_values -> . value_expression COMMA listed_values
    (128) empty -> .
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET

    R_BRACKET       reduce using rule 128 (empty -> .)
    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 51

    opt_listed_values              shift and go to state 101
    listed_values                  shift and go to state 102
    empty                          shift and go to state 103
    value_expression               shift and go to state 104
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49
    logical_expression             shift and go to state 50

state 79

    (93) list_element_extraction -> ID L_SQUARE_BRACKET . value_expression R_SQUARE_BRACKET
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 51

    value_expression               shift and go to state 105
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49
    logical_expression             shift and go to state 50

state 80

    (69) trinary_mark_expression -> logical_expression QUESTION_MARK . value_expression COLON value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 51

    logical_expression             shift and go to state 50
    value_expression               shift and go to state 106
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49

state 81

    (64) logical_expression -> logical_expression bool_op . logical_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    NEGATION        shift and go to state 51
    L_BRACKET       shift and go to state 86
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48

    logical_expression             shift and go to state 107
    value_expression               shift and go to state 85
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49

state 82

    (103) bool_op -> AND .

    NEGATION        reduce using rule 103 (bool_op -> AND .)
    L_BRACKET       reduce using rule 103 (bool_op -> AND .)
    MINUS           reduce using rule 103 (bool_op -> AND .)
    ID              reduce using rule 103 (bool_op -> AND .)
    INTEGER         reduce using rule 103 (bool_op -> AND .)
    DECIMAL         reduce using rule 103 (bool_op -> AND .)
    CHARACTER       reduce using rule 103 (bool_op -> AND .)
    STRING          reduce using rule 103 (bool_op -> AND .)
    TRUE            reduce using rule 103 (bool_op -> AND .)
    FALSE           reduce using rule 103 (bool_op -> AND .)


state 83

    (104) bool_op -> OR .

    NEGATION        reduce using rule 104 (bool_op -> OR .)
    L_BRACKET       reduce using rule 104 (bool_op -> OR .)
    MINUS           reduce using rule 104 (bool_op -> OR .)
    ID              reduce using rule 104 (bool_op -> OR .)
    INTEGER         reduce using rule 104 (bool_op -> OR .)
    DECIMAL         reduce using rule 104 (bool_op -> OR .)
    CHARACTER       reduce using rule 104 (bool_op -> OR .)
    STRING          reduce using rule 104 (bool_op -> OR .)
    TRUE            reduce using rule 104 (bool_op -> OR .)
    FALSE           reduce using rule 104 (bool_op -> OR .)


state 84

    (65) logical_expression -> NEGATION logical_expression .
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (69) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (103) bool_op -> . AND
    (104) bool_op -> . OR

  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    R_BRACKET       reduce using rule 65 (logical_expression -> NEGATION logical_expression .)
    SEMICOLON       reduce using rule 65 (logical_expression -> NEGATION logical_expression .)
    QUESTION_MARK   shift and go to state 80
    AND             shift and go to state 82
    OR              shift and go to state 83

  ! QUESTION_MARK   [ reduce using rule 65 (logical_expression -> NEGATION logical_expression .) ]
  ! AND             [ reduce using rule 65 (logical_expression -> NEGATION logical_expression .) ]
  ! OR              [ reduce using rule 65 (logical_expression -> NEGATION logical_expression .) ]

    bool_op                        shift and go to state 81

state 85

    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

    comparison_op                  shift and go to state 58

state 86

    (67) logical_expression -> L_BRACKET . logical_expression R_BRACKET
    (57) value_expression -> L_BRACKET . value_expression R_BRACKET
    (60) math_expression -> L_BRACKET . math_expression R_BRACKET
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    NEGATION        shift and go to state 51
    L_BRACKET       shift and go to state 86
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48

    logical_expression             shift and go to state 73
    value_expression               shift and go to state 71
    math_expression                shift and go to state 72
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49

state 87

    (125) args -> type ID COMMA . args
    (124) args -> . type ID
    (125) args -> . type ID COMMA args
    (78) type -> . INT
    (79) type -> . FLOAT
    (80) type -> . DOUBLE
    (81) type -> . CHAR
    (82) type -> . BOOL
    (83) type -> . LONG
    (84) type -> . VOID

    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

    type                           shift and go to state 28
    args                           shift and go to state 108

state 88

    (33) function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .

    COMMENT         reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    PREPROCESSOR_LINE reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    CONST           reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    INT             reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    FLOAT           reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    DOUBLE          reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    CHAR            reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    BOOL            reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    LONG            reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    VOID            reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    $end            reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)


state 89

    (15) statements_block -> L_BRACE . opt_statements R_BRACE
    (13) opt_statements -> . statements
    (14) opt_statements -> . empty
    (11) statements -> . statement
    (12) statements -> . statement statements
    (128) empty -> .
    (8) statement -> . any_statement
    (9) statement -> . COMMENT
    (10) statement -> . SEMICOLON
    (16) any_statement -> . declaration_statement
    (17) any_statement -> . assign_statement
    (18) any_statement -> . function_statement
    (19) any_statement -> . return_statement
    (20) any_statement -> . while_loop_statement
    (21) any_statement -> . do_while_loop_statement
    (22) any_statement -> . break_statement
    (23) any_statement -> . for_loop_statement
    (24) any_statement -> . if_statement_block
    (25) any_statement -> . print_statement
    (26) any_statement -> . scan_statement
    (27) declaration_statement -> . opt_const type ID opt_array_mark
    (28) declaration_statement -> . opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (29) assign_statement -> . assign_expression SEMICOLON
    (30) function_statement -> . function_expression SEMICOLON
    (31) return_statement -> . RETURN value_expression SEMICOLON
    (34) while_loop_statement -> . WHILE L_BRACKET logical_expression R_BRACKET statements_block
    (35) do_while_loop_statement -> . DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON
    (32) break_statement -> . BREAK SEMICOLON
    (36) for_loop_statement -> . FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block
    (39) if_statement_block -> . if_statement
    (40) if_statement_block -> . if_statement else_else_if_statements_block
    (48) print_statement -> . PRINTF L_BRACKET value_expression R_BRACKET
    (49) scan_statement -> . SCANF L_BRACKET AMPERSAND ID R_BRACKET
    (118) opt_const -> . CONST
    (119) opt_const -> . empty
    (70) assign_expression -> . ID assign_op value_expression
    (71) assign_expression -> . list_element_extraction assign_op value_expression
    (72) assign_expression -> . unary_op ID
    (73) assign_expression -> . ID unary_op
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (41) if_statement -> . IF L_BRACKET logical_expression R_BRACKET statements_block
    (42) if_statement -> . IF L_BRACKET value_expression R_BRACKET statements_block
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (101) unary_op -> . INCREMENT
    (102) unary_op -> . DECREMENT

    R_BRACE         reduce using rule 128 (empty -> .)
    INT             reduce using rule 128 (empty -> .)
    FLOAT           reduce using rule 128 (empty -> .)
    DOUBLE          reduce using rule 128 (empty -> .)
    CHAR            reduce using rule 128 (empty -> .)
    BOOL            reduce using rule 128 (empty -> .)
    LONG            reduce using rule 128 (empty -> .)
    VOID            reduce using rule 128 (empty -> .)
    COMMENT         shift and go to state 114
    SEMICOLON       shift and go to state 115
    RETURN          shift and go to state 130
    WHILE           shift and go to state 131
    DO              shift and go to state 132
    BREAK           shift and go to state 133
    FOR             shift and go to state 134
    PRINTF          shift and go to state 136
    SCANF           shift and go to state 137
    CONST           shift and go to state 10
    ID              shift and go to state 127
    IF              shift and go to state 140
    INCREMENT       shift and go to state 141
    DECREMENT       shift and go to state 142

    opt_statements                 shift and go to state 109
    statements                     shift and go to state 110
    empty                          shift and go to state 111
    statement                      shift and go to state 112
    any_statement                  shift and go to state 113
    declaration_statement          shift and go to state 116
    assign_statement               shift and go to state 117
    function_statement             shift and go to state 118
    return_statement               shift and go to state 119
    while_loop_statement           shift and go to state 120
    do_while_loop_statement        shift and go to state 121
    break_statement                shift and go to state 122
    for_loop_statement             shift and go to state 123
    if_statement_block             shift and go to state 124
    print_statement                shift and go to state 125
    scan_statement                 shift and go to state 126
    opt_const                      shift and go to state 8
    assign_expression              shift and go to state 128
    function_expression            shift and go to state 129
    if_statement                   shift and go to state 135
    list_element_extraction        shift and go to state 138
    unary_op                       shift and go to state 139

state 90

    (28) declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .

    COMMENT         reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    PREPROCESSOR_LINE reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    CONST           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    INT             reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    FLOAT           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    DOUBLE          reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    CHAR            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    BOOL            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    LONG            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    VOID            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    $end            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    SEMICOLON       reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    RETURN          reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    WHILE           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    DO              reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    BREAK           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    FOR             reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    PRINTF          reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    SCANF           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    ID              reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    IF              reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    INCREMENT       reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    DECREMENT       reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    R_BRACE         reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    NEGATION        reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    L_BRACKET       reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    MINUS           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    INTEGER         reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    DECIMAL         reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    CHARACTER       reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    STRING          reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    TRUE            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    FALSE           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)


state 91

    (51) declaration_value_expression -> L_BRACE listed_values . R_BRACE

    R_BRACE         shift and go to state 143


state 92

    (52) declaration_value_expression -> L_BRACE declaration_value_expression . R_BRACE

    R_BRACE         shift and go to state 144


state 93

    (94) listed_values -> value_expression . COMMA value_expression
    (95) listed_values -> value_expression . COMMA listed_values
    (50) declaration_value_expression -> value_expression .
    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

    COMMA           shift and go to state 145
    R_BRACE         reduce using rule 50 (declaration_value_expression -> value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

    comparison_op                  shift and go to state 58

state 94

    (66) logical_expression -> value_expression comparison_op value_expression .
    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

    QUESTION_MARK   reduce using rule 66 (logical_expression -> value_expression comparison_op value_expression .)
    AND             reduce using rule 66 (logical_expression -> value_expression comparison_op value_expression .)
    OR              reduce using rule 66 (logical_expression -> value_expression comparison_op value_expression .)
    R_BRACKET       reduce using rule 66 (logical_expression -> value_expression comparison_op value_expression .)
    SEMICOLON       reduce using rule 66 (logical_expression -> value_expression comparison_op value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

    comparison_op                  shift and go to state 58

state 95

    (63) math_expression -> value math_op value .

    EQUAL           reduce using rule 63 (math_expression -> value math_op value .)
    NOT_EQUAL       reduce using rule 63 (math_expression -> value math_op value .)
    GREATER         reduce using rule 63 (math_expression -> value math_op value .)
    GREATER_EQUAL   reduce using rule 63 (math_expression -> value math_op value .)
    LESSER          reduce using rule 63 (math_expression -> value math_op value .)
    LESSER_EQUAL    reduce using rule 63 (math_expression -> value math_op value .)
    R_SQUARE_BRACKET reduce using rule 63 (math_expression -> value math_op value .)
    SEMICOLON       reduce using rule 63 (math_expression -> value math_op value .)
    R_BRACKET       reduce using rule 63 (math_expression -> value math_op value .)
    COMMA           reduce using rule 63 (math_expression -> value math_op value .)
    R_BRACE         reduce using rule 63 (math_expression -> value math_op value .)
    QUESTION_MARK   reduce using rule 63 (math_expression -> value math_op value .)
    AND             reduce using rule 63 (math_expression -> value math_op value .)
    OR              reduce using rule 63 (math_expression -> value math_op value .)
    COLON           reduce using rule 63 (math_expression -> value math_op value .)


state 96

    (57) value_expression -> L_BRACKET value_expression R_BRACKET .

    EQUAL           reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    NOT_EQUAL       reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    GREATER         reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    GREATER_EQUAL   reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    LESSER          reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    LESSER_EQUAL    reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    R_SQUARE_BRACKET reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    SEMICOLON       reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    R_BRACKET       reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    COMMA           reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    R_BRACE         reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    QUESTION_MARK   reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    AND             reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    OR              reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    COLON           reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)


state 97

    (60) math_expression -> L_BRACKET math_expression R_BRACKET .

    EQUAL           reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    NOT_EQUAL       reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    GREATER         reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    GREATER_EQUAL   reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    LESSER          reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    LESSER_EQUAL    reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    R_SQUARE_BRACKET reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    SEMICOLON       reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    R_BRACKET       reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    COMMA           reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    R_BRACE         reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    QUESTION_MARK   reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    AND             reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    OR              reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    COLON           reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)


state 98

    (67) logical_expression -> L_BRACKET logical_expression R_BRACKET .

    QUESTION_MARK   reduce using rule 67 (logical_expression -> L_BRACKET logical_expression R_BRACKET .)
    AND             reduce using rule 67 (logical_expression -> L_BRACKET logical_expression R_BRACKET .)
    OR              reduce using rule 67 (logical_expression -> L_BRACKET logical_expression R_BRACKET .)
    R_BRACKET       reduce using rule 67 (logical_expression -> L_BRACKET logical_expression R_BRACKET .)
    SEMICOLON       reduce using rule 67 (logical_expression -> L_BRACKET logical_expression R_BRACKET .)


state 99

    (60) math_expression -> L_BRACKET math_expression . R_BRACKET

    R_BRACKET       shift and go to state 97


state 100

    (63) math_expression -> value . math_op value
    (96) math_op -> . PLUS
    (97) math_op -> . MINUS
    (98) math_op -> . MUL
    (99) math_op -> . DIV
    (100) math_op -> . MOD

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    MUL             shift and go to state 68
    DIV             shift and go to state 69
    MOD             shift and go to state 70

    math_op                        shift and go to state 65

state 101

    (68) function_expression -> ID L_BRACKET opt_listed_values . R_BRACKET

    R_BRACKET       shift and go to state 146


state 102

    (122) opt_listed_values -> listed_values .

    R_BRACKET       reduce using rule 122 (opt_listed_values -> listed_values .)


state 103

    (123) opt_listed_values -> empty .

    R_BRACKET       reduce using rule 123 (opt_listed_values -> empty .)


state 104

    (94) listed_values -> value_expression . COMMA value_expression
    (95) listed_values -> value_expression . COMMA listed_values
    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

    COMMA           shift and go to state 145
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

    comparison_op                  shift and go to state 58

state 105

    (93) list_element_extraction -> ID L_SQUARE_BRACKET value_expression . R_SQUARE_BRACKET
    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

    R_SQUARE_BRACKET shift and go to state 147
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

    comparison_op                  shift and go to state 58

state 106

    (69) trinary_mark_expression -> logical_expression QUESTION_MARK value_expression . COLON value_expression
    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

    COLON           shift and go to state 148
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

    comparison_op                  shift and go to state 58

state 107

    (64) logical_expression -> logical_expression bool_op logical_expression .
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (69) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (103) bool_op -> . AND
    (104) bool_op -> . OR

  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    R_BRACKET       reduce using rule 64 (logical_expression -> logical_expression bool_op logical_expression .)
    SEMICOLON       reduce using rule 64 (logical_expression -> logical_expression bool_op logical_expression .)
    QUESTION_MARK   shift and go to state 80
    AND             shift and go to state 82
    OR              shift and go to state 83

  ! QUESTION_MARK   [ reduce using rule 64 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! AND             [ reduce using rule 64 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! OR              [ reduce using rule 64 (logical_expression -> logical_expression bool_op logical_expression .) ]

    bool_op                        shift and go to state 81

state 108

    (125) args -> type ID COMMA args .

    R_BRACKET       reduce using rule 125 (args -> type ID COMMA args .)


state 109

    (15) statements_block -> L_BRACE opt_statements . R_BRACE

    R_BRACE         shift and go to state 149


state 110

    (13) opt_statements -> statements .

    R_BRACE         reduce using rule 13 (opt_statements -> statements .)


state 111

    (14) opt_statements -> empty .
    (119) opt_const -> empty .

    R_BRACE         reduce using rule 14 (opt_statements -> empty .)
    INT             reduce using rule 119 (opt_const -> empty .)
    FLOAT           reduce using rule 119 (opt_const -> empty .)
    DOUBLE          reduce using rule 119 (opt_const -> empty .)
    CHAR            reduce using rule 119 (opt_const -> empty .)
    BOOL            reduce using rule 119 (opt_const -> empty .)
    LONG            reduce using rule 119 (opt_const -> empty .)
    VOID            reduce using rule 119 (opt_const -> empty .)


state 112

    (11) statements -> statement .
    (12) statements -> statement . statements
    (11) statements -> . statement
    (12) statements -> . statement statements
    (8) statement -> . any_statement
    (9) statement -> . COMMENT
    (10) statement -> . SEMICOLON
    (16) any_statement -> . declaration_statement
    (17) any_statement -> . assign_statement
    (18) any_statement -> . function_statement
    (19) any_statement -> . return_statement
    (20) any_statement -> . while_loop_statement
    (21) any_statement -> . do_while_loop_statement
    (22) any_statement -> . break_statement
    (23) any_statement -> . for_loop_statement
    (24) any_statement -> . if_statement_block
    (25) any_statement -> . print_statement
    (26) any_statement -> . scan_statement
    (27) declaration_statement -> . opt_const type ID opt_array_mark
    (28) declaration_statement -> . opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (29) assign_statement -> . assign_expression SEMICOLON
    (30) function_statement -> . function_expression SEMICOLON
    (31) return_statement -> . RETURN value_expression SEMICOLON
    (34) while_loop_statement -> . WHILE L_BRACKET logical_expression R_BRACKET statements_block
    (35) do_while_loop_statement -> . DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON
    (32) break_statement -> . BREAK SEMICOLON
    (36) for_loop_statement -> . FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block
    (39) if_statement_block -> . if_statement
    (40) if_statement_block -> . if_statement else_else_if_statements_block
    (48) print_statement -> . PRINTF L_BRACKET value_expression R_BRACKET
    (49) scan_statement -> . SCANF L_BRACKET AMPERSAND ID R_BRACKET
    (118) opt_const -> . CONST
    (119) opt_const -> . empty
    (70) assign_expression -> . ID assign_op value_expression
    (71) assign_expression -> . list_element_extraction assign_op value_expression
    (72) assign_expression -> . unary_op ID
    (73) assign_expression -> . ID unary_op
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (41) if_statement -> . IF L_BRACKET logical_expression R_BRACKET statements_block
    (42) if_statement -> . IF L_BRACKET value_expression R_BRACKET statements_block
    (128) empty -> .
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (101) unary_op -> . INCREMENT
    (102) unary_op -> . DECREMENT

    R_BRACE         reduce using rule 11 (statements -> statement .)
    COMMENT         shift and go to state 114
    SEMICOLON       shift and go to state 115
    RETURN          shift and go to state 130
    WHILE           shift and go to state 131
    DO              shift and go to state 132
    BREAK           shift and go to state 133
    FOR             shift and go to state 134
    PRINTF          shift and go to state 136
    SCANF           shift and go to state 137
    CONST           shift and go to state 10
    ID              shift and go to state 127
    IF              shift and go to state 140
    INT             reduce using rule 128 (empty -> .)
    FLOAT           reduce using rule 128 (empty -> .)
    DOUBLE          reduce using rule 128 (empty -> .)
    CHAR            reduce using rule 128 (empty -> .)
    BOOL            reduce using rule 128 (empty -> .)
    LONG            reduce using rule 128 (empty -> .)
    VOID            reduce using rule 128 (empty -> .)
    INCREMENT       shift and go to state 141
    DECREMENT       shift and go to state 142

    statement                      shift and go to state 112
    statements                     shift and go to state 150
    any_statement                  shift and go to state 113
    declaration_statement          shift and go to state 116
    assign_statement               shift and go to state 117
    function_statement             shift and go to state 118
    return_statement               shift and go to state 119
    while_loop_statement           shift and go to state 120
    do_while_loop_statement        shift and go to state 121
    break_statement                shift and go to state 122
    for_loop_statement             shift and go to state 123
    if_statement_block             shift and go to state 124
    print_statement                shift and go to state 125
    scan_statement                 shift and go to state 126
    opt_const                      shift and go to state 8
    assign_expression              shift and go to state 128
    function_expression            shift and go to state 129
    if_statement                   shift and go to state 135
    empty                          shift and go to state 11
    list_element_extraction        shift and go to state 138
    unary_op                       shift and go to state 139

state 113

    (8) statement -> any_statement .

    COMMENT         reduce using rule 8 (statement -> any_statement .)
    SEMICOLON       reduce using rule 8 (statement -> any_statement .)
    RETURN          reduce using rule 8 (statement -> any_statement .)
    WHILE           reduce using rule 8 (statement -> any_statement .)
    DO              reduce using rule 8 (statement -> any_statement .)
    BREAK           reduce using rule 8 (statement -> any_statement .)
    FOR             reduce using rule 8 (statement -> any_statement .)
    PRINTF          reduce using rule 8 (statement -> any_statement .)
    SCANF           reduce using rule 8 (statement -> any_statement .)
    CONST           reduce using rule 8 (statement -> any_statement .)
    ID              reduce using rule 8 (statement -> any_statement .)
    IF              reduce using rule 8 (statement -> any_statement .)
    INCREMENT       reduce using rule 8 (statement -> any_statement .)
    DECREMENT       reduce using rule 8 (statement -> any_statement .)
    INT             reduce using rule 8 (statement -> any_statement .)
    FLOAT           reduce using rule 8 (statement -> any_statement .)
    DOUBLE          reduce using rule 8 (statement -> any_statement .)
    CHAR            reduce using rule 8 (statement -> any_statement .)
    BOOL            reduce using rule 8 (statement -> any_statement .)
    LONG            reduce using rule 8 (statement -> any_statement .)
    VOID            reduce using rule 8 (statement -> any_statement .)
    R_BRACE         reduce using rule 8 (statement -> any_statement .)


state 114

    (9) statement -> COMMENT .

    COMMENT         reduce using rule 9 (statement -> COMMENT .)
    SEMICOLON       reduce using rule 9 (statement -> COMMENT .)
    RETURN          reduce using rule 9 (statement -> COMMENT .)
    WHILE           reduce using rule 9 (statement -> COMMENT .)
    DO              reduce using rule 9 (statement -> COMMENT .)
    BREAK           reduce using rule 9 (statement -> COMMENT .)
    FOR             reduce using rule 9 (statement -> COMMENT .)
    PRINTF          reduce using rule 9 (statement -> COMMENT .)
    SCANF           reduce using rule 9 (statement -> COMMENT .)
    CONST           reduce using rule 9 (statement -> COMMENT .)
    ID              reduce using rule 9 (statement -> COMMENT .)
    IF              reduce using rule 9 (statement -> COMMENT .)
    INCREMENT       reduce using rule 9 (statement -> COMMENT .)
    DECREMENT       reduce using rule 9 (statement -> COMMENT .)
    INT             reduce using rule 9 (statement -> COMMENT .)
    FLOAT           reduce using rule 9 (statement -> COMMENT .)
    DOUBLE          reduce using rule 9 (statement -> COMMENT .)
    CHAR            reduce using rule 9 (statement -> COMMENT .)
    BOOL            reduce using rule 9 (statement -> COMMENT .)
    LONG            reduce using rule 9 (statement -> COMMENT .)
    VOID            reduce using rule 9 (statement -> COMMENT .)
    R_BRACE         reduce using rule 9 (statement -> COMMENT .)


state 115

    (10) statement -> SEMICOLON .

    COMMENT         reduce using rule 10 (statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 10 (statement -> SEMICOLON .)
    RETURN          reduce using rule 10 (statement -> SEMICOLON .)
    WHILE           reduce using rule 10 (statement -> SEMICOLON .)
    DO              reduce using rule 10 (statement -> SEMICOLON .)
    BREAK           reduce using rule 10 (statement -> SEMICOLON .)
    FOR             reduce using rule 10 (statement -> SEMICOLON .)
    PRINTF          reduce using rule 10 (statement -> SEMICOLON .)
    SCANF           reduce using rule 10 (statement -> SEMICOLON .)
    CONST           reduce using rule 10 (statement -> SEMICOLON .)
    ID              reduce using rule 10 (statement -> SEMICOLON .)
    IF              reduce using rule 10 (statement -> SEMICOLON .)
    INCREMENT       reduce using rule 10 (statement -> SEMICOLON .)
    DECREMENT       reduce using rule 10 (statement -> SEMICOLON .)
    INT             reduce using rule 10 (statement -> SEMICOLON .)
    FLOAT           reduce using rule 10 (statement -> SEMICOLON .)
    DOUBLE          reduce using rule 10 (statement -> SEMICOLON .)
    CHAR            reduce using rule 10 (statement -> SEMICOLON .)
    BOOL            reduce using rule 10 (statement -> SEMICOLON .)
    LONG            reduce using rule 10 (statement -> SEMICOLON .)
    VOID            reduce using rule 10 (statement -> SEMICOLON .)
    R_BRACE         reduce using rule 10 (statement -> SEMICOLON .)


state 116

    (16) any_statement -> declaration_statement .

    COMMENT         reduce using rule 16 (any_statement -> declaration_statement .)
    SEMICOLON       reduce using rule 16 (any_statement -> declaration_statement .)
    RETURN          reduce using rule 16 (any_statement -> declaration_statement .)
    WHILE           reduce using rule 16 (any_statement -> declaration_statement .)
    DO              reduce using rule 16 (any_statement -> declaration_statement .)
    BREAK           reduce using rule 16 (any_statement -> declaration_statement .)
    FOR             reduce using rule 16 (any_statement -> declaration_statement .)
    PRINTF          reduce using rule 16 (any_statement -> declaration_statement .)
    SCANF           reduce using rule 16 (any_statement -> declaration_statement .)
    CONST           reduce using rule 16 (any_statement -> declaration_statement .)
    ID              reduce using rule 16 (any_statement -> declaration_statement .)
    IF              reduce using rule 16 (any_statement -> declaration_statement .)
    INCREMENT       reduce using rule 16 (any_statement -> declaration_statement .)
    DECREMENT       reduce using rule 16 (any_statement -> declaration_statement .)
    INT             reduce using rule 16 (any_statement -> declaration_statement .)
    FLOAT           reduce using rule 16 (any_statement -> declaration_statement .)
    DOUBLE          reduce using rule 16 (any_statement -> declaration_statement .)
    CHAR            reduce using rule 16 (any_statement -> declaration_statement .)
    BOOL            reduce using rule 16 (any_statement -> declaration_statement .)
    LONG            reduce using rule 16 (any_statement -> declaration_statement .)
    VOID            reduce using rule 16 (any_statement -> declaration_statement .)
    R_BRACE         reduce using rule 16 (any_statement -> declaration_statement .)


state 117

    (17) any_statement -> assign_statement .

    COMMENT         reduce using rule 17 (any_statement -> assign_statement .)
    SEMICOLON       reduce using rule 17 (any_statement -> assign_statement .)
    RETURN          reduce using rule 17 (any_statement -> assign_statement .)
    WHILE           reduce using rule 17 (any_statement -> assign_statement .)
    DO              reduce using rule 17 (any_statement -> assign_statement .)
    BREAK           reduce using rule 17 (any_statement -> assign_statement .)
    FOR             reduce using rule 17 (any_statement -> assign_statement .)
    PRINTF          reduce using rule 17 (any_statement -> assign_statement .)
    SCANF           reduce using rule 17 (any_statement -> assign_statement .)
    CONST           reduce using rule 17 (any_statement -> assign_statement .)
    ID              reduce using rule 17 (any_statement -> assign_statement .)
    IF              reduce using rule 17 (any_statement -> assign_statement .)
    INCREMENT       reduce using rule 17 (any_statement -> assign_statement .)
    DECREMENT       reduce using rule 17 (any_statement -> assign_statement .)
    INT             reduce using rule 17 (any_statement -> assign_statement .)
    FLOAT           reduce using rule 17 (any_statement -> assign_statement .)
    DOUBLE          reduce using rule 17 (any_statement -> assign_statement .)
    CHAR            reduce using rule 17 (any_statement -> assign_statement .)
    BOOL            reduce using rule 17 (any_statement -> assign_statement .)
    LONG            reduce using rule 17 (any_statement -> assign_statement .)
    VOID            reduce using rule 17 (any_statement -> assign_statement .)
    R_BRACE         reduce using rule 17 (any_statement -> assign_statement .)


state 118

    (18) any_statement -> function_statement .

    COMMENT         reduce using rule 18 (any_statement -> function_statement .)
    SEMICOLON       reduce using rule 18 (any_statement -> function_statement .)
    RETURN          reduce using rule 18 (any_statement -> function_statement .)
    WHILE           reduce using rule 18 (any_statement -> function_statement .)
    DO              reduce using rule 18 (any_statement -> function_statement .)
    BREAK           reduce using rule 18 (any_statement -> function_statement .)
    FOR             reduce using rule 18 (any_statement -> function_statement .)
    PRINTF          reduce using rule 18 (any_statement -> function_statement .)
    SCANF           reduce using rule 18 (any_statement -> function_statement .)
    CONST           reduce using rule 18 (any_statement -> function_statement .)
    ID              reduce using rule 18 (any_statement -> function_statement .)
    IF              reduce using rule 18 (any_statement -> function_statement .)
    INCREMENT       reduce using rule 18 (any_statement -> function_statement .)
    DECREMENT       reduce using rule 18 (any_statement -> function_statement .)
    INT             reduce using rule 18 (any_statement -> function_statement .)
    FLOAT           reduce using rule 18 (any_statement -> function_statement .)
    DOUBLE          reduce using rule 18 (any_statement -> function_statement .)
    CHAR            reduce using rule 18 (any_statement -> function_statement .)
    BOOL            reduce using rule 18 (any_statement -> function_statement .)
    LONG            reduce using rule 18 (any_statement -> function_statement .)
    VOID            reduce using rule 18 (any_statement -> function_statement .)
    R_BRACE         reduce using rule 18 (any_statement -> function_statement .)


state 119

    (19) any_statement -> return_statement .

    COMMENT         reduce using rule 19 (any_statement -> return_statement .)
    SEMICOLON       reduce using rule 19 (any_statement -> return_statement .)
    RETURN          reduce using rule 19 (any_statement -> return_statement .)
    WHILE           reduce using rule 19 (any_statement -> return_statement .)
    DO              reduce using rule 19 (any_statement -> return_statement .)
    BREAK           reduce using rule 19 (any_statement -> return_statement .)
    FOR             reduce using rule 19 (any_statement -> return_statement .)
    PRINTF          reduce using rule 19 (any_statement -> return_statement .)
    SCANF           reduce using rule 19 (any_statement -> return_statement .)
    CONST           reduce using rule 19 (any_statement -> return_statement .)
    ID              reduce using rule 19 (any_statement -> return_statement .)
    IF              reduce using rule 19 (any_statement -> return_statement .)
    INCREMENT       reduce using rule 19 (any_statement -> return_statement .)
    DECREMENT       reduce using rule 19 (any_statement -> return_statement .)
    INT             reduce using rule 19 (any_statement -> return_statement .)
    FLOAT           reduce using rule 19 (any_statement -> return_statement .)
    DOUBLE          reduce using rule 19 (any_statement -> return_statement .)
    CHAR            reduce using rule 19 (any_statement -> return_statement .)
    BOOL            reduce using rule 19 (any_statement -> return_statement .)
    LONG            reduce using rule 19 (any_statement -> return_statement .)
    VOID            reduce using rule 19 (any_statement -> return_statement .)
    R_BRACE         reduce using rule 19 (any_statement -> return_statement .)


state 120

    (20) any_statement -> while_loop_statement .

    COMMENT         reduce using rule 20 (any_statement -> while_loop_statement .)
    SEMICOLON       reduce using rule 20 (any_statement -> while_loop_statement .)
    RETURN          reduce using rule 20 (any_statement -> while_loop_statement .)
    WHILE           reduce using rule 20 (any_statement -> while_loop_statement .)
    DO              reduce using rule 20 (any_statement -> while_loop_statement .)
    BREAK           reduce using rule 20 (any_statement -> while_loop_statement .)
    FOR             reduce using rule 20 (any_statement -> while_loop_statement .)
    PRINTF          reduce using rule 20 (any_statement -> while_loop_statement .)
    SCANF           reduce using rule 20 (any_statement -> while_loop_statement .)
    CONST           reduce using rule 20 (any_statement -> while_loop_statement .)
    ID              reduce using rule 20 (any_statement -> while_loop_statement .)
    IF              reduce using rule 20 (any_statement -> while_loop_statement .)
    INCREMENT       reduce using rule 20 (any_statement -> while_loop_statement .)
    DECREMENT       reduce using rule 20 (any_statement -> while_loop_statement .)
    INT             reduce using rule 20 (any_statement -> while_loop_statement .)
    FLOAT           reduce using rule 20 (any_statement -> while_loop_statement .)
    DOUBLE          reduce using rule 20 (any_statement -> while_loop_statement .)
    CHAR            reduce using rule 20 (any_statement -> while_loop_statement .)
    BOOL            reduce using rule 20 (any_statement -> while_loop_statement .)
    LONG            reduce using rule 20 (any_statement -> while_loop_statement .)
    VOID            reduce using rule 20 (any_statement -> while_loop_statement .)
    R_BRACE         reduce using rule 20 (any_statement -> while_loop_statement .)


state 121

    (21) any_statement -> do_while_loop_statement .

    COMMENT         reduce using rule 21 (any_statement -> do_while_loop_statement .)
    SEMICOLON       reduce using rule 21 (any_statement -> do_while_loop_statement .)
    RETURN          reduce using rule 21 (any_statement -> do_while_loop_statement .)
    WHILE           reduce using rule 21 (any_statement -> do_while_loop_statement .)
    DO              reduce using rule 21 (any_statement -> do_while_loop_statement .)
    BREAK           reduce using rule 21 (any_statement -> do_while_loop_statement .)
    FOR             reduce using rule 21 (any_statement -> do_while_loop_statement .)
    PRINTF          reduce using rule 21 (any_statement -> do_while_loop_statement .)
    SCANF           reduce using rule 21 (any_statement -> do_while_loop_statement .)
    CONST           reduce using rule 21 (any_statement -> do_while_loop_statement .)
    ID              reduce using rule 21 (any_statement -> do_while_loop_statement .)
    IF              reduce using rule 21 (any_statement -> do_while_loop_statement .)
    INCREMENT       reduce using rule 21 (any_statement -> do_while_loop_statement .)
    DECREMENT       reduce using rule 21 (any_statement -> do_while_loop_statement .)
    INT             reduce using rule 21 (any_statement -> do_while_loop_statement .)
    FLOAT           reduce using rule 21 (any_statement -> do_while_loop_statement .)
    DOUBLE          reduce using rule 21 (any_statement -> do_while_loop_statement .)
    CHAR            reduce using rule 21 (any_statement -> do_while_loop_statement .)
    BOOL            reduce using rule 21 (any_statement -> do_while_loop_statement .)
    LONG            reduce using rule 21 (any_statement -> do_while_loop_statement .)
    VOID            reduce using rule 21 (any_statement -> do_while_loop_statement .)
    R_BRACE         reduce using rule 21 (any_statement -> do_while_loop_statement .)


state 122

    (22) any_statement -> break_statement .

    COMMENT         reduce using rule 22 (any_statement -> break_statement .)
    SEMICOLON       reduce using rule 22 (any_statement -> break_statement .)
    RETURN          reduce using rule 22 (any_statement -> break_statement .)
    WHILE           reduce using rule 22 (any_statement -> break_statement .)
    DO              reduce using rule 22 (any_statement -> break_statement .)
    BREAK           reduce using rule 22 (any_statement -> break_statement .)
    FOR             reduce using rule 22 (any_statement -> break_statement .)
    PRINTF          reduce using rule 22 (any_statement -> break_statement .)
    SCANF           reduce using rule 22 (any_statement -> break_statement .)
    CONST           reduce using rule 22 (any_statement -> break_statement .)
    ID              reduce using rule 22 (any_statement -> break_statement .)
    IF              reduce using rule 22 (any_statement -> break_statement .)
    INCREMENT       reduce using rule 22 (any_statement -> break_statement .)
    DECREMENT       reduce using rule 22 (any_statement -> break_statement .)
    INT             reduce using rule 22 (any_statement -> break_statement .)
    FLOAT           reduce using rule 22 (any_statement -> break_statement .)
    DOUBLE          reduce using rule 22 (any_statement -> break_statement .)
    CHAR            reduce using rule 22 (any_statement -> break_statement .)
    BOOL            reduce using rule 22 (any_statement -> break_statement .)
    LONG            reduce using rule 22 (any_statement -> break_statement .)
    VOID            reduce using rule 22 (any_statement -> break_statement .)
    R_BRACE         reduce using rule 22 (any_statement -> break_statement .)


state 123

    (23) any_statement -> for_loop_statement .

    COMMENT         reduce using rule 23 (any_statement -> for_loop_statement .)
    SEMICOLON       reduce using rule 23 (any_statement -> for_loop_statement .)
    RETURN          reduce using rule 23 (any_statement -> for_loop_statement .)
    WHILE           reduce using rule 23 (any_statement -> for_loop_statement .)
    DO              reduce using rule 23 (any_statement -> for_loop_statement .)
    BREAK           reduce using rule 23 (any_statement -> for_loop_statement .)
    FOR             reduce using rule 23 (any_statement -> for_loop_statement .)
    PRINTF          reduce using rule 23 (any_statement -> for_loop_statement .)
    SCANF           reduce using rule 23 (any_statement -> for_loop_statement .)
    CONST           reduce using rule 23 (any_statement -> for_loop_statement .)
    ID              reduce using rule 23 (any_statement -> for_loop_statement .)
    IF              reduce using rule 23 (any_statement -> for_loop_statement .)
    INCREMENT       reduce using rule 23 (any_statement -> for_loop_statement .)
    DECREMENT       reduce using rule 23 (any_statement -> for_loop_statement .)
    INT             reduce using rule 23 (any_statement -> for_loop_statement .)
    FLOAT           reduce using rule 23 (any_statement -> for_loop_statement .)
    DOUBLE          reduce using rule 23 (any_statement -> for_loop_statement .)
    CHAR            reduce using rule 23 (any_statement -> for_loop_statement .)
    BOOL            reduce using rule 23 (any_statement -> for_loop_statement .)
    LONG            reduce using rule 23 (any_statement -> for_loop_statement .)
    VOID            reduce using rule 23 (any_statement -> for_loop_statement .)
    R_BRACE         reduce using rule 23 (any_statement -> for_loop_statement .)


state 124

    (24) any_statement -> if_statement_block .

    COMMENT         reduce using rule 24 (any_statement -> if_statement_block .)
    SEMICOLON       reduce using rule 24 (any_statement -> if_statement_block .)
    RETURN          reduce using rule 24 (any_statement -> if_statement_block .)
    WHILE           reduce using rule 24 (any_statement -> if_statement_block .)
    DO              reduce using rule 24 (any_statement -> if_statement_block .)
    BREAK           reduce using rule 24 (any_statement -> if_statement_block .)
    FOR             reduce using rule 24 (any_statement -> if_statement_block .)
    PRINTF          reduce using rule 24 (any_statement -> if_statement_block .)
    SCANF           reduce using rule 24 (any_statement -> if_statement_block .)
    CONST           reduce using rule 24 (any_statement -> if_statement_block .)
    ID              reduce using rule 24 (any_statement -> if_statement_block .)
    IF              reduce using rule 24 (any_statement -> if_statement_block .)
    INCREMENT       reduce using rule 24 (any_statement -> if_statement_block .)
    DECREMENT       reduce using rule 24 (any_statement -> if_statement_block .)
    INT             reduce using rule 24 (any_statement -> if_statement_block .)
    FLOAT           reduce using rule 24 (any_statement -> if_statement_block .)
    DOUBLE          reduce using rule 24 (any_statement -> if_statement_block .)
    CHAR            reduce using rule 24 (any_statement -> if_statement_block .)
    BOOL            reduce using rule 24 (any_statement -> if_statement_block .)
    LONG            reduce using rule 24 (any_statement -> if_statement_block .)
    VOID            reduce using rule 24 (any_statement -> if_statement_block .)
    R_BRACE         reduce using rule 24 (any_statement -> if_statement_block .)


state 125

    (25) any_statement -> print_statement .

    COMMENT         reduce using rule 25 (any_statement -> print_statement .)
    SEMICOLON       reduce using rule 25 (any_statement -> print_statement .)
    RETURN          reduce using rule 25 (any_statement -> print_statement .)
    WHILE           reduce using rule 25 (any_statement -> print_statement .)
    DO              reduce using rule 25 (any_statement -> print_statement .)
    BREAK           reduce using rule 25 (any_statement -> print_statement .)
    FOR             reduce using rule 25 (any_statement -> print_statement .)
    PRINTF          reduce using rule 25 (any_statement -> print_statement .)
    SCANF           reduce using rule 25 (any_statement -> print_statement .)
    CONST           reduce using rule 25 (any_statement -> print_statement .)
    ID              reduce using rule 25 (any_statement -> print_statement .)
    IF              reduce using rule 25 (any_statement -> print_statement .)
    INCREMENT       reduce using rule 25 (any_statement -> print_statement .)
    DECREMENT       reduce using rule 25 (any_statement -> print_statement .)
    INT             reduce using rule 25 (any_statement -> print_statement .)
    FLOAT           reduce using rule 25 (any_statement -> print_statement .)
    DOUBLE          reduce using rule 25 (any_statement -> print_statement .)
    CHAR            reduce using rule 25 (any_statement -> print_statement .)
    BOOL            reduce using rule 25 (any_statement -> print_statement .)
    LONG            reduce using rule 25 (any_statement -> print_statement .)
    VOID            reduce using rule 25 (any_statement -> print_statement .)
    R_BRACE         reduce using rule 25 (any_statement -> print_statement .)


state 126

    (26) any_statement -> scan_statement .

    COMMENT         reduce using rule 26 (any_statement -> scan_statement .)
    SEMICOLON       reduce using rule 26 (any_statement -> scan_statement .)
    RETURN          reduce using rule 26 (any_statement -> scan_statement .)
    WHILE           reduce using rule 26 (any_statement -> scan_statement .)
    DO              reduce using rule 26 (any_statement -> scan_statement .)
    BREAK           reduce using rule 26 (any_statement -> scan_statement .)
    FOR             reduce using rule 26 (any_statement -> scan_statement .)
    PRINTF          reduce using rule 26 (any_statement -> scan_statement .)
    SCANF           reduce using rule 26 (any_statement -> scan_statement .)
    CONST           reduce using rule 26 (any_statement -> scan_statement .)
    ID              reduce using rule 26 (any_statement -> scan_statement .)
    IF              reduce using rule 26 (any_statement -> scan_statement .)
    INCREMENT       reduce using rule 26 (any_statement -> scan_statement .)
    DECREMENT       reduce using rule 26 (any_statement -> scan_statement .)
    INT             reduce using rule 26 (any_statement -> scan_statement .)
    FLOAT           reduce using rule 26 (any_statement -> scan_statement .)
    DOUBLE          reduce using rule 26 (any_statement -> scan_statement .)
    CHAR            reduce using rule 26 (any_statement -> scan_statement .)
    BOOL            reduce using rule 26 (any_statement -> scan_statement .)
    LONG            reduce using rule 26 (any_statement -> scan_statement .)
    VOID            reduce using rule 26 (any_statement -> scan_statement .)
    R_BRACE         reduce using rule 26 (any_statement -> scan_statement .)


state 127

    (70) assign_expression -> ID . assign_op value_expression
    (73) assign_expression -> ID . unary_op
    (68) function_expression -> ID . L_BRACKET opt_listed_values R_BRACKET
    (93) list_element_extraction -> ID . L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (111) assign_op -> . ASSIGN
    (112) assign_op -> . PLUS_ASSIGN
    (113) assign_op -> . MINUS_ASSIGN
    (114) assign_op -> . MUL_ASSIGN
    (115) assign_op -> . DIV_ASSIGN
    (116) assign_op -> . MOD_ASSIGN
    (101) unary_op -> . INCREMENT
    (102) unary_op -> . DECREMENT

    L_BRACKET       shift and go to state 78
    L_SQUARE_BRACKET shift and go to state 79
    ASSIGN          shift and go to state 153
    PLUS_ASSIGN     shift and go to state 154
    MINUS_ASSIGN    shift and go to state 155
    MUL_ASSIGN      shift and go to state 156
    DIV_ASSIGN      shift and go to state 157
    MOD_ASSIGN      shift and go to state 158
    INCREMENT       shift and go to state 141
    DECREMENT       shift and go to state 142

    assign_op                      shift and go to state 151
    unary_op                       shift and go to state 152

state 128

    (29) assign_statement -> assign_expression . SEMICOLON

    SEMICOLON       shift and go to state 159


state 129

    (30) function_statement -> function_expression . SEMICOLON

    SEMICOLON       shift and go to state 160


state 130

    (31) return_statement -> RETURN . value_expression SEMICOLON
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 51

    value_expression               shift and go to state 161
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49
    logical_expression             shift and go to state 50

state 131

    (34) while_loop_statement -> WHILE . L_BRACKET logical_expression R_BRACKET statements_block

    L_BRACKET       shift and go to state 162


state 132

    (35) do_while_loop_statement -> DO . statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 89

    statements_block               shift and go to state 163

state 133

    (32) break_statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 164


state 134

    (36) for_loop_statement -> FOR . L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block

    L_BRACKET       shift and go to state 165


state 135

    (39) if_statement_block -> if_statement .
    (40) if_statement_block -> if_statement . else_else_if_statements_block
    (43) else_else_if_statements_block -> . else_statement
    (44) else_else_if_statements_block -> . else_if_statement else_else_if_statements_block
    (45) else_else_if_statements_block -> . else_if_statement
    (46) else_statement -> . ELSE statements_block
    (47) else_if_statement -> . ELSE if_statement

    COMMENT         reduce using rule 39 (if_statement_block -> if_statement .)
    SEMICOLON       reduce using rule 39 (if_statement_block -> if_statement .)
    RETURN          reduce using rule 39 (if_statement_block -> if_statement .)
    WHILE           reduce using rule 39 (if_statement_block -> if_statement .)
    DO              reduce using rule 39 (if_statement_block -> if_statement .)
    BREAK           reduce using rule 39 (if_statement_block -> if_statement .)
    FOR             reduce using rule 39 (if_statement_block -> if_statement .)
    PRINTF          reduce using rule 39 (if_statement_block -> if_statement .)
    SCANF           reduce using rule 39 (if_statement_block -> if_statement .)
    CONST           reduce using rule 39 (if_statement_block -> if_statement .)
    ID              reduce using rule 39 (if_statement_block -> if_statement .)
    IF              reduce using rule 39 (if_statement_block -> if_statement .)
    INCREMENT       reduce using rule 39 (if_statement_block -> if_statement .)
    DECREMENT       reduce using rule 39 (if_statement_block -> if_statement .)
    INT             reduce using rule 39 (if_statement_block -> if_statement .)
    FLOAT           reduce using rule 39 (if_statement_block -> if_statement .)
    DOUBLE          reduce using rule 39 (if_statement_block -> if_statement .)
    CHAR            reduce using rule 39 (if_statement_block -> if_statement .)
    BOOL            reduce using rule 39 (if_statement_block -> if_statement .)
    LONG            reduce using rule 39 (if_statement_block -> if_statement .)
    VOID            reduce using rule 39 (if_statement_block -> if_statement .)
    R_BRACE         reduce using rule 39 (if_statement_block -> if_statement .)
    ELSE            shift and go to state 169

    else_else_if_statements_block  shift and go to state 166
    else_statement                 shift and go to state 167
    else_if_statement              shift and go to state 168

state 136

    (48) print_statement -> PRINTF . L_BRACKET value_expression R_BRACKET

    L_BRACKET       shift and go to state 170


state 137

    (49) scan_statement -> SCANF . L_BRACKET AMPERSAND ID R_BRACKET

    L_BRACKET       shift and go to state 171


state 138

    (71) assign_expression -> list_element_extraction . assign_op value_expression
    (111) assign_op -> . ASSIGN
    (112) assign_op -> . PLUS_ASSIGN
    (113) assign_op -> . MINUS_ASSIGN
    (114) assign_op -> . MUL_ASSIGN
    (115) assign_op -> . DIV_ASSIGN
    (116) assign_op -> . MOD_ASSIGN

    ASSIGN          shift and go to state 153
    PLUS_ASSIGN     shift and go to state 154
    MINUS_ASSIGN    shift and go to state 155
    MUL_ASSIGN      shift and go to state 156
    DIV_ASSIGN      shift and go to state 157
    MOD_ASSIGN      shift and go to state 158

    assign_op                      shift and go to state 172

state 139

    (72) assign_expression -> unary_op . ID

    ID              shift and go to state 173


state 140

    (41) if_statement -> IF . L_BRACKET logical_expression R_BRACKET statements_block
    (42) if_statement -> IF . L_BRACKET value_expression R_BRACKET statements_block

    L_BRACKET       shift and go to state 174


state 141

    (101) unary_op -> INCREMENT .

    ID              reduce using rule 101 (unary_op -> INCREMENT .)
    SEMICOLON       reduce using rule 101 (unary_op -> INCREMENT .)
    R_BRACKET       reduce using rule 101 (unary_op -> INCREMENT .)


state 142

    (102) unary_op -> DECREMENT .

    ID              reduce using rule 102 (unary_op -> DECREMENT .)
    SEMICOLON       reduce using rule 102 (unary_op -> DECREMENT .)
    R_BRACKET       reduce using rule 102 (unary_op -> DECREMENT .)


state 143

    (51) declaration_value_expression -> L_BRACE listed_values R_BRACE .

    SEMICOLON       reduce using rule 51 (declaration_value_expression -> L_BRACE listed_values R_BRACE .)
    R_BRACE         reduce using rule 51 (declaration_value_expression -> L_BRACE listed_values R_BRACE .)


state 144

    (52) declaration_value_expression -> L_BRACE declaration_value_expression R_BRACE .

    SEMICOLON       reduce using rule 52 (declaration_value_expression -> L_BRACE declaration_value_expression R_BRACE .)
    R_BRACE         reduce using rule 52 (declaration_value_expression -> L_BRACE declaration_value_expression R_BRACE .)


state 145

    (94) listed_values -> value_expression COMMA . value_expression
    (95) listed_values -> value_expression COMMA . listed_values
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (94) listed_values -> . value_expression COMMA value_expression
    (95) listed_values -> . value_expression COMMA listed_values
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 51

    value_expression               shift and go to state 175
    listed_values                  shift and go to state 176
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49
    logical_expression             shift and go to state 50

state 146

    (68) function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .

    EQUAL           reduce using rule 68 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    NOT_EQUAL       reduce using rule 68 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    GREATER         reduce using rule 68 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    GREATER_EQUAL   reduce using rule 68 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    LESSER          reduce using rule 68 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    LESSER_EQUAL    reduce using rule 68 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    R_SQUARE_BRACKET reduce using rule 68 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    SEMICOLON       reduce using rule 68 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    R_BRACKET       reduce using rule 68 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    COMMA           reduce using rule 68 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    R_BRACE         reduce using rule 68 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    QUESTION_MARK   reduce using rule 68 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    AND             reduce using rule 68 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    OR              reduce using rule 68 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    COLON           reduce using rule 68 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)


state 147

    (93) list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .

    PLUS            reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    MINUS           reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    MUL             reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    DIV             reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    MOD             reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    EQUAL           reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    NOT_EQUAL       reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    GREATER         reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    GREATER_EQUAL   reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    LESSER          reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    LESSER_EQUAL    reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    R_SQUARE_BRACKET reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    SEMICOLON       reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    R_BRACKET       reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    COMMA           reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    R_BRACE         reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    QUESTION_MARK   reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    AND             reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    OR              reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    COLON           reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    ASSIGN          reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    PLUS_ASSIGN     reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    MINUS_ASSIGN    reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    MUL_ASSIGN      reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    DIV_ASSIGN      reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    MOD_ASSIGN      reduce using rule 93 (list_element_extraction -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)


state 148

    (69) trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 51

    logical_expression             shift and go to state 50
    value_expression               shift and go to state 177
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49

state 149

    (15) statements_block -> L_BRACE opt_statements R_BRACE .

    COMMENT         reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    PREPROCESSOR_LINE reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    CONST           reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    INT             reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    FLOAT           reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    DOUBLE          reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    CHAR            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    BOOL            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    LONG            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    VOID            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    $end            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    WHILE           reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    SEMICOLON       reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    RETURN          reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    DO              reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    BREAK           reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    FOR             reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    PRINTF          reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    SCANF           reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    ID              reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    IF              reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    INCREMENT       reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    DECREMENT       reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    R_BRACE         reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    ELSE            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)


state 150

    (12) statements -> statement statements .

    R_BRACE         reduce using rule 12 (statements -> statement statements .)


state 151

    (70) assign_expression -> ID assign_op . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 51

    value_expression               shift and go to state 178
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49
    logical_expression             shift and go to state 50

state 152

    (73) assign_expression -> ID unary_op .

    SEMICOLON       reduce using rule 73 (assign_expression -> ID unary_op .)
    R_BRACKET       reduce using rule 73 (assign_expression -> ID unary_op .)


state 153

    (111) assign_op -> ASSIGN .

    L_BRACKET       reduce using rule 111 (assign_op -> ASSIGN .)
    MINUS           reduce using rule 111 (assign_op -> ASSIGN .)
    ID              reduce using rule 111 (assign_op -> ASSIGN .)
    INTEGER         reduce using rule 111 (assign_op -> ASSIGN .)
    DECIMAL         reduce using rule 111 (assign_op -> ASSIGN .)
    CHARACTER       reduce using rule 111 (assign_op -> ASSIGN .)
    STRING          reduce using rule 111 (assign_op -> ASSIGN .)
    TRUE            reduce using rule 111 (assign_op -> ASSIGN .)
    FALSE           reduce using rule 111 (assign_op -> ASSIGN .)
    NEGATION        reduce using rule 111 (assign_op -> ASSIGN .)


state 154

    (112) assign_op -> PLUS_ASSIGN .

    L_BRACKET       reduce using rule 112 (assign_op -> PLUS_ASSIGN .)
    MINUS           reduce using rule 112 (assign_op -> PLUS_ASSIGN .)
    ID              reduce using rule 112 (assign_op -> PLUS_ASSIGN .)
    INTEGER         reduce using rule 112 (assign_op -> PLUS_ASSIGN .)
    DECIMAL         reduce using rule 112 (assign_op -> PLUS_ASSIGN .)
    CHARACTER       reduce using rule 112 (assign_op -> PLUS_ASSIGN .)
    STRING          reduce using rule 112 (assign_op -> PLUS_ASSIGN .)
    TRUE            reduce using rule 112 (assign_op -> PLUS_ASSIGN .)
    FALSE           reduce using rule 112 (assign_op -> PLUS_ASSIGN .)
    NEGATION        reduce using rule 112 (assign_op -> PLUS_ASSIGN .)


state 155

    (113) assign_op -> MINUS_ASSIGN .

    L_BRACKET       reduce using rule 113 (assign_op -> MINUS_ASSIGN .)
    MINUS           reduce using rule 113 (assign_op -> MINUS_ASSIGN .)
    ID              reduce using rule 113 (assign_op -> MINUS_ASSIGN .)
    INTEGER         reduce using rule 113 (assign_op -> MINUS_ASSIGN .)
    DECIMAL         reduce using rule 113 (assign_op -> MINUS_ASSIGN .)
    CHARACTER       reduce using rule 113 (assign_op -> MINUS_ASSIGN .)
    STRING          reduce using rule 113 (assign_op -> MINUS_ASSIGN .)
    TRUE            reduce using rule 113 (assign_op -> MINUS_ASSIGN .)
    FALSE           reduce using rule 113 (assign_op -> MINUS_ASSIGN .)
    NEGATION        reduce using rule 113 (assign_op -> MINUS_ASSIGN .)


state 156

    (114) assign_op -> MUL_ASSIGN .

    L_BRACKET       reduce using rule 114 (assign_op -> MUL_ASSIGN .)
    MINUS           reduce using rule 114 (assign_op -> MUL_ASSIGN .)
    ID              reduce using rule 114 (assign_op -> MUL_ASSIGN .)
    INTEGER         reduce using rule 114 (assign_op -> MUL_ASSIGN .)
    DECIMAL         reduce using rule 114 (assign_op -> MUL_ASSIGN .)
    CHARACTER       reduce using rule 114 (assign_op -> MUL_ASSIGN .)
    STRING          reduce using rule 114 (assign_op -> MUL_ASSIGN .)
    TRUE            reduce using rule 114 (assign_op -> MUL_ASSIGN .)
    FALSE           reduce using rule 114 (assign_op -> MUL_ASSIGN .)
    NEGATION        reduce using rule 114 (assign_op -> MUL_ASSIGN .)


state 157

    (115) assign_op -> DIV_ASSIGN .

    L_BRACKET       reduce using rule 115 (assign_op -> DIV_ASSIGN .)
    MINUS           reduce using rule 115 (assign_op -> DIV_ASSIGN .)
    ID              reduce using rule 115 (assign_op -> DIV_ASSIGN .)
    INTEGER         reduce using rule 115 (assign_op -> DIV_ASSIGN .)
    DECIMAL         reduce using rule 115 (assign_op -> DIV_ASSIGN .)
    CHARACTER       reduce using rule 115 (assign_op -> DIV_ASSIGN .)
    STRING          reduce using rule 115 (assign_op -> DIV_ASSIGN .)
    TRUE            reduce using rule 115 (assign_op -> DIV_ASSIGN .)
    FALSE           reduce using rule 115 (assign_op -> DIV_ASSIGN .)
    NEGATION        reduce using rule 115 (assign_op -> DIV_ASSIGN .)


state 158

    (116) assign_op -> MOD_ASSIGN .

    L_BRACKET       reduce using rule 116 (assign_op -> MOD_ASSIGN .)
    MINUS           reduce using rule 116 (assign_op -> MOD_ASSIGN .)
    ID              reduce using rule 116 (assign_op -> MOD_ASSIGN .)
    INTEGER         reduce using rule 116 (assign_op -> MOD_ASSIGN .)
    DECIMAL         reduce using rule 116 (assign_op -> MOD_ASSIGN .)
    CHARACTER       reduce using rule 116 (assign_op -> MOD_ASSIGN .)
    STRING          reduce using rule 116 (assign_op -> MOD_ASSIGN .)
    TRUE            reduce using rule 116 (assign_op -> MOD_ASSIGN .)
    FALSE           reduce using rule 116 (assign_op -> MOD_ASSIGN .)
    NEGATION        reduce using rule 116 (assign_op -> MOD_ASSIGN .)


state 159

    (29) assign_statement -> assign_expression SEMICOLON .

    COMMENT         reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    SEMICOLON       reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    RETURN          reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    WHILE           reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    DO              reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    BREAK           reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    FOR             reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    PRINTF          reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    SCANF           reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    CONST           reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    ID              reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    IF              reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    INCREMENT       reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    DECREMENT       reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    INT             reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    FLOAT           reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    DOUBLE          reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    CHAR            reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    BOOL            reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    LONG            reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    VOID            reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    R_BRACE         reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)


state 160

    (30) function_statement -> function_expression SEMICOLON .

    COMMENT         reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    SEMICOLON       reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    RETURN          reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    WHILE           reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    DO              reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    BREAK           reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    FOR             reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    PRINTF          reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    SCANF           reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    CONST           reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    ID              reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    IF              reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    INCREMENT       reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    DECREMENT       reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    INT             reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    FLOAT           reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    DOUBLE          reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    CHAR            reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    BOOL            reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    LONG            reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    VOID            reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    R_BRACE         reduce using rule 30 (function_statement -> function_expression SEMICOLON .)


state 161

    (31) return_statement -> RETURN value_expression . SEMICOLON
    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

    SEMICOLON       shift and go to state 179
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

    comparison_op                  shift and go to state 58

state 162

    (34) while_loop_statement -> WHILE L_BRACKET . logical_expression R_BRACKET statements_block
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    NEGATION        shift and go to state 51
    L_BRACKET       shift and go to state 86
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48

    logical_expression             shift and go to state 180
    value_expression               shift and go to state 85
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49

state 163

    (35) do_while_loop_statement -> DO statements_block . WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON

    WHILE           shift and go to state 181


state 164

    (32) break_statement -> BREAK SEMICOLON .

    COMMENT         reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    DO              reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    PRINTF          reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    SCANF           reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    CONST           reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    ID              reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    IF              reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    INCREMENT       reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    DECREMENT       reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    INT             reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    DOUBLE          reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    CHAR            reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    BOOL            reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    LONG            reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    VOID            reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    R_BRACE         reduce using rule 32 (break_statement -> BREAK SEMICOLON .)


state 165

    (36) for_loop_statement -> FOR L_BRACKET . decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block
    (37) decl_stat_or_sem -> . declaration_statement
    (38) decl_stat_or_sem -> . SEMICOLON
    (27) declaration_statement -> . opt_const type ID opt_array_mark
    (28) declaration_statement -> . opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (118) opt_const -> . CONST
    (119) opt_const -> . empty
    (128) empty -> .

    SEMICOLON       shift and go to state 183
    CONST           shift and go to state 10
    INT             reduce using rule 128 (empty -> .)
    FLOAT           reduce using rule 128 (empty -> .)
    DOUBLE          reduce using rule 128 (empty -> .)
    CHAR            reduce using rule 128 (empty -> .)
    BOOL            reduce using rule 128 (empty -> .)
    LONG            reduce using rule 128 (empty -> .)
    VOID            reduce using rule 128 (empty -> .)

    decl_stat_or_sem               shift and go to state 182
    declaration_statement          shift and go to state 184
    opt_const                      shift and go to state 8
    empty                          shift and go to state 11

state 166

    (40) if_statement_block -> if_statement else_else_if_statements_block .

    COMMENT         reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    SEMICOLON       reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    RETURN          reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    WHILE           reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    DO              reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    BREAK           reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    FOR             reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    PRINTF          reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    SCANF           reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    CONST           reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    ID              reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    IF              reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    INCREMENT       reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    DECREMENT       reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    INT             reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    FLOAT           reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    DOUBLE          reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    CHAR            reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    BOOL            reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    LONG            reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    VOID            reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)
    R_BRACE         reduce using rule 40 (if_statement_block -> if_statement else_else_if_statements_block .)


state 167

    (43) else_else_if_statements_block -> else_statement .

    COMMENT         reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    SEMICOLON       reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    RETURN          reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    WHILE           reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    DO              reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    BREAK           reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    FOR             reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    PRINTF          reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    SCANF           reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    CONST           reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    ID              reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    IF              reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    INCREMENT       reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    DECREMENT       reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    INT             reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    FLOAT           reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    DOUBLE          reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    CHAR            reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    BOOL            reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    LONG            reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    VOID            reduce using rule 43 (else_else_if_statements_block -> else_statement .)
    R_BRACE         reduce using rule 43 (else_else_if_statements_block -> else_statement .)


state 168

    (44) else_else_if_statements_block -> else_if_statement . else_else_if_statements_block
    (45) else_else_if_statements_block -> else_if_statement .
    (43) else_else_if_statements_block -> . else_statement
    (44) else_else_if_statements_block -> . else_if_statement else_else_if_statements_block
    (45) else_else_if_statements_block -> . else_if_statement
    (46) else_statement -> . ELSE statements_block
    (47) else_if_statement -> . ELSE if_statement

    COMMENT         reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    SEMICOLON       reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    RETURN          reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    WHILE           reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    DO              reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    BREAK           reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    FOR             reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    PRINTF          reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    SCANF           reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    CONST           reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    ID              reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    IF              reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    INCREMENT       reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    DECREMENT       reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    INT             reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    FLOAT           reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    DOUBLE          reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    CHAR            reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    BOOL            reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    LONG            reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    VOID            reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    R_BRACE         reduce using rule 45 (else_else_if_statements_block -> else_if_statement .)
    ELSE            shift and go to state 169

    else_if_statement              shift and go to state 168
    else_else_if_statements_block  shift and go to state 185
    else_statement                 shift and go to state 167

state 169

    (46) else_statement -> ELSE . statements_block
    (47) else_if_statement -> ELSE . if_statement
    (15) statements_block -> . L_BRACE opt_statements R_BRACE
    (41) if_statement -> . IF L_BRACKET logical_expression R_BRACKET statements_block
    (42) if_statement -> . IF L_BRACKET value_expression R_BRACKET statements_block

    L_BRACE         shift and go to state 89
    IF              shift and go to state 140

    statements_block               shift and go to state 186
    if_statement                   shift and go to state 187

state 170

    (48) print_statement -> PRINTF L_BRACKET . value_expression R_BRACKET
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 51

    value_expression               shift and go to state 188
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49
    logical_expression             shift and go to state 50

state 171

    (49) scan_statement -> SCANF L_BRACKET . AMPERSAND ID R_BRACKET

    AMPERSAND       shift and go to state 189


state 172

    (71) assign_expression -> list_element_extraction assign_op . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 51

    list_element_extraction        shift and go to state 49
    value_expression               shift and go to state 190
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    logical_expression             shift and go to state 50

state 173

    (72) assign_expression -> unary_op ID .

    SEMICOLON       reduce using rule 72 (assign_expression -> unary_op ID .)
    R_BRACKET       reduce using rule 72 (assign_expression -> unary_op ID .)


state 174

    (41) if_statement -> IF L_BRACKET . logical_expression R_BRACKET statements_block
    (42) if_statement -> IF L_BRACKET . value_expression R_BRACKET statements_block
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    NEGATION        shift and go to state 51
    L_BRACKET       shift and go to state 86
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48

    logical_expression             shift and go to state 191
    value_expression               shift and go to state 192
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49

state 175

    (94) listed_values -> value_expression COMMA value_expression .
    (94) listed_values -> value_expression . COMMA value_expression
    (95) listed_values -> value_expression . COMMA listed_values
    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

    R_BRACE         reduce using rule 94 (listed_values -> value_expression COMMA value_expression .)
    R_BRACKET       reduce using rule 94 (listed_values -> value_expression COMMA value_expression .)
    COMMA           shift and go to state 145
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

    comparison_op                  shift and go to state 58

state 176

    (95) listed_values -> value_expression COMMA listed_values .

    R_BRACE         reduce using rule 95 (listed_values -> value_expression COMMA listed_values .)
    R_BRACKET       reduce using rule 95 (listed_values -> value_expression COMMA listed_values .)


state 177

    (69) trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .
    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
    R_SQUARE_BRACKET reduce using rule 69 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    SEMICOLON       reduce using rule 69 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    R_BRACKET       reduce using rule 69 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    COMMA           reduce using rule 69 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    R_BRACE         reduce using rule 69 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    QUESTION_MARK   reduce using rule 69 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    AND             reduce using rule 69 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    OR              reduce using rule 69 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    COLON           reduce using rule 69 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

  ! EQUAL           [ reduce using rule 69 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 69 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! GREATER         [ reduce using rule 69 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 69 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! LESSER          [ reduce using rule 69 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 69 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]

    comparison_op                  shift and go to state 58

state 178

    (70) assign_expression -> ID assign_op value_expression .
    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

    SEMICOLON       reduce using rule 70 (assign_expression -> ID assign_op value_expression .)
    R_BRACKET       reduce using rule 70 (assign_expression -> ID assign_op value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

    comparison_op                  shift and go to state 58

state 179

    (31) return_statement -> RETURN value_expression SEMICOLON .

    COMMENT         reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    SEMICOLON       reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    RETURN          reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    WHILE           reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    DO              reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    BREAK           reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    FOR             reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    PRINTF          reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    SCANF           reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    CONST           reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    ID              reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    IF              reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    INCREMENT       reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    DECREMENT       reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    INT             reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    FLOAT           reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    DOUBLE          reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    CHAR            reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    BOOL            reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    LONG            reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    VOID            reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    R_BRACE         reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)


state 180

    (34) while_loop_statement -> WHILE L_BRACKET logical_expression . R_BRACKET statements_block
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (69) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (103) bool_op -> . AND
    (104) bool_op -> . OR

    R_BRACKET       shift and go to state 193
    QUESTION_MARK   shift and go to state 80
    AND             shift and go to state 82
    OR              shift and go to state 83

    bool_op                        shift and go to state 81

state 181

    (35) do_while_loop_statement -> DO statements_block WHILE . L_BRACKET logical_expression R_BRACKET SEMICOLON

    L_BRACKET       shift and go to state 194


state 182

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem . opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block
    (74) opt_logical_expression -> . logical_expression
    (75) opt_logical_expression -> . empty
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET
    (128) empty -> .
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    NEGATION        shift and go to state 51
    L_BRACKET       shift and go to state 86
    SEMICOLON       reduce using rule 128 (empty -> .)
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48

    opt_logical_expression         shift and go to state 195
    logical_expression             shift and go to state 196
    empty                          shift and go to state 197
    value_expression               shift and go to state 85
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49

state 183

    (38) decl_stat_or_sem -> SEMICOLON .

    NEGATION        reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    L_BRACKET       reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    MINUS           reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    ID              reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    INTEGER         reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    DECIMAL         reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    CHARACTER       reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    STRING          reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    TRUE            reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    FALSE           reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    SEMICOLON       reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)


state 184

    (37) decl_stat_or_sem -> declaration_statement .

    NEGATION        reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    L_BRACKET       reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    MINUS           reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    ID              reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    INTEGER         reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    DECIMAL         reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    CHARACTER       reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    STRING          reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    TRUE            reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    FALSE           reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    SEMICOLON       reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)


state 185

    (44) else_else_if_statements_block -> else_if_statement else_else_if_statements_block .

    COMMENT         reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    SEMICOLON       reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    RETURN          reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    WHILE           reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    DO              reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    BREAK           reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    FOR             reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    PRINTF          reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    SCANF           reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    CONST           reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    ID              reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    IF              reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    INCREMENT       reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    DECREMENT       reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    INT             reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    FLOAT           reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    DOUBLE          reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    CHAR            reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    BOOL            reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    LONG            reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    VOID            reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)
    R_BRACE         reduce using rule 44 (else_else_if_statements_block -> else_if_statement else_else_if_statements_block .)


state 186

    (46) else_statement -> ELSE statements_block .

    COMMENT         reduce using rule 46 (else_statement -> ELSE statements_block .)
    SEMICOLON       reduce using rule 46 (else_statement -> ELSE statements_block .)
    RETURN          reduce using rule 46 (else_statement -> ELSE statements_block .)
    WHILE           reduce using rule 46 (else_statement -> ELSE statements_block .)
    DO              reduce using rule 46 (else_statement -> ELSE statements_block .)
    BREAK           reduce using rule 46 (else_statement -> ELSE statements_block .)
    FOR             reduce using rule 46 (else_statement -> ELSE statements_block .)
    PRINTF          reduce using rule 46 (else_statement -> ELSE statements_block .)
    SCANF           reduce using rule 46 (else_statement -> ELSE statements_block .)
    CONST           reduce using rule 46 (else_statement -> ELSE statements_block .)
    ID              reduce using rule 46 (else_statement -> ELSE statements_block .)
    IF              reduce using rule 46 (else_statement -> ELSE statements_block .)
    INCREMENT       reduce using rule 46 (else_statement -> ELSE statements_block .)
    DECREMENT       reduce using rule 46 (else_statement -> ELSE statements_block .)
    INT             reduce using rule 46 (else_statement -> ELSE statements_block .)
    FLOAT           reduce using rule 46 (else_statement -> ELSE statements_block .)
    DOUBLE          reduce using rule 46 (else_statement -> ELSE statements_block .)
    CHAR            reduce using rule 46 (else_statement -> ELSE statements_block .)
    BOOL            reduce using rule 46 (else_statement -> ELSE statements_block .)
    LONG            reduce using rule 46 (else_statement -> ELSE statements_block .)
    VOID            reduce using rule 46 (else_statement -> ELSE statements_block .)
    R_BRACE         reduce using rule 46 (else_statement -> ELSE statements_block .)


state 187

    (47) else_if_statement -> ELSE if_statement .

    ELSE            reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    COMMENT         reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    SEMICOLON       reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    RETURN          reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    WHILE           reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    DO              reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    BREAK           reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    FOR             reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    PRINTF          reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    SCANF           reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    CONST           reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    ID              reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    IF              reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    INCREMENT       reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    DECREMENT       reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    INT             reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    FLOAT           reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    DOUBLE          reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    CHAR            reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    BOOL            reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    LONG            reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    VOID            reduce using rule 47 (else_if_statement -> ELSE if_statement .)
    R_BRACE         reduce using rule 47 (else_if_statement -> ELSE if_statement .)


state 188

    (48) print_statement -> PRINTF L_BRACKET value_expression . R_BRACKET
    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

    R_BRACKET       shift and go to state 198
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

    comparison_op                  shift and go to state 58

state 189

    (49) scan_statement -> SCANF L_BRACKET AMPERSAND . ID R_BRACKET

    ID              shift and go to state 199


state 190

    (71) assign_expression -> list_element_extraction assign_op value_expression .
    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

    SEMICOLON       reduce using rule 71 (assign_expression -> list_element_extraction assign_op value_expression .)
    R_BRACKET       reduce using rule 71 (assign_expression -> list_element_extraction assign_op value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

    comparison_op                  shift and go to state 58

state 191

    (41) if_statement -> IF L_BRACKET logical_expression . R_BRACKET statements_block
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (69) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (103) bool_op -> . AND
    (104) bool_op -> . OR

    R_BRACKET       shift and go to state 200
    QUESTION_MARK   shift and go to state 80
    AND             shift and go to state 82
    OR              shift and go to state 83

    bool_op                        shift and go to state 81

state 192

    (42) if_statement -> IF L_BRACKET value_expression . R_BRACKET statements_block
    (66) logical_expression -> value_expression . comparison_op value_expression
    (105) comparison_op -> . EQUAL
    (106) comparison_op -> . NOT_EQUAL
    (107) comparison_op -> . GREATER
    (108) comparison_op -> . GREATER_EQUAL
    (109) comparison_op -> . LESSER
    (110) comparison_op -> . LESSER_EQUAL

    R_BRACKET       shift and go to state 201
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

    comparison_op                  shift and go to state 58

state 193

    (34) while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 89

    statements_block               shift and go to state 202

state 194

    (35) do_while_loop_statement -> DO statements_block WHILE L_BRACKET . logical_expression R_BRACKET SEMICOLON
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (67) logical_expression -> . L_BRACKET logical_expression R_BRACKET
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (68) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (85) value -> . INTEGER
    (86) value -> . DECIMAL
    (87) value -> . CHARACTER
    (88) value -> . STRING
    (89) value -> . TRUE
    (90) value -> . FALSE
    (91) value -> . ID
    (92) value -> . list_element_extraction
    (69) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    NEGATION        shift and go to state 51
    L_BRACKET       shift and go to state 86
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48

    logical_expression             shift and go to state 203
    value_expression               shift and go to state 85
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    list_element_extraction        shift and go to state 49

state 195

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression . SEMICOLON opt_assign_expression R_BRACKET statements_block

    SEMICOLON       shift and go to state 204


state 196

    (74) opt_logical_expression -> logical_expression .
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (69) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (103) bool_op -> . AND
    (104) bool_op -> . OR

    SEMICOLON       reduce using rule 74 (opt_logical_expression -> logical_expression .)
    QUESTION_MARK   shift and go to state 80
    AND             shift and go to state 82
    OR              shift and go to state 83

    bool_op                        shift and go to state 81

state 197

    (75) opt_logical_expression -> empty .

    SEMICOLON       reduce using rule 75 (opt_logical_expression -> empty .)


state 198

    (48) print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .

    COMMENT         reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    SEMICOLON       reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    RETURN          reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    WHILE           reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    DO              reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    BREAK           reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    FOR             reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    PRINTF          reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    SCANF           reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    CONST           reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    ID              reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    IF              reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    INCREMENT       reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    DECREMENT       reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    INT             reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    FLOAT           reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    DOUBLE          reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    CHAR            reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    BOOL            reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    LONG            reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    VOID            reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    R_BRACE         reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)


state 199

    (49) scan_statement -> SCANF L_BRACKET AMPERSAND ID . R_BRACKET

    R_BRACKET       shift and go to state 205


state 200

    (41) if_statement -> IF L_BRACKET logical_expression R_BRACKET . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 89

    statements_block               shift and go to state 206

state 201

    (42) if_statement -> IF L_BRACKET value_expression R_BRACKET . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 89

    statements_block               shift and go to state 207

state 202

    (34) while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .

    COMMENT         reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    SEMICOLON       reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    RETURN          reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    WHILE           reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    DO              reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    BREAK           reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    FOR             reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    PRINTF          reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    SCANF           reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    CONST           reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    ID              reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    IF              reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    INCREMENT       reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    DECREMENT       reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    INT             reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    FLOAT           reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    DOUBLE          reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    CHAR            reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    BOOL            reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    LONG            reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    VOID            reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    R_BRACE         reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)


state 203

    (35) do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression . R_BRACKET SEMICOLON
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (69) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (103) bool_op -> . AND
    (104) bool_op -> . OR

    R_BRACKET       shift and go to state 208
    QUESTION_MARK   shift and go to state 80
    AND             shift and go to state 82
    OR              shift and go to state 83

    bool_op                        shift and go to state 81

state 204

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON . opt_assign_expression R_BRACKET statements_block
    (76) opt_assign_expression -> . assign_expression
    (77) opt_assign_expression -> . empty
    (70) assign_expression -> . ID assign_op value_expression
    (71) assign_expression -> . list_element_extraction assign_op value_expression
    (72) assign_expression -> . unary_op ID
    (73) assign_expression -> . ID unary_op
    (128) empty -> .
    (93) list_element_extraction -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (101) unary_op -> . INCREMENT
    (102) unary_op -> . DECREMENT

    ID              shift and go to state 212
    R_BRACKET       reduce using rule 128 (empty -> .)
    INCREMENT       shift and go to state 141
    DECREMENT       shift and go to state 142

    opt_assign_expression          shift and go to state 209
    assign_expression              shift and go to state 210
    empty                          shift and go to state 211
    list_element_extraction        shift and go to state 138
    unary_op                       shift and go to state 139

state 205

    (49) scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .

    COMMENT         reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    SEMICOLON       reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    RETURN          reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    WHILE           reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    DO              reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    BREAK           reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    FOR             reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    PRINTF          reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    SCANF           reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    CONST           reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    ID              reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    IF              reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    INCREMENT       reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    DECREMENT       reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    INT             reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    FLOAT           reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    DOUBLE          reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    CHAR            reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    BOOL            reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    LONG            reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    VOID            reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    R_BRACE         reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)


state 206

    (41) if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .

    ELSE            reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    COMMENT         reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    SEMICOLON       reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    RETURN          reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    WHILE           reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    DO              reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    BREAK           reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    FOR             reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    PRINTF          reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    SCANF           reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    CONST           reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    ID              reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    IF              reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    INCREMENT       reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    DECREMENT       reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    INT             reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    FLOAT           reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    DOUBLE          reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    CHAR            reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    BOOL            reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    LONG            reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    VOID            reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    R_BRACE         reduce using rule 41 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)


state 207

    (42) if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .

    ELSE            reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    COMMENT         reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    SEMICOLON       reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    RETURN          reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    WHILE           reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    DO              reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    BREAK           reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    FOR             reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    PRINTF          reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    SCANF           reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    CONST           reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    ID              reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    IF              reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    INCREMENT       reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    DECREMENT       reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    INT             reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    FLOAT           reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    DOUBLE          reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    CHAR            reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    BOOL            reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    LONG            reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    VOID            reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)
    R_BRACE         reduce using rule 42 (if_statement -> IF L_BRACKET value_expression R_BRACKET statements_block .)


state 208

    (35) do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET . SEMICOLON

    SEMICOLON       shift and go to state 213


state 209

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression . R_BRACKET statements_block

    R_BRACKET       shift and go to state 214


state 210

    (76) opt_assign_expression -> assign_expression .

    R_BRACKET       reduce using rule 76 (opt_assign_expression -> assign_expression .)


state 211

    (77) opt_assign_expression -> empty .

    R_BRACKET       reduce using rule 77 (opt_assign_expression -> empty .)


state 212

    (70) assign_expression -> ID . assign_op value_expression
    (73) assign_expression -> ID . unary_op
    (93) list_element_extraction -> ID . L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (111) assign_op -> . ASSIGN
    (112) assign_op -> . PLUS_ASSIGN
    (113) assign_op -> . MINUS_ASSIGN
    (114) assign_op -> . MUL_ASSIGN
    (115) assign_op -> . DIV_ASSIGN
    (116) assign_op -> . MOD_ASSIGN
    (101) unary_op -> . INCREMENT
    (102) unary_op -> . DECREMENT

    L_SQUARE_BRACKET shift and go to state 79
    ASSIGN          shift and go to state 153
    PLUS_ASSIGN     shift and go to state 154
    MINUS_ASSIGN    shift and go to state 155
    MUL_ASSIGN      shift and go to state 156
    DIV_ASSIGN      shift and go to state 157
    MOD_ASSIGN      shift and go to state 158
    INCREMENT       shift and go to state 141
    DECREMENT       shift and go to state 142

    assign_op                      shift and go to state 151
    unary_op                       shift and go to state 152

state 213

    (35) do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .

    COMMENT         reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    RETURN          reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    WHILE           reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    DO              reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    BREAK           reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    FOR             reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    PRINTF          reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    SCANF           reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    CONST           reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    ID              reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    IF              reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    INCREMENT       reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    DECREMENT       reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    INT             reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    FLOAT           reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    DOUBLE          reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    CHAR            reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    BOOL            reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    LONG            reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    VOID            reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    R_BRACE         reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)


state 214

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 89

    statements_block               shift and go to state 215

state 215

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .

    COMMENT         reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    SEMICOLON       reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    RETURN          reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    WHILE           reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    DO              reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    BREAK           reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    FOR             reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    PRINTF          reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    SCANF           reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    CONST           reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    ID              reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    IF              reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    INCREMENT       reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    DECREMENT       reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    INT             reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    FLOAT           reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    DOUBLE          reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    CHAR            reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    BOOL            reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    LONG            reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    VOID            reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    R_BRACE         reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 0 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 0 resolved as shift
WARNING: shift/reduce conflict for LONG in state 0 resolved as shift
WARNING: shift/reduce conflict for VOID in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 3 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 3 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 3 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 3 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 3 resolved as shift
WARNING: shift/reduce conflict for LONG in state 3 resolved as shift
WARNING: shift/reduce conflict for VOID in state 3 resolved as shift
WARNING: shift/reduce conflict for R_BRACKET in state 72 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 84 resolved as shift
WARNING: shift/reduce conflict for AND in state 84 resolved as shift
WARNING: shift/reduce conflict for OR in state 84 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 107 resolved as shift
WARNING: shift/reduce conflict for AND in state 107 resolved as shift
WARNING: shift/reduce conflict for OR in state 107 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 177 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 177 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 177 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 177 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 177 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 177 resolved as shift
