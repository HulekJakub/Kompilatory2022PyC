Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> s_prim
Rule 1     s_prim -> program
Rule 2     program -> program_component
Rule 3     program -> program_component program
Rule 4     program_component -> declaration_statement
Rule 5     program_component -> function_definition_statement
Rule 6     program_component -> COMMENT
Rule 7     program_component -> PREPROCESSOR_LINE
Rule 8     statement -> any_statement
Rule 9     statement -> COMMENT
Rule 10    statement -> SEMICOLON
Rule 11    statements -> statement
Rule 12    statements -> statement statements
Rule 13    opt_statements -> statements
Rule 14    opt_statements -> empty
Rule 15    statements_block -> L_BRACE opt_statements R_BRACE
Rule 16    any_statement -> declaration_statement
Rule 17    any_statement -> assign_statement
Rule 18    any_statement -> function_statement
Rule 19    any_statement -> return_statement
Rule 20    any_statement -> while_loop_statement
Rule 21    any_statement -> do_while_loop_statement
Rule 22    any_statement -> break_statement
Rule 23    any_statement -> for_loop_statement
Rule 24    any_statement -> if_statement opt_else_if_statements opt_else_statement
Rule 25    any_statement -> print_statement
Rule 26    any_statement -> scan_statement
Rule 27    declaration_statement -> opt_const type ID opt_array_mark
Rule 28    declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
Rule 29    assign_statement -> assign_expression SEMICOLON
Rule 30    function_statement -> function_expression SEMICOLON
Rule 31    return_statement -> RETURN value_expression SEMICOLON
Rule 32    break_statement -> BREAK SEMICOLON
Rule 33    function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block
Rule 34    while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block
Rule 35    do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON
Rule 36    for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block
Rule 37    decl_stat_or_sem -> declaration_statement
Rule 38    decl_stat_or_sem -> SEMICOLON
Rule 39    if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block
Rule 40    else_statement -> ELSE statements_block
Rule 41    else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block
Rule 42    else_if_statements -> else_if_statement
Rule 43    else_if_statements -> else_if_statement else_if_statements
Rule 44    opt_else_statement -> else_statement
Rule 45    opt_else_statement -> empty
Rule 46    opt_else_if_statements -> else_if_statements
Rule 47    opt_else_if_statements -> empty
Rule 48    print_statement -> PRINTF L_BRACKET value_expression R_BRACKET
Rule 49    scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET
Rule 50    declaration_value_expression -> value_expression
Rule 51    declaration_value_expression -> L_BRACE listed_values R_BRACE
Rule 52    declaration_value_expression -> L_BRACE declaration_value_expression R_BRACE
Rule 53    value_expression -> math_expression
Rule 54    value_expression -> function_expression
Rule 55    value_expression -> value
Rule 56    value_expression -> trinary_mark_expression
Rule 57    value_expression -> L_BRACKET value_expression R_BRACKET
Rule 58    opt_value_expression -> value_expression
Rule 59    opt_value_expression -> empty
Rule 60    math_expression -> L_BRACKET math_expression R_BRACKET
Rule 61    math_expression -> MINUS math_expression
Rule 62    math_expression -> MINUS value
Rule 63    math_expression -> value math_op value
Rule 64    logical_expression -> logical_expression bool_op logical_expression
Rule 65    logical_expression -> NEGATION logical_expression
Rule 66    logical_expression -> value_expression comparison_op value_expression
Rule 67    function_expression -> ID L_BRACKET opt_listed_values R_BRACKET
Rule 68    trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression
Rule 69    assign_expression -> ID assign_op value_expression
Rule 70    assign_expression -> unary_op ID
Rule 71    assign_expression -> ID unary_op
Rule 72    opt_logical_expression -> logical_expression
Rule 73    opt_logical_expression -> empty
Rule 74    opt_assign_expression -> assign_expression
Rule 75    opt_assign_expression -> empty
Rule 76    type -> INT
Rule 77    type -> FLOAT
Rule 78    type -> DOUBLE
Rule 79    type -> CHAR
Rule 80    type -> BOOL
Rule 81    type -> LONG
Rule 82    type -> VOID
Rule 83    value -> INTEGER
Rule 84    value -> DECIMAL
Rule 85    value -> CHARACTER
Rule 86    value -> STRING
Rule 87    value -> TRUE
Rule 88    value -> FALSE
Rule 89    value -> ID
Rule 90    value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
Rule 91    listed_values -> value_expression COMMA value_expression
Rule 92    listed_values -> value_expression COMMA listed_values
Rule 93    math_op -> PLUS
Rule 94    math_op -> MINUS
Rule 95    math_op -> MUL
Rule 96    math_op -> DIV
Rule 97    math_op -> MOD
Rule 98    unary_op -> INCREMENT
Rule 99    unary_op -> DECREMENT
Rule 100   bool_op -> AND
Rule 101   bool_op -> OR
Rule 102   comparison_op -> EQUAL
Rule 103   comparison_op -> NOT_EQUAL
Rule 104   comparison_op -> GREATER
Rule 105   comparison_op -> GREATER_EQUAL
Rule 106   comparison_op -> LESSER
Rule 107   comparison_op -> LESSER_EQUAL
Rule 108   assign_op -> ASSIGN
Rule 109   assign_op -> PLUS_ASSIGN
Rule 110   assign_op -> MINUS_ASSIGN
Rule 111   assign_op -> MUL_ASSIGN
Rule 112   assign_op -> DIV_ASSIGN
Rule 113   assign_op -> MOD_ASSIGN
Rule 114   array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET
Rule 115   opt_const -> CONST
Rule 116   opt_const -> empty
Rule 117   opt_array_mark -> array_mark
Rule 118   opt_array_mark -> empty
Rule 119   opt_listed_values -> listed_values
Rule 120   opt_listed_values -> empty
Rule 121   args -> type ID
Rule 122   args -> type ID COMMA args
Rule 123   opt_args -> args
Rule 124   opt_args -> empty
Rule 125   empty -> <empty>

Terminals, with rules where they appear

AMPERSAND            : 49
AND                  : 100
ASSIGN               : 28 108
BOOL                 : 80
BREAK                : 32
CHAR                 : 79
CHARACTER            : 85
COLON                : 68
COMMA                : 91 92 122
COMMENT              : 6 9
CONST                : 115
DECIMAL              : 84
DECREMENT            : 99
DIV                  : 96
DIV_ASSIGN           : 112
DO                   : 35
DOUBLE               : 78
ELSE                 : 40 41
EQUAL                : 102
FALSE                : 88
FLOAT                : 77
FOR                  : 36
GREATER              : 104
GREATER_EQUAL        : 105
ID                   : 27 28 33 49 67 69 70 71 89 90 121 122
IF                   : 39 41
INCREMENT            : 98
INT                  : 76
INTEGER              : 83
LESSER               : 106
LESSER_EQUAL         : 107
LONG                 : 81
L_BRACE              : 15 51 52
L_BRACKET            : 33 34 35 36 39 41 48 49 57 60 67
L_SQUARE_BRACKET     : 90 114
MINUS                : 61 62 94
MINUS_ASSIGN         : 110
MOD                  : 97
MOD_ASSIGN           : 113
MUL                  : 95
MUL_ASSIGN           : 111
NEGATION             : 65
NOT_EQUAL            : 103
OR                   : 101
PLUS                 : 93
PLUS_ASSIGN          : 109
PREPROCESSOR_LINE    : 7
PRINTF               : 48
QUESTION_MARK        : 68
RETURN               : 31
R_BRACE              : 15 51 52
R_BRACKET            : 33 34 35 36 39 41 48 49 57 60 67
R_SQUARE_BRACKET     : 90 114
SCANF                : 49
SEMICOLON            : 10 28 29 30 31 32 35 36 38
STRING               : 91
TRUE                 : 92
VOID                 : 87
WHILE                : 34 35
error                : 

Nonterminals, with rules where they appear

any_statement        : 8
args                 : 122 123
array_mark           : 117
assign_expression    : 29 74
assign_op            : 69
assign_statement     : 17
bool_op              : 64
break_statement      : 22
comparison_op        : 66
decl_stat_or_sem     : 36
declaration_statement : 4 16 37
declaration_value_expression : 28 52
do_while_loop_statement : 21
else_if_statement    : 42 43
else_if_statements   : 43 46
else_statement       : 44
empty                : 14 45 47 59 73 75 116 118 120 124
for_loop_statement   : 23
function_definition_statement : 5
function_expression  : 30 54
function_statement   : 18
if_statement         : 24
listed_values        : 51 92 119
logical_expression   : 34 35 39 41 64 64 65 68 72
math_expression      : 53 60 61
math_op              : 63
opt_args             : 33
opt_array_mark       : 27 28
opt_assign_expression : 36
opt_const            : 27 28
opt_else_if_statements : 24
opt_else_statement   : 24
opt_listed_values    : 67
opt_logical_expression : 36
opt_statements       : 15
opt_value_expression : 114
print_statement      : 25
program              : 1 3
program_component    : 2 3
return_statement     : 19
s_prim               : 0
scan_statement       : 26
statement            : 11 12
statements           : 12 13
statements_block     : 33 34 35 36 39 40 41
trinary_mark_expression : 56
type                 : 27 28 33 121 122
unary_op             : 70 71
value                : 55 62 63 63
value_expression     : 31 48 50 57 58 66 66 68 68 69 90 91 91 92
while_loop_statement : 20

Parsing method: LALR

state 0

    (0) S' -> . s_prim
    (1) s_prim -> . program
    (2) program -> . program_component
    (3) program -> . program_component program
    (4) program_component -> . declaration_statement
    (5) program_component -> . function_definition_statement
    (6) program_component -> . COMMENT
    (7) program_component -> . PREPROCESSOR_LINE
    (27) declaration_statement -> . opt_const type ID opt_array_mark
    (28) declaration_statement -> . opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (33) function_definition_statement -> . type ID L_BRACKET opt_args R_BRACKET statements_block
    (115) opt_const -> . CONST
    (116) opt_const -> . empty
    (76) type -> . INT
    (77) type -> . FLOAT
    (78) type -> . DOUBLE
    (79) type -> . CHAR
    (80) type -> . BOOL
    (81) type -> . LONG
    (82) type -> . VOID
    (125) empty -> .

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LONG resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    COMMENT         shift and go to state 6
    PREPROCESSOR_LINE shift and go to state 7
    CONST           shift and go to state 10
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

  ! INT             [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 125 (empty -> .) ]
  ! CHAR            [ reduce using rule 125 (empty -> .) ]
  ! BOOL            [ reduce using rule 125 (empty -> .) ]
  ! LONG            [ reduce using rule 125 (empty -> .) ]
  ! VOID            [ reduce using rule 125 (empty -> .) ]

    s_prim                         shift and go to state 1
    program                        shift and go to state 2
    program_component              shift and go to state 3
    declaration_statement          shift and go to state 4
    function_definition_statement  shift and go to state 5
    opt_const                      shift and go to state 8
    type                           shift and go to state 9
    empty                          shift and go to state 11

state 1

    (0) S' -> s_prim .



state 2

    (1) s_prim -> program .

    $end            reduce using rule 1 (s_prim -> program .)


state 3

    (2) program -> program_component .
    (3) program -> program_component . program
    (2) program -> . program_component
    (3) program -> . program_component program
    (4) program_component -> . declaration_statement
    (5) program_component -> . function_definition_statement
    (6) program_component -> . COMMENT
    (7) program_component -> . PREPROCESSOR_LINE
    (27) declaration_statement -> . opt_const type ID opt_array_mark
    (28) declaration_statement -> . opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (33) function_definition_statement -> . type ID L_BRACKET opt_args R_BRACKET statements_block
    (115) opt_const -> . CONST
    (116) opt_const -> . empty
    (76) type -> . INT
    (77) type -> . FLOAT
    (78) type -> . DOUBLE
    (79) type -> . CHAR
    (80) type -> . BOOL
    (81) type -> . LONG
    (82) type -> . VOID
    (125) empty -> .

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LONG resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    $end            reduce using rule 2 (program -> program_component .)
    COMMENT         shift and go to state 6
    PREPROCESSOR_LINE shift and go to state 7
    CONST           shift and go to state 10
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

  ! INT             [ reduce using rule 125 (empty -> .) ]
  ! FLOAT           [ reduce using rule 125 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 125 (empty -> .) ]
  ! CHAR            [ reduce using rule 125 (empty -> .) ]
  ! BOOL            [ reduce using rule 125 (empty -> .) ]
  ! LONG            [ reduce using rule 125 (empty -> .) ]
  ! VOID            [ reduce using rule 125 (empty -> .) ]

    program_component              shift and go to state 3
    program                        shift and go to state 19
    declaration_statement          shift and go to state 4
    function_definition_statement  shift and go to state 5
    opt_const                      shift and go to state 8
    type                           shift and go to state 9
    empty                          shift and go to state 11

state 4

    (4) program_component -> declaration_statement .

    COMMENT         reduce using rule 4 (program_component -> declaration_statement .)
    PREPROCESSOR_LINE reduce using rule 4 (program_component -> declaration_statement .)
    CONST           reduce using rule 4 (program_component -> declaration_statement .)
    INT             reduce using rule 4 (program_component -> declaration_statement .)
    FLOAT           reduce using rule 4 (program_component -> declaration_statement .)
    DOUBLE          reduce using rule 4 (program_component -> declaration_statement .)
    CHAR            reduce using rule 4 (program_component -> declaration_statement .)
    BOOL            reduce using rule 4 (program_component -> declaration_statement .)
    LONG            reduce using rule 4 (program_component -> declaration_statement .)
    VOID            reduce using rule 4 (program_component -> declaration_statement .)
    $end            reduce using rule 4 (program_component -> declaration_statement .)


state 5

    (5) program_component -> function_definition_statement .

    COMMENT         reduce using rule 5 (program_component -> function_definition_statement .)
    PREPROCESSOR_LINE reduce using rule 5 (program_component -> function_definition_statement .)
    CONST           reduce using rule 5 (program_component -> function_definition_statement .)
    INT             reduce using rule 5 (program_component -> function_definition_statement .)
    FLOAT           reduce using rule 5 (program_component -> function_definition_statement .)
    DOUBLE          reduce using rule 5 (program_component -> function_definition_statement .)
    CHAR            reduce using rule 5 (program_component -> function_definition_statement .)
    BOOL            reduce using rule 5 (program_component -> function_definition_statement .)
    LONG            reduce using rule 5 (program_component -> function_definition_statement .)
    VOID            reduce using rule 5 (program_component -> function_definition_statement .)
    $end            reduce using rule 5 (program_component -> function_definition_statement .)


state 6

    (6) program_component -> COMMENT .

    COMMENT         reduce using rule 6 (program_component -> COMMENT .)
    PREPROCESSOR_LINE reduce using rule 6 (program_component -> COMMENT .)
    CONST           reduce using rule 6 (program_component -> COMMENT .)
    INT             reduce using rule 6 (program_component -> COMMENT .)
    FLOAT           reduce using rule 6 (program_component -> COMMENT .)
    DOUBLE          reduce using rule 6 (program_component -> COMMENT .)
    CHAR            reduce using rule 6 (program_component -> COMMENT .)
    BOOL            reduce using rule 6 (program_component -> COMMENT .)
    LONG            reduce using rule 6 (program_component -> COMMENT .)
    VOID            reduce using rule 6 (program_component -> COMMENT .)
    $end            reduce using rule 6 (program_component -> COMMENT .)


state 7

    (7) program_component -> PREPROCESSOR_LINE .

    COMMENT         reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    PREPROCESSOR_LINE reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    CONST           reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    INT             reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    FLOAT           reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    DOUBLE          reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    CHAR            reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    BOOL            reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    LONG            reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    VOID            reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    $end            reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)


state 8

    (27) declaration_statement -> opt_const . type ID opt_array_mark
    (28) declaration_statement -> opt_const . type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (76) type -> . INT
    (77) type -> . FLOAT
    (78) type -> . DOUBLE
    (79) type -> . CHAR
    (80) type -> . BOOL
    (81) type -> . LONG
    (82) type -> . VOID

    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

    type                           shift and go to state 20

state 9

    (33) function_definition_statement -> type . ID L_BRACKET opt_args R_BRACKET statements_block

    ID              shift and go to state 21


state 10

    (115) opt_const -> CONST .

    INT             reduce using rule 115 (opt_const -> CONST .)
    FLOAT           reduce using rule 115 (opt_const -> CONST .)
    DOUBLE          reduce using rule 115 (opt_const -> CONST .)
    CHAR            reduce using rule 115 (opt_const -> CONST .)
    BOOL            reduce using rule 115 (opt_const -> CONST .)
    LONG            reduce using rule 115 (opt_const -> CONST .)
    VOID            reduce using rule 115 (opt_const -> CONST .)


state 11

    (116) opt_const -> empty .

    INT             reduce using rule 116 (opt_const -> empty .)
    FLOAT           reduce using rule 116 (opt_const -> empty .)
    DOUBLE          reduce using rule 116 (opt_const -> empty .)
    CHAR            reduce using rule 116 (opt_const -> empty .)
    BOOL            reduce using rule 116 (opt_const -> empty .)
    LONG            reduce using rule 116 (opt_const -> empty .)
    VOID            reduce using rule 116 (opt_const -> empty .)


state 12

    (76) type -> INT .

    ID              reduce using rule 76 (type -> INT .)


state 13

    (77) type -> FLOAT .

    ID              reduce using rule 77 (type -> FLOAT .)


state 14

    (78) type -> DOUBLE .

    ID              reduce using rule 78 (type -> DOUBLE .)


state 15

    (79) type -> CHAR .

    ID              reduce using rule 79 (type -> CHAR .)


state 16

    (80) type -> BOOL .

    ID              reduce using rule 80 (type -> BOOL .)


state 17

    (81) type -> LONG .

    ID              reduce using rule 81 (type -> LONG .)


state 18

    (82) type -> VOID .

    ID              reduce using rule 82 (type -> VOID .)


state 19

    (3) program -> program_component program .

    $end            reduce using rule 3 (program -> program_component program .)


state 20

    (27) declaration_statement -> opt_const type . ID opt_array_mark
    (28) declaration_statement -> opt_const type . ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON

    ID              shift and go to state 22


state 21

    (33) function_definition_statement -> type ID . L_BRACKET opt_args R_BRACKET statements_block

    L_BRACKET       shift and go to state 23


state 22

    (27) declaration_statement -> opt_const type ID . opt_array_mark
    (28) declaration_statement -> opt_const type ID . opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (117) opt_array_mark -> . array_mark
    (118) opt_array_mark -> . empty
    (114) array_mark -> . L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET
    (125) empty -> .

    L_SQUARE_BRACKET shift and go to state 27
    ASSIGN          reduce using rule 125 (empty -> .)
    COMMENT         reduce using rule 125 (empty -> .)
    PREPROCESSOR_LINE reduce using rule 125 (empty -> .)
    CONST           reduce using rule 125 (empty -> .)
    INT             reduce using rule 125 (empty -> .)
    FLOAT           reduce using rule 125 (empty -> .)
    DOUBLE          reduce using rule 125 (empty -> .)
    CHAR            reduce using rule 125 (empty -> .)
    BOOL            reduce using rule 125 (empty -> .)
    LONG            reduce using rule 125 (empty -> .)
    VOID            reduce using rule 125 (empty -> .)
    $end            reduce using rule 125 (empty -> .)
    SEMICOLON       reduce using rule 125 (empty -> .)
    RETURN          reduce using rule 125 (empty -> .)
    WHILE           reduce using rule 125 (empty -> .)
    DO              reduce using rule 125 (empty -> .)
    BREAK           reduce using rule 125 (empty -> .)
    FOR             reduce using rule 125 (empty -> .)
    IF              reduce using rule 125 (empty -> .)
    PRINTF          reduce using rule 125 (empty -> .)
    SCANF           reduce using rule 125 (empty -> .)
    ID              reduce using rule 125 (empty -> .)
    INCREMENT       reduce using rule 125 (empty -> .)
    DECREMENT       reduce using rule 125 (empty -> .)
    R_BRACE         reduce using rule 125 (empty -> .)
    NEGATION        reduce using rule 125 (empty -> .)
    L_BRACKET       reduce using rule 125 (empty -> .)
    MINUS           reduce using rule 125 (empty -> .)
    INTEGER         reduce using rule 125 (empty -> .)
    DECIMAL         reduce using rule 125 (empty -> .)
    CHARACTER       reduce using rule 125 (empty -> .)
    STRING          reduce using rule 125 (empty -> .)
    TRUE            reduce using rule 125 (empty -> .)
    FALSE           reduce using rule 125 (empty -> .)

    opt_array_mark                 shift and go to state 24
    array_mark                     shift and go to state 25
    empty                          shift and go to state 26

state 23

    (33) function_definition_statement -> type ID L_BRACKET . opt_args R_BRACKET statements_block
    (123) opt_args -> . args
    (124) opt_args -> . empty
    (121) args -> . type ID
    (122) args -> . type ID COMMA args
    (125) empty -> .
    (76) type -> . INT
    (77) type -> . FLOAT
    (78) type -> . DOUBLE
    (79) type -> . CHAR
    (80) type -> . BOOL
    (81) type -> . LONG
    (82) type -> . VOID

    R_BRACKET       reduce using rule 125 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

    type                           shift and go to state 28
    opt_args                       shift and go to state 29
    args                           shift and go to state 30
    empty                          shift and go to state 31

state 24

    (27) declaration_statement -> opt_const type ID opt_array_mark .
    (28) declaration_statement -> opt_const type ID opt_array_mark . ASSIGN declaration_value_expression SEMICOLON

    COMMENT         reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    PREPROCESSOR_LINE reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    CONST           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    INT             reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    FLOAT           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    DOUBLE          reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    CHAR            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    BOOL            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    LONG            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    VOID            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    $end            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    SEMICOLON       reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    RETURN          reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    WHILE           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    DO              reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    BREAK           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    FOR             reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    IF              reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    PRINTF          reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    SCANF           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    ID              reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    INCREMENT       reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    DECREMENT       reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    R_BRACE         reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    NEGATION        reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    L_BRACKET       reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    MINUS           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    INTEGER         reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    DECIMAL         reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    CHARACTER       reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    STRING          reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    TRUE            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    FALSE           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    ASSIGN          shift and go to state 32


state 25

    (117) opt_array_mark -> array_mark .

    ASSIGN          reduce using rule 117 (opt_array_mark -> array_mark .)
    COMMENT         reduce using rule 117 (opt_array_mark -> array_mark .)
    PREPROCESSOR_LINE reduce using rule 117 (opt_array_mark -> array_mark .)
    CONST           reduce using rule 117 (opt_array_mark -> array_mark .)
    INT             reduce using rule 117 (opt_array_mark -> array_mark .)
    FLOAT           reduce using rule 117 (opt_array_mark -> array_mark .)
    DOUBLE          reduce using rule 117 (opt_array_mark -> array_mark .)
    CHAR            reduce using rule 117 (opt_array_mark -> array_mark .)
    BOOL            reduce using rule 117 (opt_array_mark -> array_mark .)
    LONG            reduce using rule 117 (opt_array_mark -> array_mark .)
    VOID            reduce using rule 117 (opt_array_mark -> array_mark .)
    $end            reduce using rule 117 (opt_array_mark -> array_mark .)
    SEMICOLON       reduce using rule 117 (opt_array_mark -> array_mark .)
    RETURN          reduce using rule 117 (opt_array_mark -> array_mark .)
    WHILE           reduce using rule 117 (opt_array_mark -> array_mark .)
    DO              reduce using rule 117 (opt_array_mark -> array_mark .)
    BREAK           reduce using rule 117 (opt_array_mark -> array_mark .)
    FOR             reduce using rule 117 (opt_array_mark -> array_mark .)
    IF              reduce using rule 117 (opt_array_mark -> array_mark .)
    PRINTF          reduce using rule 117 (opt_array_mark -> array_mark .)
    SCANF           reduce using rule 117 (opt_array_mark -> array_mark .)
    ID              reduce using rule 117 (opt_array_mark -> array_mark .)
    INCREMENT       reduce using rule 117 (opt_array_mark -> array_mark .)
    DECREMENT       reduce using rule 117 (opt_array_mark -> array_mark .)
    R_BRACE         reduce using rule 117 (opt_array_mark -> array_mark .)
    NEGATION        reduce using rule 117 (opt_array_mark -> array_mark .)
    L_BRACKET       reduce using rule 117 (opt_array_mark -> array_mark .)
    MINUS           reduce using rule 117 (opt_array_mark -> array_mark .)
    INTEGER         reduce using rule 117 (opt_array_mark -> array_mark .)
    DECIMAL         reduce using rule 117 (opt_array_mark -> array_mark .)
    CHARACTER       reduce using rule 117 (opt_array_mark -> array_mark .)
    STRING          reduce using rule 117 (opt_array_mark -> array_mark .)
    TRUE            reduce using rule 117 (opt_array_mark -> array_mark .)
    FALSE           reduce using rule 117 (opt_array_mark -> array_mark .)


state 26

    (118) opt_array_mark -> empty .

    ASSIGN          reduce using rule 118 (opt_array_mark -> empty .)
    COMMENT         reduce using rule 118 (opt_array_mark -> empty .)
    PREPROCESSOR_LINE reduce using rule 118 (opt_array_mark -> empty .)
    CONST           reduce using rule 118 (opt_array_mark -> empty .)
    INT             reduce using rule 118 (opt_array_mark -> empty .)
    FLOAT           reduce using rule 118 (opt_array_mark -> empty .)
    DOUBLE          reduce using rule 118 (opt_array_mark -> empty .)
    CHAR            reduce using rule 118 (opt_array_mark -> empty .)
    BOOL            reduce using rule 118 (opt_array_mark -> empty .)
    LONG            reduce using rule 118 (opt_array_mark -> empty .)
    VOID            reduce using rule 118 (opt_array_mark -> empty .)
    $end            reduce using rule 118 (opt_array_mark -> empty .)
    SEMICOLON       reduce using rule 118 (opt_array_mark -> empty .)
    RETURN          reduce using rule 118 (opt_array_mark -> empty .)
    WHILE           reduce using rule 118 (opt_array_mark -> empty .)
    DO              reduce using rule 118 (opt_array_mark -> empty .)
    BREAK           reduce using rule 118 (opt_array_mark -> empty .)
    FOR             reduce using rule 118 (opt_array_mark -> empty .)
    IF              reduce using rule 118 (opt_array_mark -> empty .)
    PRINTF          reduce using rule 118 (opt_array_mark -> empty .)
    SCANF           reduce using rule 118 (opt_array_mark -> empty .)
    ID              reduce using rule 118 (opt_array_mark -> empty .)
    INCREMENT       reduce using rule 118 (opt_array_mark -> empty .)
    DECREMENT       reduce using rule 118 (opt_array_mark -> empty .)
    R_BRACE         reduce using rule 118 (opt_array_mark -> empty .)
    NEGATION        reduce using rule 118 (opt_array_mark -> empty .)
    L_BRACKET       reduce using rule 118 (opt_array_mark -> empty .)
    MINUS           reduce using rule 118 (opt_array_mark -> empty .)
    INTEGER         reduce using rule 118 (opt_array_mark -> empty .)
    DECIMAL         reduce using rule 118 (opt_array_mark -> empty .)
    CHARACTER       reduce using rule 118 (opt_array_mark -> empty .)
    STRING          reduce using rule 118 (opt_array_mark -> empty .)
    TRUE            reduce using rule 118 (opt_array_mark -> empty .)
    FALSE           reduce using rule 118 (opt_array_mark -> empty .)


state 27

    (114) array_mark -> L_SQUARE_BRACKET . opt_value_expression R_SQUARE_BRACKET
    (58) opt_value_expression -> . value_expression
    (59) opt_value_expression -> . empty
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (125) empty -> .
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression

    L_BRACKET       shift and go to state 40
    R_SQUARE_BRACKET reduce using rule 125 (empty -> .)
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 50

    opt_value_expression           shift and go to state 33
    value_expression               shift and go to state 34
    empty                          shift and go to state 35
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    logical_expression             shift and go to state 49

state 28

    (121) args -> type . ID
    (122) args -> type . ID COMMA args

    ID              shift and go to state 51


state 29

    (33) function_definition_statement -> type ID L_BRACKET opt_args . R_BRACKET statements_block

    R_BRACKET       shift and go to state 52


state 30

    (123) opt_args -> args .

    R_BRACKET       reduce using rule 123 (opt_args -> args .)


state 31

    (124) opt_args -> empty .

    R_BRACKET       reduce using rule 124 (opt_args -> empty .)


state 32

    (28) declaration_statement -> opt_const type ID opt_array_mark ASSIGN . declaration_value_expression SEMICOLON
    (50) declaration_value_expression -> . value_expression
    (51) declaration_value_expression -> . L_BRACE listed_values R_BRACE
    (52) declaration_value_expression -> . L_BRACE declaration_value_expression R_BRACE
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression

    L_BRACE         shift and go to state 55
    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 50

    declaration_value_expression   shift and go to state 53
    value_expression               shift and go to state 54
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    logical_expression             shift and go to state 49

state 33

    (114) array_mark -> L_SQUARE_BRACKET opt_value_expression . R_SQUARE_BRACKET

    R_SQUARE_BRACKET shift and go to state 56


state 34

    (58) opt_value_expression -> value_expression .
    (66) logical_expression -> value_expression . comparison_op value_expression
    (102) comparison_op -> . EQUAL
    (103) comparison_op -> . NOT_EQUAL
    (104) comparison_op -> . GREATER
    (105) comparison_op -> . GREATER_EQUAL
    (106) comparison_op -> . LESSER
    (107) comparison_op -> . LESSER_EQUAL

    R_SQUARE_BRACKET reduce using rule 58 (opt_value_expression -> value_expression .)
    EQUAL           shift and go to state 58
    NOT_EQUAL       shift and go to state 59
    GREATER         shift and go to state 60
    GREATER_EQUAL   shift and go to state 61
    LESSER          shift and go to state 62
    LESSER_EQUAL    shift and go to state 63

    comparison_op                  shift and go to state 57

state 35

    (59) opt_value_expression -> empty .

    R_SQUARE_BRACKET reduce using rule 59 (opt_value_expression -> empty .)


state 36

    (53) value_expression -> math_expression .

    EQUAL           reduce using rule 53 (value_expression -> math_expression .)
    NOT_EQUAL       reduce using rule 53 (value_expression -> math_expression .)
    GREATER         reduce using rule 53 (value_expression -> math_expression .)
    GREATER_EQUAL   reduce using rule 53 (value_expression -> math_expression .)
    LESSER          reduce using rule 53 (value_expression -> math_expression .)
    LESSER_EQUAL    reduce using rule 53 (value_expression -> math_expression .)
    R_SQUARE_BRACKET reduce using rule 53 (value_expression -> math_expression .)
    SEMICOLON       reduce using rule 53 (value_expression -> math_expression .)
    COMMA           reduce using rule 53 (value_expression -> math_expression .)
    R_BRACE         reduce using rule 53 (value_expression -> math_expression .)
    QUESTION_MARK   reduce using rule 53 (value_expression -> math_expression .)
    AND             reduce using rule 53 (value_expression -> math_expression .)
    OR              reduce using rule 53 (value_expression -> math_expression .)
    R_BRACKET       reduce using rule 53 (value_expression -> math_expression .)
    COLON           reduce using rule 53 (value_expression -> math_expression .)


state 37

    (54) value_expression -> function_expression .

    EQUAL           reduce using rule 54 (value_expression -> function_expression .)
    NOT_EQUAL       reduce using rule 54 (value_expression -> function_expression .)
    GREATER         reduce using rule 54 (value_expression -> function_expression .)
    GREATER_EQUAL   reduce using rule 54 (value_expression -> function_expression .)
    LESSER          reduce using rule 54 (value_expression -> function_expression .)
    LESSER_EQUAL    reduce using rule 54 (value_expression -> function_expression .)
    R_SQUARE_BRACKET reduce using rule 54 (value_expression -> function_expression .)
    SEMICOLON       reduce using rule 54 (value_expression -> function_expression .)
    R_BRACKET       reduce using rule 54 (value_expression -> function_expression .)
    COMMA           reduce using rule 54 (value_expression -> function_expression .)
    R_BRACE         reduce using rule 54 (value_expression -> function_expression .)
    QUESTION_MARK   reduce using rule 54 (value_expression -> function_expression .)
    AND             reduce using rule 54 (value_expression -> function_expression .)
    OR              reduce using rule 54 (value_expression -> function_expression .)
    COLON           reduce using rule 54 (value_expression -> function_expression .)


state 38

    (55) value_expression -> value .
    (63) math_expression -> value . math_op value
    (93) math_op -> . PLUS
    (94) math_op -> . MINUS
    (95) math_op -> . MUL
    (96) math_op -> . DIV
    (97) math_op -> . MOD

    EQUAL           reduce using rule 55 (value_expression -> value .)
    NOT_EQUAL       reduce using rule 55 (value_expression -> value .)
    GREATER         reduce using rule 55 (value_expression -> value .)
    GREATER_EQUAL   reduce using rule 55 (value_expression -> value .)
    LESSER          reduce using rule 55 (value_expression -> value .)
    LESSER_EQUAL    reduce using rule 55 (value_expression -> value .)
    R_SQUARE_BRACKET reduce using rule 55 (value_expression -> value .)
    SEMICOLON       reduce using rule 55 (value_expression -> value .)
    R_BRACKET       reduce using rule 55 (value_expression -> value .)
    COMMA           reduce using rule 55 (value_expression -> value .)
    R_BRACE         reduce using rule 55 (value_expression -> value .)
    QUESTION_MARK   reduce using rule 55 (value_expression -> value .)
    AND             reduce using rule 55 (value_expression -> value .)
    OR              reduce using rule 55 (value_expression -> value .)
    COLON           reduce using rule 55 (value_expression -> value .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    MUL             shift and go to state 67
    DIV             shift and go to state 68
    MOD             shift and go to state 69

    math_op                        shift and go to state 64

state 39

    (56) value_expression -> trinary_mark_expression .

    EQUAL           reduce using rule 56 (value_expression -> trinary_mark_expression .)
    NOT_EQUAL       reduce using rule 56 (value_expression -> trinary_mark_expression .)
    GREATER         reduce using rule 56 (value_expression -> trinary_mark_expression .)
    GREATER_EQUAL   reduce using rule 56 (value_expression -> trinary_mark_expression .)
    LESSER          reduce using rule 56 (value_expression -> trinary_mark_expression .)
    LESSER_EQUAL    reduce using rule 56 (value_expression -> trinary_mark_expression .)
    R_SQUARE_BRACKET reduce using rule 56 (value_expression -> trinary_mark_expression .)
    SEMICOLON       reduce using rule 56 (value_expression -> trinary_mark_expression .)
    R_BRACKET       reduce using rule 56 (value_expression -> trinary_mark_expression .)
    COMMA           reduce using rule 56 (value_expression -> trinary_mark_expression .)
    R_BRACE         reduce using rule 56 (value_expression -> trinary_mark_expression .)
    QUESTION_MARK   reduce using rule 56 (value_expression -> trinary_mark_expression .)
    AND             reduce using rule 56 (value_expression -> trinary_mark_expression .)
    OR              reduce using rule 56 (value_expression -> trinary_mark_expression .)
    COLON           reduce using rule 56 (value_expression -> trinary_mark_expression .)


state 40

    (57) value_expression -> L_BRACKET . value_expression R_BRACKET
    (60) math_expression -> L_BRACKET . math_expression R_BRACKET
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 50

    value_expression               shift and go to state 70
    math_expression                shift and go to state 71
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    logical_expression             shift and go to state 49

state 41

    (61) math_expression -> MINUS . math_expression
    (62) math_expression -> MINUS . value
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    L_BRACKET       shift and go to state 74
    MINUS           shift and go to state 41
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    ID              shift and go to state 75

    math_expression                shift and go to state 72
    value                          shift and go to state 73

state 42

    (67) function_expression -> ID . L_BRACKET opt_listed_values R_BRACKET
    (89) value -> ID .
    (90) value -> ID . L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    L_BRACKET       shift and go to state 76
    PLUS            reduce using rule 89 (value -> ID .)
    MINUS           reduce using rule 89 (value -> ID .)
    MUL             reduce using rule 89 (value -> ID .)
    DIV             reduce using rule 89 (value -> ID .)
    MOD             reduce using rule 89 (value -> ID .)
    EQUAL           reduce using rule 89 (value -> ID .)
    NOT_EQUAL       reduce using rule 89 (value -> ID .)
    GREATER         reduce using rule 89 (value -> ID .)
    GREATER_EQUAL   reduce using rule 89 (value -> ID .)
    LESSER          reduce using rule 89 (value -> ID .)
    LESSER_EQUAL    reduce using rule 89 (value -> ID .)
    R_SQUARE_BRACKET reduce using rule 89 (value -> ID .)
    SEMICOLON       reduce using rule 89 (value -> ID .)
    R_BRACKET       reduce using rule 89 (value -> ID .)
    COMMA           reduce using rule 89 (value -> ID .)
    R_BRACE         reduce using rule 89 (value -> ID .)
    QUESTION_MARK   reduce using rule 89 (value -> ID .)
    AND             reduce using rule 89 (value -> ID .)
    OR              reduce using rule 89 (value -> ID .)
    COLON           reduce using rule 89 (value -> ID .)
    L_SQUARE_BRACKET shift and go to state 77


state 43

    (83) value -> INTEGER .

    PLUS            reduce using rule 83 (value -> INTEGER .)
    MINUS           reduce using rule 83 (value -> INTEGER .)
    MUL             reduce using rule 83 (value -> INTEGER .)
    DIV             reduce using rule 83 (value -> INTEGER .)
    MOD             reduce using rule 83 (value -> INTEGER .)
    EQUAL           reduce using rule 83 (value -> INTEGER .)
    NOT_EQUAL       reduce using rule 83 (value -> INTEGER .)
    GREATER         reduce using rule 83 (value -> INTEGER .)
    GREATER_EQUAL   reduce using rule 83 (value -> INTEGER .)
    LESSER          reduce using rule 83 (value -> INTEGER .)
    LESSER_EQUAL    reduce using rule 83 (value -> INTEGER .)
    R_SQUARE_BRACKET reduce using rule 83 (value -> INTEGER .)
    SEMICOLON       reduce using rule 83 (value -> INTEGER .)
    R_BRACKET       reduce using rule 83 (value -> INTEGER .)
    COMMA           reduce using rule 83 (value -> INTEGER .)
    R_BRACE         reduce using rule 83 (value -> INTEGER .)
    QUESTION_MARK   reduce using rule 83 (value -> INTEGER .)
    AND             reduce using rule 83 (value -> INTEGER .)
    OR              reduce using rule 83 (value -> INTEGER .)
    COLON           reduce using rule 83 (value -> INTEGER .)


state 44

    (84) value -> DECIMAL .

    PLUS            reduce using rule 84 (value -> DECIMAL .)
    MINUS           reduce using rule 84 (value -> DECIMAL .)
    MUL             reduce using rule 84 (value -> DECIMAL .)
    DIV             reduce using rule 84 (value -> DECIMAL .)
    MOD             reduce using rule 84 (value -> DECIMAL .)
    EQUAL           reduce using rule 84 (value -> DECIMAL .)
    NOT_EQUAL       reduce using rule 84 (value -> DECIMAL .)
    GREATER         reduce using rule 84 (value -> DECIMAL .)
    GREATER_EQUAL   reduce using rule 84 (value -> DECIMAL .)
    LESSER          reduce using rule 84 (value -> DECIMAL .)
    LESSER_EQUAL    reduce using rule 84 (value -> DECIMAL .)
    R_SQUARE_BRACKET reduce using rule 84 (value -> DECIMAL .)
    SEMICOLON       reduce using rule 84 (value -> DECIMAL .)
    R_BRACKET       reduce using rule 84 (value -> DECIMAL .)
    COMMA           reduce using rule 84 (value -> DECIMAL .)
    R_BRACE         reduce using rule 84 (value -> DECIMAL .)
    QUESTION_MARK   reduce using rule 84 (value -> DECIMAL .)
    AND             reduce using rule 84 (value -> DECIMAL .)
    OR              reduce using rule 84 (value -> DECIMAL .)
    COLON           reduce using rule 84 (value -> DECIMAL .)


state 45

    (85) value -> CHARACTER .

    PLUS            reduce using rule 85 (value -> CHARACTER .)
    MINUS           reduce using rule 85 (value -> CHARACTER .)
    MUL             reduce using rule 85 (value -> CHARACTER .)
    DIV             reduce using rule 85 (value -> CHARACTER .)
    MOD             reduce using rule 85 (value -> CHARACTER .)
    EQUAL           reduce using rule 85 (value -> CHARACTER .)
    NOT_EQUAL       reduce using rule 85 (value -> CHARACTER .)
    GREATER         reduce using rule 85 (value -> CHARACTER .)
    GREATER_EQUAL   reduce using rule 85 (value -> CHARACTER .)
    LESSER          reduce using rule 85 (value -> CHARACTER .)
    LESSER_EQUAL    reduce using rule 85 (value -> CHARACTER .)
    R_SQUARE_BRACKET reduce using rule 85 (value -> CHARACTER .)
    SEMICOLON       reduce using rule 85 (value -> CHARACTER .)
    R_BRACKET       reduce using rule 85 (value -> CHARACTER .)
    COMMA           reduce using rule 85 (value -> CHARACTER .)
    R_BRACE         reduce using rule 85 (value -> CHARACTER .)
    QUESTION_MARK   reduce using rule 85 (value -> CHARACTER .)
    AND             reduce using rule 85 (value -> CHARACTER .)
    OR              reduce using rule 85 (value -> CHARACTER .)
    COLON           reduce using rule 85 (value -> CHARACTER .)


state 46

    (86) value -> STRING .

    PLUS            reduce using rule 86 (value -> STRING .)
    MINUS           reduce using rule 86 (value -> STRING .)
    MUL             reduce using rule 86 (value -> STRING .)
    DIV             reduce using rule 86 (value -> STRING .)
    MOD             reduce using rule 86 (value -> STRING .)
    EQUAL           reduce using rule 86 (value -> STRING .)
    NOT_EQUAL       reduce using rule 86 (value -> STRING .)
    GREATER         reduce using rule 86 (value -> STRING .)
    GREATER_EQUAL   reduce using rule 86 (value -> STRING .)
    LESSER          reduce using rule 86 (value -> STRING .)
    LESSER_EQUAL    reduce using rule 86 (value -> STRING .)
    R_SQUARE_BRACKET reduce using rule 86 (value -> STRING .)
    SEMICOLON       reduce using rule 86 (value -> STRING .)
    R_BRACKET       reduce using rule 86 (value -> STRING .)
    COMMA           reduce using rule 86 (value -> STRING .)
    R_BRACE         reduce using rule 86 (value -> STRING .)
    QUESTION_MARK   reduce using rule 86 (value -> STRING .)
    AND             reduce using rule 86 (value -> STRING .)
    OR              reduce using rule 86 (value -> STRING .)
    COLON           reduce using rule 86 (value -> STRING .)


state 47

    (87) value -> TRUE .

    PLUS            reduce using rule 87 (value -> TRUE .)
    MINUS           reduce using rule 87 (value -> TRUE .)
    MUL             reduce using rule 87 (value -> TRUE .)
    DIV             reduce using rule 87 (value -> TRUE .)
    MOD             reduce using rule 87 (value -> TRUE .)
    EQUAL           reduce using rule 87 (value -> TRUE .)
    NOT_EQUAL       reduce using rule 87 (value -> TRUE .)
    GREATER         reduce using rule 87 (value -> TRUE .)
    GREATER_EQUAL   reduce using rule 87 (value -> TRUE .)
    LESSER          reduce using rule 87 (value -> TRUE .)
    LESSER_EQUAL    reduce using rule 87 (value -> TRUE .)
    R_SQUARE_BRACKET reduce using rule 87 (value -> TRUE .)
    SEMICOLON       reduce using rule 87 (value -> TRUE .)
    R_BRACKET       reduce using rule 87 (value -> TRUE .)
    COMMA           reduce using rule 87 (value -> TRUE .)
    R_BRACE         reduce using rule 87 (value -> TRUE .)
    QUESTION_MARK   reduce using rule 87 (value -> TRUE .)
    AND             reduce using rule 87 (value -> TRUE .)
    OR              reduce using rule 87 (value -> TRUE .)
    COLON           reduce using rule 87 (value -> TRUE .)


state 48

    (88) value -> FALSE .

    PLUS            reduce using rule 88 (value -> FALSE .)
    MINUS           reduce using rule 88 (value -> FALSE .)
    MUL             reduce using rule 88 (value -> FALSE .)
    DIV             reduce using rule 88 (value -> FALSE .)
    MOD             reduce using rule 88 (value -> FALSE .)
    EQUAL           reduce using rule 88 (value -> FALSE .)
    NOT_EQUAL       reduce using rule 88 (value -> FALSE .)
    GREATER         reduce using rule 88 (value -> FALSE .)
    GREATER_EQUAL   reduce using rule 88 (value -> FALSE .)
    LESSER          reduce using rule 88 (value -> FALSE .)
    LESSER_EQUAL    reduce using rule 88 (value -> FALSE .)
    R_SQUARE_BRACKET reduce using rule 88 (value -> FALSE .)
    SEMICOLON       reduce using rule 88 (value -> FALSE .)
    R_BRACKET       reduce using rule 88 (value -> FALSE .)
    COMMA           reduce using rule 88 (value -> FALSE .)
    R_BRACE         reduce using rule 88 (value -> FALSE .)
    QUESTION_MARK   reduce using rule 88 (value -> FALSE .)
    AND             reduce using rule 88 (value -> FALSE .)
    OR              reduce using rule 88 (value -> FALSE .)
    COLON           reduce using rule 88 (value -> FALSE .)


state 49

    (68) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (100) bool_op -> . AND
    (101) bool_op -> . OR

    QUESTION_MARK   shift and go to state 78
    AND             shift and go to state 80
    OR              shift and go to state 81

    bool_op                        shift and go to state 79

state 50

    (65) logical_expression -> NEGATION . logical_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    NEGATION        shift and go to state 50
    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48

    logical_expression             shift and go to state 82
    value_expression               shift and go to state 83
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39

state 51

    (121) args -> type ID .
    (122) args -> type ID . COMMA args

    R_BRACKET       reduce using rule 121 (args -> type ID .)
    COMMA           shift and go to state 84


state 52

    (33) function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 86

    statements_block               shift and go to state 85

state 53

    (28) declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression . SEMICOLON

    SEMICOLON       shift and go to state 87


state 54

    (50) declaration_value_expression -> value_expression .
    (66) logical_expression -> value_expression . comparison_op value_expression
    (102) comparison_op -> . EQUAL
    (103) comparison_op -> . NOT_EQUAL
    (104) comparison_op -> . GREATER
    (105) comparison_op -> . GREATER_EQUAL
    (106) comparison_op -> . LESSER
    (107) comparison_op -> . LESSER_EQUAL

    SEMICOLON       reduce using rule 50 (declaration_value_expression -> value_expression .)
    EQUAL           shift and go to state 58
    NOT_EQUAL       shift and go to state 59
    GREATER         shift and go to state 60
    GREATER_EQUAL   shift and go to state 61
    LESSER          shift and go to state 62
    LESSER_EQUAL    shift and go to state 63

    comparison_op                  shift and go to state 57

state 55

    (51) declaration_value_expression -> L_BRACE . listed_values R_BRACE
    (52) declaration_value_expression -> L_BRACE . declaration_value_expression R_BRACE
    (91) listed_values -> . value_expression COMMA value_expression
    (92) listed_values -> . value_expression COMMA listed_values
    (50) declaration_value_expression -> . value_expression
    (51) declaration_value_expression -> . L_BRACE listed_values R_BRACE
    (52) declaration_value_expression -> . L_BRACE declaration_value_expression R_BRACE
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression

    L_BRACE         shift and go to state 55
    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 50

    listed_values                  shift and go to state 88
    declaration_value_expression   shift and go to state 89
    value_expression               shift and go to state 90
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    logical_expression             shift and go to state 49

state 56

    (114) array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .

    ASSIGN          reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    COMMENT         reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    PREPROCESSOR_LINE reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    CONST           reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    INT             reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    FLOAT           reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    DOUBLE          reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    CHAR            reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    BOOL            reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    LONG            reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    VOID            reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    $end            reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    SEMICOLON       reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    RETURN          reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    WHILE           reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    DO              reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    BREAK           reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    FOR             reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    IF              reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    PRINTF          reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    SCANF           reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    ID              reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    INCREMENT       reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    DECREMENT       reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    R_BRACE         reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    NEGATION        reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    L_BRACKET       reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    MINUS           reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    INTEGER         reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    DECIMAL         reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    CHARACTER       reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    STRING          reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    TRUE            reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    FALSE           reduce using rule 114 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)


state 57

    (66) logical_expression -> value_expression comparison_op . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 50

    value_expression               shift and go to state 91
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    logical_expression             shift and go to state 49

state 58

    (102) comparison_op -> EQUAL .

    L_BRACKET       reduce using rule 102 (comparison_op -> EQUAL .)
    MINUS           reduce using rule 102 (comparison_op -> EQUAL .)
    ID              reduce using rule 102 (comparison_op -> EQUAL .)
    INTEGER         reduce using rule 102 (comparison_op -> EQUAL .)
    DECIMAL         reduce using rule 102 (comparison_op -> EQUAL .)
    CHARACTER       reduce using rule 102 (comparison_op -> EQUAL .)
    STRING          reduce using rule 102 (comparison_op -> EQUAL .)
    TRUE            reduce using rule 102 (comparison_op -> EQUAL .)
    FALSE           reduce using rule 102 (comparison_op -> EQUAL .)
    NEGATION        reduce using rule 102 (comparison_op -> EQUAL .)


state 59

    (103) comparison_op -> NOT_EQUAL .

    L_BRACKET       reduce using rule 103 (comparison_op -> NOT_EQUAL .)
    MINUS           reduce using rule 103 (comparison_op -> NOT_EQUAL .)
    ID              reduce using rule 103 (comparison_op -> NOT_EQUAL .)
    INTEGER         reduce using rule 103 (comparison_op -> NOT_EQUAL .)
    DECIMAL         reduce using rule 103 (comparison_op -> NOT_EQUAL .)
    CHARACTER       reduce using rule 103 (comparison_op -> NOT_EQUAL .)
    STRING          reduce using rule 103 (comparison_op -> NOT_EQUAL .)
    TRUE            reduce using rule 103 (comparison_op -> NOT_EQUAL .)
    FALSE           reduce using rule 103 (comparison_op -> NOT_EQUAL .)
    NEGATION        reduce using rule 103 (comparison_op -> NOT_EQUAL .)


state 60

    (104) comparison_op -> GREATER .

    L_BRACKET       reduce using rule 104 (comparison_op -> GREATER .)
    MINUS           reduce using rule 104 (comparison_op -> GREATER .)
    ID              reduce using rule 104 (comparison_op -> GREATER .)
    INTEGER         reduce using rule 104 (comparison_op -> GREATER .)
    DECIMAL         reduce using rule 104 (comparison_op -> GREATER .)
    CHARACTER       reduce using rule 104 (comparison_op -> GREATER .)
    STRING          reduce using rule 104 (comparison_op -> GREATER .)
    TRUE            reduce using rule 104 (comparison_op -> GREATER .)
    FALSE           reduce using rule 104 (comparison_op -> GREATER .)
    NEGATION        reduce using rule 104 (comparison_op -> GREATER .)


state 61

    (105) comparison_op -> GREATER_EQUAL .

    L_BRACKET       reduce using rule 105 (comparison_op -> GREATER_EQUAL .)
    MINUS           reduce using rule 105 (comparison_op -> GREATER_EQUAL .)
    ID              reduce using rule 105 (comparison_op -> GREATER_EQUAL .)
    INTEGER         reduce using rule 105 (comparison_op -> GREATER_EQUAL .)
    DECIMAL         reduce using rule 105 (comparison_op -> GREATER_EQUAL .)
    CHARACTER       reduce using rule 105 (comparison_op -> GREATER_EQUAL .)
    STRING          reduce using rule 105 (comparison_op -> GREATER_EQUAL .)
    TRUE            reduce using rule 105 (comparison_op -> GREATER_EQUAL .)
    FALSE           reduce using rule 105 (comparison_op -> GREATER_EQUAL .)
    NEGATION        reduce using rule 105 (comparison_op -> GREATER_EQUAL .)


state 62

    (106) comparison_op -> LESSER .

    L_BRACKET       reduce using rule 106 (comparison_op -> LESSER .)
    MINUS           reduce using rule 106 (comparison_op -> LESSER .)
    ID              reduce using rule 106 (comparison_op -> LESSER .)
    INTEGER         reduce using rule 106 (comparison_op -> LESSER .)
    DECIMAL         reduce using rule 106 (comparison_op -> LESSER .)
    CHARACTER       reduce using rule 106 (comparison_op -> LESSER .)
    STRING          reduce using rule 106 (comparison_op -> LESSER .)
    TRUE            reduce using rule 106 (comparison_op -> LESSER .)
    FALSE           reduce using rule 106 (comparison_op -> LESSER .)
    NEGATION        reduce using rule 106 (comparison_op -> LESSER .)


state 63

    (107) comparison_op -> LESSER_EQUAL .

    L_BRACKET       reduce using rule 107 (comparison_op -> LESSER_EQUAL .)
    MINUS           reduce using rule 107 (comparison_op -> LESSER_EQUAL .)
    ID              reduce using rule 107 (comparison_op -> LESSER_EQUAL .)
    INTEGER         reduce using rule 107 (comparison_op -> LESSER_EQUAL .)
    DECIMAL         reduce using rule 107 (comparison_op -> LESSER_EQUAL .)
    CHARACTER       reduce using rule 107 (comparison_op -> LESSER_EQUAL .)
    STRING          reduce using rule 107 (comparison_op -> LESSER_EQUAL .)
    TRUE            reduce using rule 107 (comparison_op -> LESSER_EQUAL .)
    FALSE           reduce using rule 107 (comparison_op -> LESSER_EQUAL .)
    NEGATION        reduce using rule 107 (comparison_op -> LESSER_EQUAL .)


state 64

    (63) math_expression -> value math_op . value
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    ID              shift and go to state 75

    value                          shift and go to state 92

state 65

    (93) math_op -> PLUS .

    INTEGER         reduce using rule 93 (math_op -> PLUS .)
    DECIMAL         reduce using rule 93 (math_op -> PLUS .)
    CHARACTER       reduce using rule 93 (math_op -> PLUS .)
    STRING          reduce using rule 93 (math_op -> PLUS .)
    TRUE            reduce using rule 93 (math_op -> PLUS .)
    FALSE           reduce using rule 93 (math_op -> PLUS .)
    ID              reduce using rule 93 (math_op -> PLUS .)


state 66

    (94) math_op -> MINUS .

    INTEGER         reduce using rule 94 (math_op -> MINUS .)
    DECIMAL         reduce using rule 94 (math_op -> MINUS .)
    CHARACTER       reduce using rule 94 (math_op -> MINUS .)
    STRING          reduce using rule 94 (math_op -> MINUS .)
    TRUE            reduce using rule 94 (math_op -> MINUS .)
    FALSE           reduce using rule 94 (math_op -> MINUS .)
    ID              reduce using rule 94 (math_op -> MINUS .)


state 67

    (95) math_op -> MUL .

    INTEGER         reduce using rule 95 (math_op -> MUL .)
    DECIMAL         reduce using rule 95 (math_op -> MUL .)
    CHARACTER       reduce using rule 95 (math_op -> MUL .)
    STRING          reduce using rule 95 (math_op -> MUL .)
    TRUE            reduce using rule 95 (math_op -> MUL .)
    FALSE           reduce using rule 95 (math_op -> MUL .)
    ID              reduce using rule 95 (math_op -> MUL .)


state 68

    (96) math_op -> DIV .

    INTEGER         reduce using rule 96 (math_op -> DIV .)
    DECIMAL         reduce using rule 96 (math_op -> DIV .)
    CHARACTER       reduce using rule 96 (math_op -> DIV .)
    STRING          reduce using rule 96 (math_op -> DIV .)
    TRUE            reduce using rule 96 (math_op -> DIV .)
    FALSE           reduce using rule 96 (math_op -> DIV .)
    ID              reduce using rule 96 (math_op -> DIV .)


state 69

    (97) math_op -> MOD .

    INTEGER         reduce using rule 97 (math_op -> MOD .)
    DECIMAL         reduce using rule 97 (math_op -> MOD .)
    CHARACTER       reduce using rule 97 (math_op -> MOD .)
    STRING          reduce using rule 97 (math_op -> MOD .)
    TRUE            reduce using rule 97 (math_op -> MOD .)
    FALSE           reduce using rule 97 (math_op -> MOD .)
    ID              reduce using rule 97 (math_op -> MOD .)


state 70

    (57) value_expression -> L_BRACKET value_expression . R_BRACKET
    (66) logical_expression -> value_expression . comparison_op value_expression
    (102) comparison_op -> . EQUAL
    (103) comparison_op -> . NOT_EQUAL
    (104) comparison_op -> . GREATER
    (105) comparison_op -> . GREATER_EQUAL
    (106) comparison_op -> . LESSER
    (107) comparison_op -> . LESSER_EQUAL

    R_BRACKET       shift and go to state 93
    EQUAL           shift and go to state 58
    NOT_EQUAL       shift and go to state 59
    GREATER         shift and go to state 60
    GREATER_EQUAL   shift and go to state 61
    LESSER          shift and go to state 62
    LESSER_EQUAL    shift and go to state 63

    comparison_op                  shift and go to state 57

state 71

    (60) math_expression -> L_BRACKET math_expression . R_BRACKET
    (53) value_expression -> math_expression .

  ! shift/reduce conflict for R_BRACKET resolved as shift
    R_BRACKET       shift and go to state 94
    EQUAL           reduce using rule 53 (value_expression -> math_expression .)
    NOT_EQUAL       reduce using rule 53 (value_expression -> math_expression .)
    GREATER         reduce using rule 53 (value_expression -> math_expression .)
    GREATER_EQUAL   reduce using rule 53 (value_expression -> math_expression .)
    LESSER          reduce using rule 53 (value_expression -> math_expression .)
    LESSER_EQUAL    reduce using rule 53 (value_expression -> math_expression .)

  ! R_BRACKET       [ reduce using rule 53 (value_expression -> math_expression .) ]


state 72

    (61) math_expression -> MINUS math_expression .

    EQUAL           reduce using rule 61 (math_expression -> MINUS math_expression .)
    NOT_EQUAL       reduce using rule 61 (math_expression -> MINUS math_expression .)
    GREATER         reduce using rule 61 (math_expression -> MINUS math_expression .)
    GREATER_EQUAL   reduce using rule 61 (math_expression -> MINUS math_expression .)
    LESSER          reduce using rule 61 (math_expression -> MINUS math_expression .)
    LESSER_EQUAL    reduce using rule 61 (math_expression -> MINUS math_expression .)
    R_SQUARE_BRACKET reduce using rule 61 (math_expression -> MINUS math_expression .)
    SEMICOLON       reduce using rule 61 (math_expression -> MINUS math_expression .)
    R_BRACKET       reduce using rule 61 (math_expression -> MINUS math_expression .)
    COMMA           reduce using rule 61 (math_expression -> MINUS math_expression .)
    R_BRACE         reduce using rule 61 (math_expression -> MINUS math_expression .)
    QUESTION_MARK   reduce using rule 61 (math_expression -> MINUS math_expression .)
    AND             reduce using rule 61 (math_expression -> MINUS math_expression .)
    OR              reduce using rule 61 (math_expression -> MINUS math_expression .)
    COLON           reduce using rule 61 (math_expression -> MINUS math_expression .)


state 73

    (62) math_expression -> MINUS value .
    (63) math_expression -> value . math_op value
    (93) math_op -> . PLUS
    (94) math_op -> . MINUS
    (95) math_op -> . MUL
    (96) math_op -> . DIV
    (97) math_op -> . MOD

    EQUAL           reduce using rule 62 (math_expression -> MINUS value .)
    NOT_EQUAL       reduce using rule 62 (math_expression -> MINUS value .)
    GREATER         reduce using rule 62 (math_expression -> MINUS value .)
    GREATER_EQUAL   reduce using rule 62 (math_expression -> MINUS value .)
    LESSER          reduce using rule 62 (math_expression -> MINUS value .)
    LESSER_EQUAL    reduce using rule 62 (math_expression -> MINUS value .)
    R_SQUARE_BRACKET reduce using rule 62 (math_expression -> MINUS value .)
    SEMICOLON       reduce using rule 62 (math_expression -> MINUS value .)
    R_BRACKET       reduce using rule 62 (math_expression -> MINUS value .)
    COMMA           reduce using rule 62 (math_expression -> MINUS value .)
    R_BRACE         reduce using rule 62 (math_expression -> MINUS value .)
    QUESTION_MARK   reduce using rule 62 (math_expression -> MINUS value .)
    AND             reduce using rule 62 (math_expression -> MINUS value .)
    OR              reduce using rule 62 (math_expression -> MINUS value .)
    COLON           reduce using rule 62 (math_expression -> MINUS value .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    MUL             shift and go to state 67
    DIV             shift and go to state 68
    MOD             shift and go to state 69

    math_op                        shift and go to state 64

state 74

    (60) math_expression -> L_BRACKET . math_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    L_BRACKET       shift and go to state 74
    MINUS           shift and go to state 41
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    ID              shift and go to state 75

    math_expression                shift and go to state 95
    value                          shift and go to state 96

state 75

    (89) value -> ID .
    (90) value -> ID . L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

    PLUS            reduce using rule 89 (value -> ID .)
    MINUS           reduce using rule 89 (value -> ID .)
    MUL             reduce using rule 89 (value -> ID .)
    DIV             reduce using rule 89 (value -> ID .)
    MOD             reduce using rule 89 (value -> ID .)
    EQUAL           reduce using rule 89 (value -> ID .)
    NOT_EQUAL       reduce using rule 89 (value -> ID .)
    GREATER         reduce using rule 89 (value -> ID .)
    GREATER_EQUAL   reduce using rule 89 (value -> ID .)
    LESSER          reduce using rule 89 (value -> ID .)
    LESSER_EQUAL    reduce using rule 89 (value -> ID .)
    R_SQUARE_BRACKET reduce using rule 89 (value -> ID .)
    SEMICOLON       reduce using rule 89 (value -> ID .)
    R_BRACKET       reduce using rule 89 (value -> ID .)
    COMMA           reduce using rule 89 (value -> ID .)
    R_BRACE         reduce using rule 89 (value -> ID .)
    QUESTION_MARK   reduce using rule 89 (value -> ID .)
    AND             reduce using rule 89 (value -> ID .)
    OR              reduce using rule 89 (value -> ID .)
    COLON           reduce using rule 89 (value -> ID .)
    L_SQUARE_BRACKET shift and go to state 77


state 76

    (67) function_expression -> ID L_BRACKET . opt_listed_values R_BRACKET
    (119) opt_listed_values -> . listed_values
    (120) opt_listed_values -> . empty
    (91) listed_values -> . value_expression COMMA value_expression
    (92) listed_values -> . value_expression COMMA listed_values
    (125) empty -> .
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression

    R_BRACKET       reduce using rule 125 (empty -> .)
    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 50

    opt_listed_values              shift and go to state 97
    listed_values                  shift and go to state 98
    empty                          shift and go to state 99
    value_expression               shift and go to state 100
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    logical_expression             shift and go to state 49

state 77

    (90) value -> ID L_SQUARE_BRACKET . value_expression R_SQUARE_BRACKET
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 50

    value_expression               shift and go to state 101
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    logical_expression             shift and go to state 49

state 78

    (68) trinary_mark_expression -> logical_expression QUESTION_MARK . value_expression COLON value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 50

    logical_expression             shift and go to state 49
    value_expression               shift and go to state 102
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39

state 79

    (64) logical_expression -> logical_expression bool_op . logical_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    NEGATION        shift and go to state 50
    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48

    logical_expression             shift and go to state 103
    value_expression               shift and go to state 83
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39

state 80

    (100) bool_op -> AND .

    NEGATION        reduce using rule 100 (bool_op -> AND .)
    L_BRACKET       reduce using rule 100 (bool_op -> AND .)
    MINUS           reduce using rule 100 (bool_op -> AND .)
    ID              reduce using rule 100 (bool_op -> AND .)
    INTEGER         reduce using rule 100 (bool_op -> AND .)
    DECIMAL         reduce using rule 100 (bool_op -> AND .)
    CHARACTER       reduce using rule 100 (bool_op -> AND .)
    STRING          reduce using rule 100 (bool_op -> AND .)
    TRUE            reduce using rule 100 (bool_op -> AND .)
    FALSE           reduce using rule 100 (bool_op -> AND .)


state 81

    (101) bool_op -> OR .

    NEGATION        reduce using rule 101 (bool_op -> OR .)
    L_BRACKET       reduce using rule 101 (bool_op -> OR .)
    MINUS           reduce using rule 101 (bool_op -> OR .)
    ID              reduce using rule 101 (bool_op -> OR .)
    INTEGER         reduce using rule 101 (bool_op -> OR .)
    DECIMAL         reduce using rule 101 (bool_op -> OR .)
    CHARACTER       reduce using rule 101 (bool_op -> OR .)
    STRING          reduce using rule 101 (bool_op -> OR .)
    TRUE            reduce using rule 101 (bool_op -> OR .)
    FALSE           reduce using rule 101 (bool_op -> OR .)


state 82

    (65) logical_expression -> NEGATION logical_expression .
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (68) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (100) bool_op -> . AND
    (101) bool_op -> . OR

  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    R_BRACKET       reduce using rule 65 (logical_expression -> NEGATION logical_expression .)
    SEMICOLON       reduce using rule 65 (logical_expression -> NEGATION logical_expression .)
    QUESTION_MARK   shift and go to state 78
    AND             shift and go to state 80
    OR              shift and go to state 81

  ! QUESTION_MARK   [ reduce using rule 65 (logical_expression -> NEGATION logical_expression .) ]
  ! AND             [ reduce using rule 65 (logical_expression -> NEGATION logical_expression .) ]
  ! OR              [ reduce using rule 65 (logical_expression -> NEGATION logical_expression .) ]

    bool_op                        shift and go to state 79

state 83

    (66) logical_expression -> value_expression . comparison_op value_expression
    (102) comparison_op -> . EQUAL
    (103) comparison_op -> . NOT_EQUAL
    (104) comparison_op -> . GREATER
    (105) comparison_op -> . GREATER_EQUAL
    (106) comparison_op -> . LESSER
    (107) comparison_op -> . LESSER_EQUAL

    EQUAL           shift and go to state 58
    NOT_EQUAL       shift and go to state 59
    GREATER         shift and go to state 60
    GREATER_EQUAL   shift and go to state 61
    LESSER          shift and go to state 62
    LESSER_EQUAL    shift and go to state 63

    comparison_op                  shift and go to state 57

state 84

    (122) args -> type ID COMMA . args
    (121) args -> . type ID
    (122) args -> . type ID COMMA args
    (76) type -> . INT
    (77) type -> . FLOAT
    (78) type -> . DOUBLE
    (79) type -> . CHAR
    (80) type -> . BOOL
    (81) type -> . LONG
    (82) type -> . VOID

    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

    type                           shift and go to state 28
    args                           shift and go to state 104

state 85

    (33) function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .

    COMMENT         reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    PREPROCESSOR_LINE reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    CONST           reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    INT             reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    FLOAT           reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    DOUBLE          reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    CHAR            reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    BOOL            reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    LONG            reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    VOID            reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    $end            reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)


state 86

    (15) statements_block -> L_BRACE . opt_statements R_BRACE
    (13) opt_statements -> . statements
    (14) opt_statements -> . empty
    (11) statements -> . statement
    (12) statements -> . statement statements
    (125) empty -> .
    (8) statement -> . any_statement
    (9) statement -> . COMMENT
    (10) statement -> . SEMICOLON
    (16) any_statement -> . declaration_statement
    (17) any_statement -> . assign_statement
    (18) any_statement -> . function_statement
    (19) any_statement -> . return_statement
    (20) any_statement -> . while_loop_statement
    (21) any_statement -> . do_while_loop_statement
    (22) any_statement -> . break_statement
    (23) any_statement -> . for_loop_statement
    (24) any_statement -> . if_statement opt_else_if_statements opt_else_statement
    (25) any_statement -> . print_statement
    (26) any_statement -> . scan_statement
    (27) declaration_statement -> . opt_const type ID opt_array_mark
    (28) declaration_statement -> . opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (29) assign_statement -> . assign_expression SEMICOLON
    (30) function_statement -> . function_expression SEMICOLON
    (31) return_statement -> . RETURN value_expression SEMICOLON
    (34) while_loop_statement -> . WHILE L_BRACKET logical_expression R_BRACKET statements_block
    (35) do_while_loop_statement -> . DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON
    (32) break_statement -> . BREAK SEMICOLON
    (36) for_loop_statement -> . FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block
    (39) if_statement -> . IF L_BRACKET logical_expression R_BRACKET statements_block
    (48) print_statement -> . PRINTF L_BRACKET value_expression R_BRACKET
    (49) scan_statement -> . SCANF L_BRACKET AMPERSAND ID R_BRACKET
    (115) opt_const -> . CONST
    (116) opt_const -> . empty
    (69) assign_expression -> . ID assign_op value_expression
    (70) assign_expression -> . unary_op ID
    (71) assign_expression -> . ID unary_op
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (98) unary_op -> . INCREMENT
    (99) unary_op -> . DECREMENT

    R_BRACE         reduce using rule 125 (empty -> .)
    INT             reduce using rule 125 (empty -> .)
    FLOAT           reduce using rule 125 (empty -> .)
    DOUBLE          reduce using rule 125 (empty -> .)
    CHAR            reduce using rule 125 (empty -> .)
    BOOL            reduce using rule 125 (empty -> .)
    LONG            reduce using rule 125 (empty -> .)
    VOID            reduce using rule 125 (empty -> .)
    COMMENT         shift and go to state 110
    SEMICOLON       shift and go to state 111
    RETURN          shift and go to state 126
    WHILE           shift and go to state 127
    DO              shift and go to state 128
    BREAK           shift and go to state 129
    FOR             shift and go to state 130
    IF              shift and go to state 131
    PRINTF          shift and go to state 132
    SCANF           shift and go to state 133
    CONST           shift and go to state 10
    ID              shift and go to state 123
    INCREMENT       shift and go to state 135
    DECREMENT       shift and go to state 136

    opt_statements                 shift and go to state 105
    statements                     shift and go to state 106
    empty                          shift and go to state 107
    statement                      shift and go to state 108
    any_statement                  shift and go to state 109
    declaration_statement          shift and go to state 112
    assign_statement               shift and go to state 113
    function_statement             shift and go to state 114
    return_statement               shift and go to state 115
    while_loop_statement           shift and go to state 116
    do_while_loop_statement        shift and go to state 117
    break_statement                shift and go to state 118
    for_loop_statement             shift and go to state 119
    if_statement                   shift and go to state 120
    print_statement                shift and go to state 121
    scan_statement                 shift and go to state 122
    opt_const                      shift and go to state 8
    assign_expression              shift and go to state 124
    function_expression            shift and go to state 125
    unary_op                       shift and go to state 134

state 87

    (28) declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .

    COMMENT         reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    PREPROCESSOR_LINE reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    CONST           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    INT             reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    FLOAT           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    DOUBLE          reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    CHAR            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    BOOL            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    LONG            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    VOID            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    $end            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    SEMICOLON       reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    RETURN          reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    WHILE           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    DO              reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    BREAK           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    FOR             reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    IF              reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    PRINTF          reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    SCANF           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    ID              reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    INCREMENT       reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    DECREMENT       reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    R_BRACE         reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    NEGATION        reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    L_BRACKET       reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    MINUS           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    INTEGER         reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    DECIMAL         reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    CHARACTER       reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    STRING          reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    TRUE            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    FALSE           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)


state 88

    (51) declaration_value_expression -> L_BRACE listed_values . R_BRACE

    R_BRACE         shift and go to state 137


state 89

    (52) declaration_value_expression -> L_BRACE declaration_value_expression . R_BRACE

    R_BRACE         shift and go to state 138


state 90

    (91) listed_values -> value_expression . COMMA value_expression
    (92) listed_values -> value_expression . COMMA listed_values
    (50) declaration_value_expression -> value_expression .
    (66) logical_expression -> value_expression . comparison_op value_expression
    (102) comparison_op -> . EQUAL
    (103) comparison_op -> . NOT_EQUAL
    (104) comparison_op -> . GREATER
    (105) comparison_op -> . GREATER_EQUAL
    (106) comparison_op -> . LESSER
    (107) comparison_op -> . LESSER_EQUAL

    COMMA           shift and go to state 139
    R_BRACE         reduce using rule 50 (declaration_value_expression -> value_expression .)
    EQUAL           shift and go to state 58
    NOT_EQUAL       shift and go to state 59
    GREATER         shift and go to state 60
    GREATER_EQUAL   shift and go to state 61
    LESSER          shift and go to state 62
    LESSER_EQUAL    shift and go to state 63

    comparison_op                  shift and go to state 57

state 91

    (66) logical_expression -> value_expression comparison_op value_expression .
    (66) logical_expression -> value_expression . comparison_op value_expression
    (102) comparison_op -> . EQUAL
    (103) comparison_op -> . NOT_EQUAL
    (104) comparison_op -> . GREATER
    (105) comparison_op -> . GREATER_EQUAL
    (106) comparison_op -> . LESSER
    (107) comparison_op -> . LESSER_EQUAL

    QUESTION_MARK   reduce using rule 66 (logical_expression -> value_expression comparison_op value_expression .)
    AND             reduce using rule 66 (logical_expression -> value_expression comparison_op value_expression .)
    OR              reduce using rule 66 (logical_expression -> value_expression comparison_op value_expression .)
    R_BRACKET       reduce using rule 66 (logical_expression -> value_expression comparison_op value_expression .)
    SEMICOLON       reduce using rule 66 (logical_expression -> value_expression comparison_op value_expression .)
    EQUAL           shift and go to state 58
    NOT_EQUAL       shift and go to state 59
    GREATER         shift and go to state 60
    GREATER_EQUAL   shift and go to state 61
    LESSER          shift and go to state 62
    LESSER_EQUAL    shift and go to state 63

    comparison_op                  shift and go to state 57

state 92

    (63) math_expression -> value math_op value .

    EQUAL           reduce using rule 63 (math_expression -> value math_op value .)
    NOT_EQUAL       reduce using rule 63 (math_expression -> value math_op value .)
    GREATER         reduce using rule 63 (math_expression -> value math_op value .)
    GREATER_EQUAL   reduce using rule 63 (math_expression -> value math_op value .)
    LESSER          reduce using rule 63 (math_expression -> value math_op value .)
    LESSER_EQUAL    reduce using rule 63 (math_expression -> value math_op value .)
    R_SQUARE_BRACKET reduce using rule 63 (math_expression -> value math_op value .)
    SEMICOLON       reduce using rule 63 (math_expression -> value math_op value .)
    R_BRACKET       reduce using rule 63 (math_expression -> value math_op value .)
    COMMA           reduce using rule 63 (math_expression -> value math_op value .)
    R_BRACE         reduce using rule 63 (math_expression -> value math_op value .)
    QUESTION_MARK   reduce using rule 63 (math_expression -> value math_op value .)
    AND             reduce using rule 63 (math_expression -> value math_op value .)
    OR              reduce using rule 63 (math_expression -> value math_op value .)
    COLON           reduce using rule 63 (math_expression -> value math_op value .)


state 93

    (57) value_expression -> L_BRACKET value_expression R_BRACKET .

    EQUAL           reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    NOT_EQUAL       reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    GREATER         reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    GREATER_EQUAL   reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    LESSER          reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    LESSER_EQUAL    reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    R_SQUARE_BRACKET reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    SEMICOLON       reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    R_BRACKET       reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    COMMA           reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    R_BRACE         reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    QUESTION_MARK   reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    AND             reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    OR              reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    COLON           reduce using rule 57 (value_expression -> L_BRACKET value_expression R_BRACKET .)


state 94

    (60) math_expression -> L_BRACKET math_expression R_BRACKET .

    EQUAL           reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    NOT_EQUAL       reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    GREATER         reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    GREATER_EQUAL   reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    LESSER          reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    LESSER_EQUAL    reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    R_SQUARE_BRACKET reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    SEMICOLON       reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    R_BRACKET       reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    COMMA           reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    R_BRACE         reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    QUESTION_MARK   reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    AND             reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    OR              reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    COLON           reduce using rule 60 (math_expression -> L_BRACKET math_expression R_BRACKET .)


state 95

    (60) math_expression -> L_BRACKET math_expression . R_BRACKET

    R_BRACKET       shift and go to state 94


state 96

    (63) math_expression -> value . math_op value
    (93) math_op -> . PLUS
    (94) math_op -> . MINUS
    (95) math_op -> . MUL
    (96) math_op -> . DIV
    (97) math_op -> . MOD

    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    MUL             shift and go to state 67
    DIV             shift and go to state 68
    MOD             shift and go to state 69

    math_op                        shift and go to state 64

state 97

    (67) function_expression -> ID L_BRACKET opt_listed_values . R_BRACKET

    R_BRACKET       shift and go to state 140


state 98

    (119) opt_listed_values -> listed_values .

    R_BRACKET       reduce using rule 119 (opt_listed_values -> listed_values .)


state 99

    (120) opt_listed_values -> empty .

    R_BRACKET       reduce using rule 120 (opt_listed_values -> empty .)


state 100

    (91) listed_values -> value_expression . COMMA value_expression
    (92) listed_values -> value_expression . COMMA listed_values
    (66) logical_expression -> value_expression . comparison_op value_expression
    (102) comparison_op -> . EQUAL
    (103) comparison_op -> . NOT_EQUAL
    (104) comparison_op -> . GREATER
    (105) comparison_op -> . GREATER_EQUAL
    (106) comparison_op -> . LESSER
    (107) comparison_op -> . LESSER_EQUAL

    COMMA           shift and go to state 139
    EQUAL           shift and go to state 58
    NOT_EQUAL       shift and go to state 59
    GREATER         shift and go to state 60
    GREATER_EQUAL   shift and go to state 61
    LESSER          shift and go to state 62
    LESSER_EQUAL    shift and go to state 63

    comparison_op                  shift and go to state 57

state 101

    (90) value -> ID L_SQUARE_BRACKET value_expression . R_SQUARE_BRACKET
    (66) logical_expression -> value_expression . comparison_op value_expression
    (102) comparison_op -> . EQUAL
    (103) comparison_op -> . NOT_EQUAL
    (104) comparison_op -> . GREATER
    (105) comparison_op -> . GREATER_EQUAL
    (106) comparison_op -> . LESSER
    (107) comparison_op -> . LESSER_EQUAL

    R_SQUARE_BRACKET shift and go to state 141
    EQUAL           shift and go to state 58
    NOT_EQUAL       shift and go to state 59
    GREATER         shift and go to state 60
    GREATER_EQUAL   shift and go to state 61
    LESSER          shift and go to state 62
    LESSER_EQUAL    shift and go to state 63

    comparison_op                  shift and go to state 57

state 102

    (68) trinary_mark_expression -> logical_expression QUESTION_MARK value_expression . COLON value_expression
    (66) logical_expression -> value_expression . comparison_op value_expression
    (102) comparison_op -> . EQUAL
    (103) comparison_op -> . NOT_EQUAL
    (104) comparison_op -> . GREATER
    (105) comparison_op -> . GREATER_EQUAL
    (106) comparison_op -> . LESSER
    (107) comparison_op -> . LESSER_EQUAL

    COLON           shift and go to state 142
    EQUAL           shift and go to state 58
    NOT_EQUAL       shift and go to state 59
    GREATER         shift and go to state 60
    GREATER_EQUAL   shift and go to state 61
    LESSER          shift and go to state 62
    LESSER_EQUAL    shift and go to state 63

    comparison_op                  shift and go to state 57

state 103

    (64) logical_expression -> logical_expression bool_op logical_expression .
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (68) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (100) bool_op -> . AND
    (101) bool_op -> . OR

  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    R_BRACKET       reduce using rule 64 (logical_expression -> logical_expression bool_op logical_expression .)
    SEMICOLON       reduce using rule 64 (logical_expression -> logical_expression bool_op logical_expression .)
    QUESTION_MARK   shift and go to state 78
    AND             shift and go to state 80
    OR              shift and go to state 81

  ! QUESTION_MARK   [ reduce using rule 64 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! AND             [ reduce using rule 64 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! OR              [ reduce using rule 64 (logical_expression -> logical_expression bool_op logical_expression .) ]

    bool_op                        shift and go to state 79

state 104

    (122) args -> type ID COMMA args .

    R_BRACKET       reduce using rule 122 (args -> type ID COMMA args .)


state 105

    (15) statements_block -> L_BRACE opt_statements . R_BRACE

    R_BRACE         shift and go to state 143


state 106

    (13) opt_statements -> statements .

    R_BRACE         reduce using rule 13 (opt_statements -> statements .)


state 107

    (14) opt_statements -> empty .
    (116) opt_const -> empty .

    R_BRACE         reduce using rule 14 (opt_statements -> empty .)
    INT             reduce using rule 116 (opt_const -> empty .)
    FLOAT           reduce using rule 116 (opt_const -> empty .)
    DOUBLE          reduce using rule 116 (opt_const -> empty .)
    CHAR            reduce using rule 116 (opt_const -> empty .)
    BOOL            reduce using rule 116 (opt_const -> empty .)
    LONG            reduce using rule 116 (opt_const -> empty .)
    VOID            reduce using rule 116 (opt_const -> empty .)


state 108

    (11) statements -> statement .
    (12) statements -> statement . statements
    (11) statements -> . statement
    (12) statements -> . statement statements
    (8) statement -> . any_statement
    (9) statement -> . COMMENT
    (10) statement -> . SEMICOLON
    (16) any_statement -> . declaration_statement
    (17) any_statement -> . assign_statement
    (18) any_statement -> . function_statement
    (19) any_statement -> . return_statement
    (20) any_statement -> . while_loop_statement
    (21) any_statement -> . do_while_loop_statement
    (22) any_statement -> . break_statement
    (23) any_statement -> . for_loop_statement
    (24) any_statement -> . if_statement opt_else_if_statements opt_else_statement
    (25) any_statement -> . print_statement
    (26) any_statement -> . scan_statement
    (27) declaration_statement -> . opt_const type ID opt_array_mark
    (28) declaration_statement -> . opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (29) assign_statement -> . assign_expression SEMICOLON
    (30) function_statement -> . function_expression SEMICOLON
    (31) return_statement -> . RETURN value_expression SEMICOLON
    (34) while_loop_statement -> . WHILE L_BRACKET logical_expression R_BRACKET statements_block
    (35) do_while_loop_statement -> . DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON
    (32) break_statement -> . BREAK SEMICOLON
    (36) for_loop_statement -> . FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block
    (39) if_statement -> . IF L_BRACKET logical_expression R_BRACKET statements_block
    (48) print_statement -> . PRINTF L_BRACKET value_expression R_BRACKET
    (49) scan_statement -> . SCANF L_BRACKET AMPERSAND ID R_BRACKET
    (115) opt_const -> . CONST
    (116) opt_const -> . empty
    (69) assign_expression -> . ID assign_op value_expression
    (70) assign_expression -> . unary_op ID
    (71) assign_expression -> . ID unary_op
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (125) empty -> .
    (98) unary_op -> . INCREMENT
    (99) unary_op -> . DECREMENT

    R_BRACE         reduce using rule 11 (statements -> statement .)
    COMMENT         shift and go to state 110
    SEMICOLON       shift and go to state 111
    RETURN          shift and go to state 126
    WHILE           shift and go to state 127
    DO              shift and go to state 128
    BREAK           shift and go to state 129
    FOR             shift and go to state 130
    IF              shift and go to state 131
    PRINTF          shift and go to state 132
    SCANF           shift and go to state 133
    CONST           shift and go to state 10
    ID              shift and go to state 123
    INT             reduce using rule 125 (empty -> .)
    FLOAT           reduce using rule 125 (empty -> .)
    DOUBLE          reduce using rule 125 (empty -> .)
    CHAR            reduce using rule 125 (empty -> .)
    BOOL            reduce using rule 125 (empty -> .)
    LONG            reduce using rule 125 (empty -> .)
    VOID            reduce using rule 125 (empty -> .)
    INCREMENT       shift and go to state 135
    DECREMENT       shift and go to state 136

    statement                      shift and go to state 108
    statements                     shift and go to state 144
    any_statement                  shift and go to state 109
    declaration_statement          shift and go to state 112
    assign_statement               shift and go to state 113
    function_statement             shift and go to state 114
    return_statement               shift and go to state 115
    while_loop_statement           shift and go to state 116
    do_while_loop_statement        shift and go to state 117
    break_statement                shift and go to state 118
    for_loop_statement             shift and go to state 119
    if_statement                   shift and go to state 120
    print_statement                shift and go to state 121
    scan_statement                 shift and go to state 122
    opt_const                      shift and go to state 8
    assign_expression              shift and go to state 124
    function_expression            shift and go to state 125
    empty                          shift and go to state 11
    unary_op                       shift and go to state 134

state 109

    (8) statement -> any_statement .

    COMMENT         reduce using rule 8 (statement -> any_statement .)
    SEMICOLON       reduce using rule 8 (statement -> any_statement .)
    RETURN          reduce using rule 8 (statement -> any_statement .)
    WHILE           reduce using rule 8 (statement -> any_statement .)
    DO              reduce using rule 8 (statement -> any_statement .)
    BREAK           reduce using rule 8 (statement -> any_statement .)
    FOR             reduce using rule 8 (statement -> any_statement .)
    IF              reduce using rule 8 (statement -> any_statement .)
    PRINTF          reduce using rule 8 (statement -> any_statement .)
    SCANF           reduce using rule 8 (statement -> any_statement .)
    CONST           reduce using rule 8 (statement -> any_statement .)
    ID              reduce using rule 8 (statement -> any_statement .)
    INCREMENT       reduce using rule 8 (statement -> any_statement .)
    DECREMENT       reduce using rule 8 (statement -> any_statement .)
    INT             reduce using rule 8 (statement -> any_statement .)
    FLOAT           reduce using rule 8 (statement -> any_statement .)
    DOUBLE          reduce using rule 8 (statement -> any_statement .)
    CHAR            reduce using rule 8 (statement -> any_statement .)
    BOOL            reduce using rule 8 (statement -> any_statement .)
    LONG            reduce using rule 8 (statement -> any_statement .)
    VOID            reduce using rule 8 (statement -> any_statement .)
    R_BRACE         reduce using rule 8 (statement -> any_statement .)


state 110

    (9) statement -> COMMENT .

    COMMENT         reduce using rule 9 (statement -> COMMENT .)
    SEMICOLON       reduce using rule 9 (statement -> COMMENT .)
    RETURN          reduce using rule 9 (statement -> COMMENT .)
    WHILE           reduce using rule 9 (statement -> COMMENT .)
    DO              reduce using rule 9 (statement -> COMMENT .)
    BREAK           reduce using rule 9 (statement -> COMMENT .)
    FOR             reduce using rule 9 (statement -> COMMENT .)
    IF              reduce using rule 9 (statement -> COMMENT .)
    PRINTF          reduce using rule 9 (statement -> COMMENT .)
    SCANF           reduce using rule 9 (statement -> COMMENT .)
    CONST           reduce using rule 9 (statement -> COMMENT .)
    ID              reduce using rule 9 (statement -> COMMENT .)
    INCREMENT       reduce using rule 9 (statement -> COMMENT .)
    DECREMENT       reduce using rule 9 (statement -> COMMENT .)
    INT             reduce using rule 9 (statement -> COMMENT .)
    FLOAT           reduce using rule 9 (statement -> COMMENT .)
    DOUBLE          reduce using rule 9 (statement -> COMMENT .)
    CHAR            reduce using rule 9 (statement -> COMMENT .)
    BOOL            reduce using rule 9 (statement -> COMMENT .)
    LONG            reduce using rule 9 (statement -> COMMENT .)
    VOID            reduce using rule 9 (statement -> COMMENT .)
    R_BRACE         reduce using rule 9 (statement -> COMMENT .)


state 111

    (10) statement -> SEMICOLON .

    COMMENT         reduce using rule 10 (statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 10 (statement -> SEMICOLON .)
    RETURN          reduce using rule 10 (statement -> SEMICOLON .)
    WHILE           reduce using rule 10 (statement -> SEMICOLON .)
    DO              reduce using rule 10 (statement -> SEMICOLON .)
    BREAK           reduce using rule 10 (statement -> SEMICOLON .)
    FOR             reduce using rule 10 (statement -> SEMICOLON .)
    IF              reduce using rule 10 (statement -> SEMICOLON .)
    PRINTF          reduce using rule 10 (statement -> SEMICOLON .)
    SCANF           reduce using rule 10 (statement -> SEMICOLON .)
    CONST           reduce using rule 10 (statement -> SEMICOLON .)
    ID              reduce using rule 10 (statement -> SEMICOLON .)
    INCREMENT       reduce using rule 10 (statement -> SEMICOLON .)
    DECREMENT       reduce using rule 10 (statement -> SEMICOLON .)
    INT             reduce using rule 10 (statement -> SEMICOLON .)
    FLOAT           reduce using rule 10 (statement -> SEMICOLON .)
    DOUBLE          reduce using rule 10 (statement -> SEMICOLON .)
    CHAR            reduce using rule 10 (statement -> SEMICOLON .)
    BOOL            reduce using rule 10 (statement -> SEMICOLON .)
    LONG            reduce using rule 10 (statement -> SEMICOLON .)
    VOID            reduce using rule 10 (statement -> SEMICOLON .)
    R_BRACE         reduce using rule 10 (statement -> SEMICOLON .)


state 112

    (16) any_statement -> declaration_statement .

    COMMENT         reduce using rule 16 (any_statement -> declaration_statement .)
    SEMICOLON       reduce using rule 16 (any_statement -> declaration_statement .)
    RETURN          reduce using rule 16 (any_statement -> declaration_statement .)
    WHILE           reduce using rule 16 (any_statement -> declaration_statement .)
    DO              reduce using rule 16 (any_statement -> declaration_statement .)
    BREAK           reduce using rule 16 (any_statement -> declaration_statement .)
    FOR             reduce using rule 16 (any_statement -> declaration_statement .)
    IF              reduce using rule 16 (any_statement -> declaration_statement .)
    PRINTF          reduce using rule 16 (any_statement -> declaration_statement .)
    SCANF           reduce using rule 16 (any_statement -> declaration_statement .)
    CONST           reduce using rule 16 (any_statement -> declaration_statement .)
    ID              reduce using rule 16 (any_statement -> declaration_statement .)
    INCREMENT       reduce using rule 16 (any_statement -> declaration_statement .)
    DECREMENT       reduce using rule 16 (any_statement -> declaration_statement .)
    INT             reduce using rule 16 (any_statement -> declaration_statement .)
    FLOAT           reduce using rule 16 (any_statement -> declaration_statement .)
    DOUBLE          reduce using rule 16 (any_statement -> declaration_statement .)
    CHAR            reduce using rule 16 (any_statement -> declaration_statement .)
    BOOL            reduce using rule 16 (any_statement -> declaration_statement .)
    LONG            reduce using rule 16 (any_statement -> declaration_statement .)
    VOID            reduce using rule 16 (any_statement -> declaration_statement .)
    R_BRACE         reduce using rule 16 (any_statement -> declaration_statement .)


state 113

    (17) any_statement -> assign_statement .

    COMMENT         reduce using rule 17 (any_statement -> assign_statement .)
    SEMICOLON       reduce using rule 17 (any_statement -> assign_statement .)
    RETURN          reduce using rule 17 (any_statement -> assign_statement .)
    WHILE           reduce using rule 17 (any_statement -> assign_statement .)
    DO              reduce using rule 17 (any_statement -> assign_statement .)
    BREAK           reduce using rule 17 (any_statement -> assign_statement .)
    FOR             reduce using rule 17 (any_statement -> assign_statement .)
    IF              reduce using rule 17 (any_statement -> assign_statement .)
    PRINTF          reduce using rule 17 (any_statement -> assign_statement .)
    SCANF           reduce using rule 17 (any_statement -> assign_statement .)
    CONST           reduce using rule 17 (any_statement -> assign_statement .)
    ID              reduce using rule 17 (any_statement -> assign_statement .)
    INCREMENT       reduce using rule 17 (any_statement -> assign_statement .)
    DECREMENT       reduce using rule 17 (any_statement -> assign_statement .)
    INT             reduce using rule 17 (any_statement -> assign_statement .)
    FLOAT           reduce using rule 17 (any_statement -> assign_statement .)
    DOUBLE          reduce using rule 17 (any_statement -> assign_statement .)
    CHAR            reduce using rule 17 (any_statement -> assign_statement .)
    BOOL            reduce using rule 17 (any_statement -> assign_statement .)
    LONG            reduce using rule 17 (any_statement -> assign_statement .)
    VOID            reduce using rule 17 (any_statement -> assign_statement .)
    R_BRACE         reduce using rule 17 (any_statement -> assign_statement .)


state 114

    (18) any_statement -> function_statement .

    COMMENT         reduce using rule 18 (any_statement -> function_statement .)
    SEMICOLON       reduce using rule 18 (any_statement -> function_statement .)
    RETURN          reduce using rule 18 (any_statement -> function_statement .)
    WHILE           reduce using rule 18 (any_statement -> function_statement .)
    DO              reduce using rule 18 (any_statement -> function_statement .)
    BREAK           reduce using rule 18 (any_statement -> function_statement .)
    FOR             reduce using rule 18 (any_statement -> function_statement .)
    IF              reduce using rule 18 (any_statement -> function_statement .)
    PRINTF          reduce using rule 18 (any_statement -> function_statement .)
    SCANF           reduce using rule 18 (any_statement -> function_statement .)
    CONST           reduce using rule 18 (any_statement -> function_statement .)
    ID              reduce using rule 18 (any_statement -> function_statement .)
    INCREMENT       reduce using rule 18 (any_statement -> function_statement .)
    DECREMENT       reduce using rule 18 (any_statement -> function_statement .)
    INT             reduce using rule 18 (any_statement -> function_statement .)
    FLOAT           reduce using rule 18 (any_statement -> function_statement .)
    DOUBLE          reduce using rule 18 (any_statement -> function_statement .)
    CHAR            reduce using rule 18 (any_statement -> function_statement .)
    BOOL            reduce using rule 18 (any_statement -> function_statement .)
    LONG            reduce using rule 18 (any_statement -> function_statement .)
    VOID            reduce using rule 18 (any_statement -> function_statement .)
    R_BRACE         reduce using rule 18 (any_statement -> function_statement .)


state 115

    (19) any_statement -> return_statement .

    COMMENT         reduce using rule 19 (any_statement -> return_statement .)
    SEMICOLON       reduce using rule 19 (any_statement -> return_statement .)
    RETURN          reduce using rule 19 (any_statement -> return_statement .)
    WHILE           reduce using rule 19 (any_statement -> return_statement .)
    DO              reduce using rule 19 (any_statement -> return_statement .)
    BREAK           reduce using rule 19 (any_statement -> return_statement .)
    FOR             reduce using rule 19 (any_statement -> return_statement .)
    IF              reduce using rule 19 (any_statement -> return_statement .)
    PRINTF          reduce using rule 19 (any_statement -> return_statement .)
    SCANF           reduce using rule 19 (any_statement -> return_statement .)
    CONST           reduce using rule 19 (any_statement -> return_statement .)
    ID              reduce using rule 19 (any_statement -> return_statement .)
    INCREMENT       reduce using rule 19 (any_statement -> return_statement .)
    DECREMENT       reduce using rule 19 (any_statement -> return_statement .)
    INT             reduce using rule 19 (any_statement -> return_statement .)
    FLOAT           reduce using rule 19 (any_statement -> return_statement .)
    DOUBLE          reduce using rule 19 (any_statement -> return_statement .)
    CHAR            reduce using rule 19 (any_statement -> return_statement .)
    BOOL            reduce using rule 19 (any_statement -> return_statement .)
    LONG            reduce using rule 19 (any_statement -> return_statement .)
    VOID            reduce using rule 19 (any_statement -> return_statement .)
    R_BRACE         reduce using rule 19 (any_statement -> return_statement .)


state 116

    (20) any_statement -> while_loop_statement .

    COMMENT         reduce using rule 20 (any_statement -> while_loop_statement .)
    SEMICOLON       reduce using rule 20 (any_statement -> while_loop_statement .)
    RETURN          reduce using rule 20 (any_statement -> while_loop_statement .)
    WHILE           reduce using rule 20 (any_statement -> while_loop_statement .)
    DO              reduce using rule 20 (any_statement -> while_loop_statement .)
    BREAK           reduce using rule 20 (any_statement -> while_loop_statement .)
    FOR             reduce using rule 20 (any_statement -> while_loop_statement .)
    IF              reduce using rule 20 (any_statement -> while_loop_statement .)
    PRINTF          reduce using rule 20 (any_statement -> while_loop_statement .)
    SCANF           reduce using rule 20 (any_statement -> while_loop_statement .)
    CONST           reduce using rule 20 (any_statement -> while_loop_statement .)
    ID              reduce using rule 20 (any_statement -> while_loop_statement .)
    INCREMENT       reduce using rule 20 (any_statement -> while_loop_statement .)
    DECREMENT       reduce using rule 20 (any_statement -> while_loop_statement .)
    INT             reduce using rule 20 (any_statement -> while_loop_statement .)
    FLOAT           reduce using rule 20 (any_statement -> while_loop_statement .)
    DOUBLE          reduce using rule 20 (any_statement -> while_loop_statement .)
    CHAR            reduce using rule 20 (any_statement -> while_loop_statement .)
    BOOL            reduce using rule 20 (any_statement -> while_loop_statement .)
    LONG            reduce using rule 20 (any_statement -> while_loop_statement .)
    VOID            reduce using rule 20 (any_statement -> while_loop_statement .)
    R_BRACE         reduce using rule 20 (any_statement -> while_loop_statement .)


state 117

    (21) any_statement -> do_while_loop_statement .

    COMMENT         reduce using rule 21 (any_statement -> do_while_loop_statement .)
    SEMICOLON       reduce using rule 21 (any_statement -> do_while_loop_statement .)
    RETURN          reduce using rule 21 (any_statement -> do_while_loop_statement .)
    WHILE           reduce using rule 21 (any_statement -> do_while_loop_statement .)
    DO              reduce using rule 21 (any_statement -> do_while_loop_statement .)
    BREAK           reduce using rule 21 (any_statement -> do_while_loop_statement .)
    FOR             reduce using rule 21 (any_statement -> do_while_loop_statement .)
    IF              reduce using rule 21 (any_statement -> do_while_loop_statement .)
    PRINTF          reduce using rule 21 (any_statement -> do_while_loop_statement .)
    SCANF           reduce using rule 21 (any_statement -> do_while_loop_statement .)
    CONST           reduce using rule 21 (any_statement -> do_while_loop_statement .)
    ID              reduce using rule 21 (any_statement -> do_while_loop_statement .)
    INCREMENT       reduce using rule 21 (any_statement -> do_while_loop_statement .)
    DECREMENT       reduce using rule 21 (any_statement -> do_while_loop_statement .)
    INT             reduce using rule 21 (any_statement -> do_while_loop_statement .)
    FLOAT           reduce using rule 21 (any_statement -> do_while_loop_statement .)
    DOUBLE          reduce using rule 21 (any_statement -> do_while_loop_statement .)
    CHAR            reduce using rule 21 (any_statement -> do_while_loop_statement .)
    BOOL            reduce using rule 21 (any_statement -> do_while_loop_statement .)
    LONG            reduce using rule 21 (any_statement -> do_while_loop_statement .)
    VOID            reduce using rule 21 (any_statement -> do_while_loop_statement .)
    R_BRACE         reduce using rule 21 (any_statement -> do_while_loop_statement .)


state 118

    (22) any_statement -> break_statement .

    COMMENT         reduce using rule 22 (any_statement -> break_statement .)
    SEMICOLON       reduce using rule 22 (any_statement -> break_statement .)
    RETURN          reduce using rule 22 (any_statement -> break_statement .)
    WHILE           reduce using rule 22 (any_statement -> break_statement .)
    DO              reduce using rule 22 (any_statement -> break_statement .)
    BREAK           reduce using rule 22 (any_statement -> break_statement .)
    FOR             reduce using rule 22 (any_statement -> break_statement .)
    IF              reduce using rule 22 (any_statement -> break_statement .)
    PRINTF          reduce using rule 22 (any_statement -> break_statement .)
    SCANF           reduce using rule 22 (any_statement -> break_statement .)
    CONST           reduce using rule 22 (any_statement -> break_statement .)
    ID              reduce using rule 22 (any_statement -> break_statement .)
    INCREMENT       reduce using rule 22 (any_statement -> break_statement .)
    DECREMENT       reduce using rule 22 (any_statement -> break_statement .)
    INT             reduce using rule 22 (any_statement -> break_statement .)
    FLOAT           reduce using rule 22 (any_statement -> break_statement .)
    DOUBLE          reduce using rule 22 (any_statement -> break_statement .)
    CHAR            reduce using rule 22 (any_statement -> break_statement .)
    BOOL            reduce using rule 22 (any_statement -> break_statement .)
    LONG            reduce using rule 22 (any_statement -> break_statement .)
    VOID            reduce using rule 22 (any_statement -> break_statement .)
    R_BRACE         reduce using rule 22 (any_statement -> break_statement .)


state 119

    (23) any_statement -> for_loop_statement .

    COMMENT         reduce using rule 23 (any_statement -> for_loop_statement .)
    SEMICOLON       reduce using rule 23 (any_statement -> for_loop_statement .)
    RETURN          reduce using rule 23 (any_statement -> for_loop_statement .)
    WHILE           reduce using rule 23 (any_statement -> for_loop_statement .)
    DO              reduce using rule 23 (any_statement -> for_loop_statement .)
    BREAK           reduce using rule 23 (any_statement -> for_loop_statement .)
    FOR             reduce using rule 23 (any_statement -> for_loop_statement .)
    IF              reduce using rule 23 (any_statement -> for_loop_statement .)
    PRINTF          reduce using rule 23 (any_statement -> for_loop_statement .)
    SCANF           reduce using rule 23 (any_statement -> for_loop_statement .)
    CONST           reduce using rule 23 (any_statement -> for_loop_statement .)
    ID              reduce using rule 23 (any_statement -> for_loop_statement .)
    INCREMENT       reduce using rule 23 (any_statement -> for_loop_statement .)
    DECREMENT       reduce using rule 23 (any_statement -> for_loop_statement .)
    INT             reduce using rule 23 (any_statement -> for_loop_statement .)
    FLOAT           reduce using rule 23 (any_statement -> for_loop_statement .)
    DOUBLE          reduce using rule 23 (any_statement -> for_loop_statement .)
    CHAR            reduce using rule 23 (any_statement -> for_loop_statement .)
    BOOL            reduce using rule 23 (any_statement -> for_loop_statement .)
    LONG            reduce using rule 23 (any_statement -> for_loop_statement .)
    VOID            reduce using rule 23 (any_statement -> for_loop_statement .)
    R_BRACE         reduce using rule 23 (any_statement -> for_loop_statement .)


state 120

    (24) any_statement -> if_statement . opt_else_if_statements opt_else_statement
    (46) opt_else_if_statements -> . else_if_statements
    (47) opt_else_if_statements -> . empty
    (42) else_if_statements -> . else_if_statement
    (43) else_if_statements -> . else_if_statement else_if_statements
    (125) empty -> .
    (41) else_if_statement -> . ELSE IF L_BRACKET logical_expression R_BRACKET statements_block

  ! shift/reduce conflict for ELSE resolved as shift
    COMMENT         reduce using rule 125 (empty -> .)
    SEMICOLON       reduce using rule 125 (empty -> .)
    RETURN          reduce using rule 125 (empty -> .)
    WHILE           reduce using rule 125 (empty -> .)
    DO              reduce using rule 125 (empty -> .)
    BREAK           reduce using rule 125 (empty -> .)
    FOR             reduce using rule 125 (empty -> .)
    IF              reduce using rule 125 (empty -> .)
    PRINTF          reduce using rule 125 (empty -> .)
    SCANF           reduce using rule 125 (empty -> .)
    CONST           reduce using rule 125 (empty -> .)
    ID              reduce using rule 125 (empty -> .)
    INCREMENT       reduce using rule 125 (empty -> .)
    DECREMENT       reduce using rule 125 (empty -> .)
    INT             reduce using rule 125 (empty -> .)
    FLOAT           reduce using rule 125 (empty -> .)
    DOUBLE          reduce using rule 125 (empty -> .)
    CHAR            reduce using rule 125 (empty -> .)
    BOOL            reduce using rule 125 (empty -> .)
    LONG            reduce using rule 125 (empty -> .)
    VOID            reduce using rule 125 (empty -> .)
    R_BRACE         reduce using rule 125 (empty -> .)
    ELSE            shift and go to state 149

  ! ELSE            [ reduce using rule 125 (empty -> .) ]

    opt_else_if_statements         shift and go to state 145
    else_if_statements             shift and go to state 146
    empty                          shift and go to state 147
    else_if_statement              shift and go to state 148

state 121

    (25) any_statement -> print_statement .

    COMMENT         reduce using rule 25 (any_statement -> print_statement .)
    SEMICOLON       reduce using rule 25 (any_statement -> print_statement .)
    RETURN          reduce using rule 25 (any_statement -> print_statement .)
    WHILE           reduce using rule 25 (any_statement -> print_statement .)
    DO              reduce using rule 25 (any_statement -> print_statement .)
    BREAK           reduce using rule 25 (any_statement -> print_statement .)
    FOR             reduce using rule 25 (any_statement -> print_statement .)
    IF              reduce using rule 25 (any_statement -> print_statement .)
    PRINTF          reduce using rule 25 (any_statement -> print_statement .)
    SCANF           reduce using rule 25 (any_statement -> print_statement .)
    CONST           reduce using rule 25 (any_statement -> print_statement .)
    ID              reduce using rule 25 (any_statement -> print_statement .)
    INCREMENT       reduce using rule 25 (any_statement -> print_statement .)
    DECREMENT       reduce using rule 25 (any_statement -> print_statement .)
    INT             reduce using rule 25 (any_statement -> print_statement .)
    FLOAT           reduce using rule 25 (any_statement -> print_statement .)
    DOUBLE          reduce using rule 25 (any_statement -> print_statement .)
    CHAR            reduce using rule 25 (any_statement -> print_statement .)
    BOOL            reduce using rule 25 (any_statement -> print_statement .)
    LONG            reduce using rule 25 (any_statement -> print_statement .)
    VOID            reduce using rule 25 (any_statement -> print_statement .)
    R_BRACE         reduce using rule 25 (any_statement -> print_statement .)


state 122

    (26) any_statement -> scan_statement .

    COMMENT         reduce using rule 26 (any_statement -> scan_statement .)
    SEMICOLON       reduce using rule 26 (any_statement -> scan_statement .)
    RETURN          reduce using rule 26 (any_statement -> scan_statement .)
    WHILE           reduce using rule 26 (any_statement -> scan_statement .)
    DO              reduce using rule 26 (any_statement -> scan_statement .)
    BREAK           reduce using rule 26 (any_statement -> scan_statement .)
    FOR             reduce using rule 26 (any_statement -> scan_statement .)
    IF              reduce using rule 26 (any_statement -> scan_statement .)
    PRINTF          reduce using rule 26 (any_statement -> scan_statement .)
    SCANF           reduce using rule 26 (any_statement -> scan_statement .)
    CONST           reduce using rule 26 (any_statement -> scan_statement .)
    ID              reduce using rule 26 (any_statement -> scan_statement .)
    INCREMENT       reduce using rule 26 (any_statement -> scan_statement .)
    DECREMENT       reduce using rule 26 (any_statement -> scan_statement .)
    INT             reduce using rule 26 (any_statement -> scan_statement .)
    FLOAT           reduce using rule 26 (any_statement -> scan_statement .)
    DOUBLE          reduce using rule 26 (any_statement -> scan_statement .)
    CHAR            reduce using rule 26 (any_statement -> scan_statement .)
    BOOL            reduce using rule 26 (any_statement -> scan_statement .)
    LONG            reduce using rule 26 (any_statement -> scan_statement .)
    VOID            reduce using rule 26 (any_statement -> scan_statement .)
    R_BRACE         reduce using rule 26 (any_statement -> scan_statement .)


state 123

    (69) assign_expression -> ID . assign_op value_expression
    (71) assign_expression -> ID . unary_op
    (67) function_expression -> ID . L_BRACKET opt_listed_values R_BRACKET
    (108) assign_op -> . ASSIGN
    (109) assign_op -> . PLUS_ASSIGN
    (110) assign_op -> . MINUS_ASSIGN
    (111) assign_op -> . MUL_ASSIGN
    (112) assign_op -> . DIV_ASSIGN
    (113) assign_op -> . MOD_ASSIGN
    (98) unary_op -> . INCREMENT
    (99) unary_op -> . DECREMENT

    L_BRACKET       shift and go to state 76
    ASSIGN          shift and go to state 152
    PLUS_ASSIGN     shift and go to state 153
    MINUS_ASSIGN    shift and go to state 154
    MUL_ASSIGN      shift and go to state 155
    DIV_ASSIGN      shift and go to state 156
    MOD_ASSIGN      shift and go to state 157
    INCREMENT       shift and go to state 135
    DECREMENT       shift and go to state 136

    assign_op                      shift and go to state 150
    unary_op                       shift and go to state 151

state 124

    (29) assign_statement -> assign_expression . SEMICOLON

    SEMICOLON       shift and go to state 158


state 125

    (30) function_statement -> function_expression . SEMICOLON

    SEMICOLON       shift and go to state 159


state 126

    (31) return_statement -> RETURN . value_expression SEMICOLON
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 50

    value_expression               shift and go to state 160
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    logical_expression             shift and go to state 49

state 127

    (34) while_loop_statement -> WHILE . L_BRACKET logical_expression R_BRACKET statements_block

    L_BRACKET       shift and go to state 161


state 128

    (35) do_while_loop_statement -> DO . statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 86

    statements_block               shift and go to state 162

state 129

    (32) break_statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 163


state 130

    (36) for_loop_statement -> FOR . L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block

    L_BRACKET       shift and go to state 164


state 131

    (39) if_statement -> IF . L_BRACKET logical_expression R_BRACKET statements_block

    L_BRACKET       shift and go to state 165


state 132

    (48) print_statement -> PRINTF . L_BRACKET value_expression R_BRACKET

    L_BRACKET       shift and go to state 166


state 133

    (49) scan_statement -> SCANF . L_BRACKET AMPERSAND ID R_BRACKET

    L_BRACKET       shift and go to state 167


state 134

    (70) assign_expression -> unary_op . ID

    ID              shift and go to state 168


state 135

    (98) unary_op -> INCREMENT .

    ID              reduce using rule 98 (unary_op -> INCREMENT .)
    SEMICOLON       reduce using rule 98 (unary_op -> INCREMENT .)
    R_BRACKET       reduce using rule 98 (unary_op -> INCREMENT .)


state 136

    (99) unary_op -> DECREMENT .

    ID              reduce using rule 99 (unary_op -> DECREMENT .)
    SEMICOLON       reduce using rule 99 (unary_op -> DECREMENT .)
    R_BRACKET       reduce using rule 99 (unary_op -> DECREMENT .)


state 137

    (51) declaration_value_expression -> L_BRACE listed_values R_BRACE .

    SEMICOLON       reduce using rule 51 (declaration_value_expression -> L_BRACE listed_values R_BRACE .)
    R_BRACE         reduce using rule 51 (declaration_value_expression -> L_BRACE listed_values R_BRACE .)


state 138

    (52) declaration_value_expression -> L_BRACE declaration_value_expression R_BRACE .

    SEMICOLON       reduce using rule 52 (declaration_value_expression -> L_BRACE declaration_value_expression R_BRACE .)
    R_BRACE         reduce using rule 52 (declaration_value_expression -> L_BRACE declaration_value_expression R_BRACE .)


state 139

    (91) listed_values -> value_expression COMMA . value_expression
    (92) listed_values -> value_expression COMMA . listed_values
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (91) listed_values -> . value_expression COMMA value_expression
    (92) listed_values -> . value_expression COMMA listed_values
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 50

    value_expression               shift and go to state 169
    listed_values                  shift and go to state 170
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    logical_expression             shift and go to state 49

state 140

    (67) function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .

    EQUAL           reduce using rule 67 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    NOT_EQUAL       reduce using rule 67 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    GREATER         reduce using rule 67 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    GREATER_EQUAL   reduce using rule 67 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    LESSER          reduce using rule 67 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    LESSER_EQUAL    reduce using rule 67 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    R_SQUARE_BRACKET reduce using rule 67 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    SEMICOLON       reduce using rule 67 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    R_BRACKET       reduce using rule 67 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    COMMA           reduce using rule 67 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    R_BRACE         reduce using rule 67 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    QUESTION_MARK   reduce using rule 67 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    AND             reduce using rule 67 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    OR              reduce using rule 67 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    COLON           reduce using rule 67 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)


state 141

    (90) value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .

    PLUS            reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    MINUS           reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    MUL             reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    DIV             reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    MOD             reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    EQUAL           reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    NOT_EQUAL       reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    GREATER         reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    GREATER_EQUAL   reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    LESSER          reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    LESSER_EQUAL    reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    R_SQUARE_BRACKET reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    SEMICOLON       reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    R_BRACKET       reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    COMMA           reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    R_BRACE         reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    QUESTION_MARK   reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    AND             reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    OR              reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    COLON           reduce using rule 90 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)


state 142

    (68) trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 50

    logical_expression             shift and go to state 49
    value_expression               shift and go to state 171
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39

state 143

    (15) statements_block -> L_BRACE opt_statements R_BRACE .

    COMMENT         reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    PREPROCESSOR_LINE reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    CONST           reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    INT             reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    FLOAT           reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    DOUBLE          reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    CHAR            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    BOOL            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    LONG            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    VOID            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    $end            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    WHILE           reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    SEMICOLON       reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    RETURN          reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    DO              reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    BREAK           reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    FOR             reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    IF              reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    PRINTF          reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    SCANF           reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    ID              reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    INCREMENT       reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    DECREMENT       reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    R_BRACE         reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    ELSE            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)


state 144

    (12) statements -> statement statements .

    R_BRACE         reduce using rule 12 (statements -> statement statements .)


state 145

    (24) any_statement -> if_statement opt_else_if_statements . opt_else_statement
    (44) opt_else_statement -> . else_statement
    (45) opt_else_statement -> . empty
    (40) else_statement -> . ELSE statements_block
    (125) empty -> .

    ELSE            shift and go to state 175
    COMMENT         reduce using rule 125 (empty -> .)
    SEMICOLON       reduce using rule 125 (empty -> .)
    RETURN          reduce using rule 125 (empty -> .)
    WHILE           reduce using rule 125 (empty -> .)
    DO              reduce using rule 125 (empty -> .)
    BREAK           reduce using rule 125 (empty -> .)
    FOR             reduce using rule 125 (empty -> .)
    IF              reduce using rule 125 (empty -> .)
    PRINTF          reduce using rule 125 (empty -> .)
    SCANF           reduce using rule 125 (empty -> .)
    CONST           reduce using rule 125 (empty -> .)
    ID              reduce using rule 125 (empty -> .)
    INCREMENT       reduce using rule 125 (empty -> .)
    DECREMENT       reduce using rule 125 (empty -> .)
    INT             reduce using rule 125 (empty -> .)
    FLOAT           reduce using rule 125 (empty -> .)
    DOUBLE          reduce using rule 125 (empty -> .)
    CHAR            reduce using rule 125 (empty -> .)
    BOOL            reduce using rule 125 (empty -> .)
    LONG            reduce using rule 125 (empty -> .)
    VOID            reduce using rule 125 (empty -> .)
    R_BRACE         reduce using rule 125 (empty -> .)

    opt_else_statement             shift and go to state 172
    else_statement                 shift and go to state 173
    empty                          shift and go to state 174

state 146

    (46) opt_else_if_statements -> else_if_statements .

    ELSE            reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    COMMENT         reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    SEMICOLON       reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    RETURN          reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    WHILE           reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    DO              reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    BREAK           reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    FOR             reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    IF              reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    PRINTF          reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    SCANF           reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    CONST           reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    ID              reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    INCREMENT       reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    DECREMENT       reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    INT             reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    FLOAT           reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    DOUBLE          reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    CHAR            reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    BOOL            reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    LONG            reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    VOID            reduce using rule 46 (opt_else_if_statements -> else_if_statements .)
    R_BRACE         reduce using rule 46 (opt_else_if_statements -> else_if_statements .)


state 147

    (47) opt_else_if_statements -> empty .

    ELSE            reduce using rule 47 (opt_else_if_statements -> empty .)
    COMMENT         reduce using rule 47 (opt_else_if_statements -> empty .)
    SEMICOLON       reduce using rule 47 (opt_else_if_statements -> empty .)
    RETURN          reduce using rule 47 (opt_else_if_statements -> empty .)
    WHILE           reduce using rule 47 (opt_else_if_statements -> empty .)
    DO              reduce using rule 47 (opt_else_if_statements -> empty .)
    BREAK           reduce using rule 47 (opt_else_if_statements -> empty .)
    FOR             reduce using rule 47 (opt_else_if_statements -> empty .)
    IF              reduce using rule 47 (opt_else_if_statements -> empty .)
    PRINTF          reduce using rule 47 (opt_else_if_statements -> empty .)
    SCANF           reduce using rule 47 (opt_else_if_statements -> empty .)
    CONST           reduce using rule 47 (opt_else_if_statements -> empty .)
    ID              reduce using rule 47 (opt_else_if_statements -> empty .)
    INCREMENT       reduce using rule 47 (opt_else_if_statements -> empty .)
    DECREMENT       reduce using rule 47 (opt_else_if_statements -> empty .)
    INT             reduce using rule 47 (opt_else_if_statements -> empty .)
    FLOAT           reduce using rule 47 (opt_else_if_statements -> empty .)
    DOUBLE          reduce using rule 47 (opt_else_if_statements -> empty .)
    CHAR            reduce using rule 47 (opt_else_if_statements -> empty .)
    BOOL            reduce using rule 47 (opt_else_if_statements -> empty .)
    LONG            reduce using rule 47 (opt_else_if_statements -> empty .)
    VOID            reduce using rule 47 (opt_else_if_statements -> empty .)
    R_BRACE         reduce using rule 47 (opt_else_if_statements -> empty .)


state 148

    (42) else_if_statements -> else_if_statement .
    (43) else_if_statements -> else_if_statement . else_if_statements
    (42) else_if_statements -> . else_if_statement
    (43) else_if_statements -> . else_if_statement else_if_statements
    (41) else_if_statement -> . ELSE IF L_BRACKET logical_expression R_BRACKET statements_block

  ! shift/reduce conflict for ELSE resolved as shift
    COMMENT         reduce using rule 42 (else_if_statements -> else_if_statement .)
    SEMICOLON       reduce using rule 42 (else_if_statements -> else_if_statement .)
    RETURN          reduce using rule 42 (else_if_statements -> else_if_statement .)
    WHILE           reduce using rule 42 (else_if_statements -> else_if_statement .)
    DO              reduce using rule 42 (else_if_statements -> else_if_statement .)
    BREAK           reduce using rule 42 (else_if_statements -> else_if_statement .)
    FOR             reduce using rule 42 (else_if_statements -> else_if_statement .)
    IF              reduce using rule 42 (else_if_statements -> else_if_statement .)
    PRINTF          reduce using rule 42 (else_if_statements -> else_if_statement .)
    SCANF           reduce using rule 42 (else_if_statements -> else_if_statement .)
    CONST           reduce using rule 42 (else_if_statements -> else_if_statement .)
    ID              reduce using rule 42 (else_if_statements -> else_if_statement .)
    INCREMENT       reduce using rule 42 (else_if_statements -> else_if_statement .)
    DECREMENT       reduce using rule 42 (else_if_statements -> else_if_statement .)
    INT             reduce using rule 42 (else_if_statements -> else_if_statement .)
    FLOAT           reduce using rule 42 (else_if_statements -> else_if_statement .)
    DOUBLE          reduce using rule 42 (else_if_statements -> else_if_statement .)
    CHAR            reduce using rule 42 (else_if_statements -> else_if_statement .)
    BOOL            reduce using rule 42 (else_if_statements -> else_if_statement .)
    LONG            reduce using rule 42 (else_if_statements -> else_if_statement .)
    VOID            reduce using rule 42 (else_if_statements -> else_if_statement .)
    R_BRACE         reduce using rule 42 (else_if_statements -> else_if_statement .)
    ELSE            shift and go to state 149

  ! ELSE            [ reduce using rule 42 (else_if_statements -> else_if_statement .) ]

    else_if_statement              shift and go to state 148
    else_if_statements             shift and go to state 176

state 149

    (41) else_if_statement -> ELSE . IF L_BRACKET logical_expression R_BRACKET statements_block

    IF              shift and go to state 177


state 150

    (69) assign_expression -> ID assign_op . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 50

    value_expression               shift and go to state 178
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    logical_expression             shift and go to state 49

state 151

    (71) assign_expression -> ID unary_op .

    SEMICOLON       reduce using rule 71 (assign_expression -> ID unary_op .)
    R_BRACKET       reduce using rule 71 (assign_expression -> ID unary_op .)


state 152

    (108) assign_op -> ASSIGN .

    L_BRACKET       reduce using rule 108 (assign_op -> ASSIGN .)
    MINUS           reduce using rule 108 (assign_op -> ASSIGN .)
    ID              reduce using rule 108 (assign_op -> ASSIGN .)
    INTEGER         reduce using rule 108 (assign_op -> ASSIGN .)
    DECIMAL         reduce using rule 108 (assign_op -> ASSIGN .)
    CHARACTER       reduce using rule 108 (assign_op -> ASSIGN .)
    STRING          reduce using rule 108 (assign_op -> ASSIGN .)
    TRUE            reduce using rule 108 (assign_op -> ASSIGN .)
    FALSE           reduce using rule 108 (assign_op -> ASSIGN .)
    NEGATION        reduce using rule 108 (assign_op -> ASSIGN .)


state 153

    (109) assign_op -> PLUS_ASSIGN .

    L_BRACKET       reduce using rule 109 (assign_op -> PLUS_ASSIGN .)
    MINUS           reduce using rule 109 (assign_op -> PLUS_ASSIGN .)
    ID              reduce using rule 109 (assign_op -> PLUS_ASSIGN .)
    INTEGER         reduce using rule 109 (assign_op -> PLUS_ASSIGN .)
    DECIMAL         reduce using rule 109 (assign_op -> PLUS_ASSIGN .)
    CHARACTER       reduce using rule 109 (assign_op -> PLUS_ASSIGN .)
    STRING          reduce using rule 109 (assign_op -> PLUS_ASSIGN .)
    TRUE            reduce using rule 109 (assign_op -> PLUS_ASSIGN .)
    FALSE           reduce using rule 109 (assign_op -> PLUS_ASSIGN .)
    NEGATION        reduce using rule 109 (assign_op -> PLUS_ASSIGN .)


state 154

    (110) assign_op -> MINUS_ASSIGN .

    L_BRACKET       reduce using rule 110 (assign_op -> MINUS_ASSIGN .)
    MINUS           reduce using rule 110 (assign_op -> MINUS_ASSIGN .)
    ID              reduce using rule 110 (assign_op -> MINUS_ASSIGN .)
    INTEGER         reduce using rule 110 (assign_op -> MINUS_ASSIGN .)
    DECIMAL         reduce using rule 110 (assign_op -> MINUS_ASSIGN .)
    CHARACTER       reduce using rule 110 (assign_op -> MINUS_ASSIGN .)
    STRING          reduce using rule 110 (assign_op -> MINUS_ASSIGN .)
    TRUE            reduce using rule 110 (assign_op -> MINUS_ASSIGN .)
    FALSE           reduce using rule 110 (assign_op -> MINUS_ASSIGN .)
    NEGATION        reduce using rule 110 (assign_op -> MINUS_ASSIGN .)


state 155

    (111) assign_op -> MUL_ASSIGN .

    L_BRACKET       reduce using rule 111 (assign_op -> MUL_ASSIGN .)
    MINUS           reduce using rule 111 (assign_op -> MUL_ASSIGN .)
    ID              reduce using rule 111 (assign_op -> MUL_ASSIGN .)
    INTEGER         reduce using rule 111 (assign_op -> MUL_ASSIGN .)
    DECIMAL         reduce using rule 111 (assign_op -> MUL_ASSIGN .)
    CHARACTER       reduce using rule 111 (assign_op -> MUL_ASSIGN .)
    STRING          reduce using rule 111 (assign_op -> MUL_ASSIGN .)
    TRUE            reduce using rule 111 (assign_op -> MUL_ASSIGN .)
    FALSE           reduce using rule 111 (assign_op -> MUL_ASSIGN .)
    NEGATION        reduce using rule 111 (assign_op -> MUL_ASSIGN .)


state 156

    (112) assign_op -> DIV_ASSIGN .

    L_BRACKET       reduce using rule 112 (assign_op -> DIV_ASSIGN .)
    MINUS           reduce using rule 112 (assign_op -> DIV_ASSIGN .)
    ID              reduce using rule 112 (assign_op -> DIV_ASSIGN .)
    INTEGER         reduce using rule 112 (assign_op -> DIV_ASSIGN .)
    DECIMAL         reduce using rule 112 (assign_op -> DIV_ASSIGN .)
    CHARACTER       reduce using rule 112 (assign_op -> DIV_ASSIGN .)
    STRING          reduce using rule 112 (assign_op -> DIV_ASSIGN .)
    TRUE            reduce using rule 112 (assign_op -> DIV_ASSIGN .)
    FALSE           reduce using rule 112 (assign_op -> DIV_ASSIGN .)
    NEGATION        reduce using rule 112 (assign_op -> DIV_ASSIGN .)


state 157

    (113) assign_op -> MOD_ASSIGN .

    L_BRACKET       reduce using rule 113 (assign_op -> MOD_ASSIGN .)
    MINUS           reduce using rule 113 (assign_op -> MOD_ASSIGN .)
    ID              reduce using rule 113 (assign_op -> MOD_ASSIGN .)
    INTEGER         reduce using rule 113 (assign_op -> MOD_ASSIGN .)
    DECIMAL         reduce using rule 113 (assign_op -> MOD_ASSIGN .)
    CHARACTER       reduce using rule 113 (assign_op -> MOD_ASSIGN .)
    STRING          reduce using rule 113 (assign_op -> MOD_ASSIGN .)
    TRUE            reduce using rule 113 (assign_op -> MOD_ASSIGN .)
    FALSE           reduce using rule 113 (assign_op -> MOD_ASSIGN .)
    NEGATION        reduce using rule 113 (assign_op -> MOD_ASSIGN .)


state 158

    (29) assign_statement -> assign_expression SEMICOLON .

    COMMENT         reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    SEMICOLON       reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    RETURN          reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    WHILE           reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    DO              reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    BREAK           reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    FOR             reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    IF              reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    PRINTF          reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    SCANF           reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    CONST           reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    ID              reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    INCREMENT       reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    DECREMENT       reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    INT             reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    FLOAT           reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    DOUBLE          reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    CHAR            reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    BOOL            reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    LONG            reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    VOID            reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    R_BRACE         reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)


state 159

    (30) function_statement -> function_expression SEMICOLON .

    COMMENT         reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    SEMICOLON       reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    RETURN          reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    WHILE           reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    DO              reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    BREAK           reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    FOR             reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    IF              reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    PRINTF          reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    SCANF           reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    CONST           reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    ID              reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    INCREMENT       reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    DECREMENT       reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    INT             reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    FLOAT           reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    DOUBLE          reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    CHAR            reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    BOOL            reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    LONG            reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    VOID            reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    R_BRACE         reduce using rule 30 (function_statement -> function_expression SEMICOLON .)


state 160

    (31) return_statement -> RETURN value_expression . SEMICOLON
    (66) logical_expression -> value_expression . comparison_op value_expression
    (102) comparison_op -> . EQUAL
    (103) comparison_op -> . NOT_EQUAL
    (104) comparison_op -> . GREATER
    (105) comparison_op -> . GREATER_EQUAL
    (106) comparison_op -> . LESSER
    (107) comparison_op -> . LESSER_EQUAL

    SEMICOLON       shift and go to state 179
    EQUAL           shift and go to state 58
    NOT_EQUAL       shift and go to state 59
    GREATER         shift and go to state 60
    GREATER_EQUAL   shift and go to state 61
    LESSER          shift and go to state 62
    LESSER_EQUAL    shift and go to state 63

    comparison_op                  shift and go to state 57

state 161

    (34) while_loop_statement -> WHILE L_BRACKET . logical_expression R_BRACKET statements_block
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    NEGATION        shift and go to state 50
    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48

    logical_expression             shift and go to state 180
    value_expression               shift and go to state 83
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39

state 162

    (35) do_while_loop_statement -> DO statements_block . WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON

    WHILE           shift and go to state 181


state 163

    (32) break_statement -> BREAK SEMICOLON .

    COMMENT         reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    DO              reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    IF              reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    PRINTF          reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    SCANF           reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    CONST           reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    ID              reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    INCREMENT       reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    DECREMENT       reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    INT             reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    DOUBLE          reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    CHAR            reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    BOOL            reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    LONG            reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    VOID            reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    R_BRACE         reduce using rule 32 (break_statement -> BREAK SEMICOLON .)


state 164

    (36) for_loop_statement -> FOR L_BRACKET . decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block
    (37) decl_stat_or_sem -> . declaration_statement
    (38) decl_stat_or_sem -> . SEMICOLON
    (27) declaration_statement -> . opt_const type ID opt_array_mark
    (28) declaration_statement -> . opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (115) opt_const -> . CONST
    (116) opt_const -> . empty
    (125) empty -> .

    SEMICOLON       shift and go to state 183
    CONST           shift and go to state 10
    INT             reduce using rule 125 (empty -> .)
    FLOAT           reduce using rule 125 (empty -> .)
    DOUBLE          reduce using rule 125 (empty -> .)
    CHAR            reduce using rule 125 (empty -> .)
    BOOL            reduce using rule 125 (empty -> .)
    LONG            reduce using rule 125 (empty -> .)
    VOID            reduce using rule 125 (empty -> .)

    decl_stat_or_sem               shift and go to state 182
    declaration_statement          shift and go to state 184
    opt_const                      shift and go to state 8
    empty                          shift and go to state 11

state 165

    (39) if_statement -> IF L_BRACKET . logical_expression R_BRACKET statements_block
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    NEGATION        shift and go to state 50
    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48

    logical_expression             shift and go to state 185
    value_expression               shift and go to state 83
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39

state 166

    (48) print_statement -> PRINTF L_BRACKET . value_expression R_BRACKET
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression

    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NEGATION        shift and go to state 50

    value_expression               shift and go to state 186
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39
    logical_expression             shift and go to state 49

state 167

    (49) scan_statement -> SCANF L_BRACKET . AMPERSAND ID R_BRACKET

    AMPERSAND       shift and go to state 187


state 168

    (70) assign_expression -> unary_op ID .

    SEMICOLON       reduce using rule 70 (assign_expression -> unary_op ID .)
    R_BRACKET       reduce using rule 70 (assign_expression -> unary_op ID .)


state 169

    (91) listed_values -> value_expression COMMA value_expression .
    (91) listed_values -> value_expression . COMMA value_expression
    (92) listed_values -> value_expression . COMMA listed_values
    (66) logical_expression -> value_expression . comparison_op value_expression
    (102) comparison_op -> . EQUAL
    (103) comparison_op -> . NOT_EQUAL
    (104) comparison_op -> . GREATER
    (105) comparison_op -> . GREATER_EQUAL
    (106) comparison_op -> . LESSER
    (107) comparison_op -> . LESSER_EQUAL

    R_BRACE         reduce using rule 91 (listed_values -> value_expression COMMA value_expression .)
    R_BRACKET       reduce using rule 91 (listed_values -> value_expression COMMA value_expression .)
    COMMA           shift and go to state 139
    EQUAL           shift and go to state 58
    NOT_EQUAL       shift and go to state 59
    GREATER         shift and go to state 60
    GREATER_EQUAL   shift and go to state 61
    LESSER          shift and go to state 62
    LESSER_EQUAL    shift and go to state 63

    comparison_op                  shift and go to state 57

state 170

    (92) listed_values -> value_expression COMMA listed_values .

    R_BRACE         reduce using rule 92 (listed_values -> value_expression COMMA listed_values .)
    R_BRACKET       reduce using rule 92 (listed_values -> value_expression COMMA listed_values .)


state 171

    (68) trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .
    (66) logical_expression -> value_expression . comparison_op value_expression
    (102) comparison_op -> . EQUAL
    (103) comparison_op -> . NOT_EQUAL
    (104) comparison_op -> . GREATER
    (105) comparison_op -> . GREATER_EQUAL
    (106) comparison_op -> . LESSER
    (107) comparison_op -> . LESSER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
    R_SQUARE_BRACKET reduce using rule 68 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    SEMICOLON       reduce using rule 68 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    R_BRACKET       reduce using rule 68 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    COMMA           reduce using rule 68 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    R_BRACE         reduce using rule 68 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    QUESTION_MARK   reduce using rule 68 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    AND             reduce using rule 68 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    OR              reduce using rule 68 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    COLON           reduce using rule 68 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .)
    EQUAL           shift and go to state 58
    NOT_EQUAL       shift and go to state 59
    GREATER         shift and go to state 60
    GREATER_EQUAL   shift and go to state 61
    LESSER          shift and go to state 62
    LESSER_EQUAL    shift and go to state 63

  ! EQUAL           [ reduce using rule 68 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 68 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! GREATER         [ reduce using rule 68 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 68 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! LESSER          [ reduce using rule 68 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 68 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]

    comparison_op                  shift and go to state 57

state 172

    (24) any_statement -> if_statement opt_else_if_statements opt_else_statement .

    COMMENT         reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    SEMICOLON       reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    RETURN          reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    WHILE           reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    DO              reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    BREAK           reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    FOR             reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    IF              reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    PRINTF          reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    SCANF           reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    CONST           reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    ID              reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    INCREMENT       reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    DECREMENT       reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    INT             reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    FLOAT           reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    DOUBLE          reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    CHAR            reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    BOOL            reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    LONG            reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    VOID            reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    R_BRACE         reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)


state 173

    (44) opt_else_statement -> else_statement .

    COMMENT         reduce using rule 44 (opt_else_statement -> else_statement .)
    SEMICOLON       reduce using rule 44 (opt_else_statement -> else_statement .)
    RETURN          reduce using rule 44 (opt_else_statement -> else_statement .)
    WHILE           reduce using rule 44 (opt_else_statement -> else_statement .)
    DO              reduce using rule 44 (opt_else_statement -> else_statement .)
    BREAK           reduce using rule 44 (opt_else_statement -> else_statement .)
    FOR             reduce using rule 44 (opt_else_statement -> else_statement .)
    IF              reduce using rule 44 (opt_else_statement -> else_statement .)
    PRINTF          reduce using rule 44 (opt_else_statement -> else_statement .)
    SCANF           reduce using rule 44 (opt_else_statement -> else_statement .)
    CONST           reduce using rule 44 (opt_else_statement -> else_statement .)
    ID              reduce using rule 44 (opt_else_statement -> else_statement .)
    INCREMENT       reduce using rule 44 (opt_else_statement -> else_statement .)
    DECREMENT       reduce using rule 44 (opt_else_statement -> else_statement .)
    INT             reduce using rule 44 (opt_else_statement -> else_statement .)
    FLOAT           reduce using rule 44 (opt_else_statement -> else_statement .)
    DOUBLE          reduce using rule 44 (opt_else_statement -> else_statement .)
    CHAR            reduce using rule 44 (opt_else_statement -> else_statement .)
    BOOL            reduce using rule 44 (opt_else_statement -> else_statement .)
    LONG            reduce using rule 44 (opt_else_statement -> else_statement .)
    VOID            reduce using rule 44 (opt_else_statement -> else_statement .)
    R_BRACE         reduce using rule 44 (opt_else_statement -> else_statement .)


state 174

    (45) opt_else_statement -> empty .

    COMMENT         reduce using rule 45 (opt_else_statement -> empty .)
    SEMICOLON       reduce using rule 45 (opt_else_statement -> empty .)
    RETURN          reduce using rule 45 (opt_else_statement -> empty .)
    WHILE           reduce using rule 45 (opt_else_statement -> empty .)
    DO              reduce using rule 45 (opt_else_statement -> empty .)
    BREAK           reduce using rule 45 (opt_else_statement -> empty .)
    FOR             reduce using rule 45 (opt_else_statement -> empty .)
    IF              reduce using rule 45 (opt_else_statement -> empty .)
    PRINTF          reduce using rule 45 (opt_else_statement -> empty .)
    SCANF           reduce using rule 45 (opt_else_statement -> empty .)
    CONST           reduce using rule 45 (opt_else_statement -> empty .)
    ID              reduce using rule 45 (opt_else_statement -> empty .)
    INCREMENT       reduce using rule 45 (opt_else_statement -> empty .)
    DECREMENT       reduce using rule 45 (opt_else_statement -> empty .)
    INT             reduce using rule 45 (opt_else_statement -> empty .)
    FLOAT           reduce using rule 45 (opt_else_statement -> empty .)
    DOUBLE          reduce using rule 45 (opt_else_statement -> empty .)
    CHAR            reduce using rule 45 (opt_else_statement -> empty .)
    BOOL            reduce using rule 45 (opt_else_statement -> empty .)
    LONG            reduce using rule 45 (opt_else_statement -> empty .)
    VOID            reduce using rule 45 (opt_else_statement -> empty .)
    R_BRACE         reduce using rule 45 (opt_else_statement -> empty .)


state 175

    (40) else_statement -> ELSE . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 86

    statements_block               shift and go to state 188

state 176

    (43) else_if_statements -> else_if_statement else_if_statements .

    ELSE            reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    COMMENT         reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    SEMICOLON       reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    RETURN          reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    WHILE           reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    DO              reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    BREAK           reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    FOR             reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    IF              reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    PRINTF          reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    SCANF           reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    CONST           reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    ID              reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    INCREMENT       reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    DECREMENT       reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    INT             reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    FLOAT           reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    DOUBLE          reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    CHAR            reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    BOOL            reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    LONG            reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    VOID            reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)
    R_BRACE         reduce using rule 43 (else_if_statements -> else_if_statement else_if_statements .)


state 177

    (41) else_if_statement -> ELSE IF . L_BRACKET logical_expression R_BRACKET statements_block

    L_BRACKET       shift and go to state 189


state 178

    (69) assign_expression -> ID assign_op value_expression .
    (66) logical_expression -> value_expression . comparison_op value_expression
    (102) comparison_op -> . EQUAL
    (103) comparison_op -> . NOT_EQUAL
    (104) comparison_op -> . GREATER
    (105) comparison_op -> . GREATER_EQUAL
    (106) comparison_op -> . LESSER
    (107) comparison_op -> . LESSER_EQUAL

    SEMICOLON       reduce using rule 69 (assign_expression -> ID assign_op value_expression .)
    R_BRACKET       reduce using rule 69 (assign_expression -> ID assign_op value_expression .)
    EQUAL           shift and go to state 58
    NOT_EQUAL       shift and go to state 59
    GREATER         shift and go to state 60
    GREATER_EQUAL   shift and go to state 61
    LESSER          shift and go to state 62
    LESSER_EQUAL    shift and go to state 63

    comparison_op                  shift and go to state 57

state 179

    (31) return_statement -> RETURN value_expression SEMICOLON .

    COMMENT         reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    SEMICOLON       reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    RETURN          reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    WHILE           reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    DO              reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    BREAK           reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    FOR             reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    IF              reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    PRINTF          reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    SCANF           reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    CONST           reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    ID              reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    INCREMENT       reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    DECREMENT       reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    INT             reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    FLOAT           reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    DOUBLE          reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    CHAR            reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    BOOL            reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    LONG            reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    VOID            reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    R_BRACE         reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)


state 180

    (34) while_loop_statement -> WHILE L_BRACKET logical_expression . R_BRACKET statements_block
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (68) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (100) bool_op -> . AND
    (101) bool_op -> . OR

    R_BRACKET       shift and go to state 190
    QUESTION_MARK   shift and go to state 78
    AND             shift and go to state 80
    OR              shift and go to state 81

    bool_op                        shift and go to state 79

state 181

    (35) do_while_loop_statement -> DO statements_block WHILE . L_BRACKET logical_expression R_BRACKET SEMICOLON

    L_BRACKET       shift and go to state 191


state 182

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem . opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block
    (72) opt_logical_expression -> . logical_expression
    (73) opt_logical_expression -> . empty
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (125) empty -> .
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    NEGATION        shift and go to state 50
    SEMICOLON       reduce using rule 125 (empty -> .)
    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48

    opt_logical_expression         shift and go to state 192
    logical_expression             shift and go to state 193
    empty                          shift and go to state 194
    value_expression               shift and go to state 83
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39

state 183

    (38) decl_stat_or_sem -> SEMICOLON .

    NEGATION        reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    L_BRACKET       reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    MINUS           reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    ID              reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    INTEGER         reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    DECIMAL         reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    CHARACTER       reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    STRING          reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    TRUE            reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    FALSE           reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    SEMICOLON       reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)


state 184

    (37) decl_stat_or_sem -> declaration_statement .

    NEGATION        reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    L_BRACKET       reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    MINUS           reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    ID              reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    INTEGER         reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    DECIMAL         reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    CHARACTER       reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    STRING          reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    TRUE            reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    FALSE           reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    SEMICOLON       reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)


state 185

    (39) if_statement -> IF L_BRACKET logical_expression . R_BRACKET statements_block
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (68) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (100) bool_op -> . AND
    (101) bool_op -> . OR

    R_BRACKET       shift and go to state 195
    QUESTION_MARK   shift and go to state 78
    AND             shift and go to state 80
    OR              shift and go to state 81

    bool_op                        shift and go to state 79

state 186

    (48) print_statement -> PRINTF L_BRACKET value_expression . R_BRACKET
    (66) logical_expression -> value_expression . comparison_op value_expression
    (102) comparison_op -> . EQUAL
    (103) comparison_op -> . NOT_EQUAL
    (104) comparison_op -> . GREATER
    (105) comparison_op -> . GREATER_EQUAL
    (106) comparison_op -> . LESSER
    (107) comparison_op -> . LESSER_EQUAL

    R_BRACKET       shift and go to state 196
    EQUAL           shift and go to state 58
    NOT_EQUAL       shift and go to state 59
    GREATER         shift and go to state 60
    GREATER_EQUAL   shift and go to state 61
    LESSER          shift and go to state 62
    LESSER_EQUAL    shift and go to state 63

    comparison_op                  shift and go to state 57

state 187

    (49) scan_statement -> SCANF L_BRACKET AMPERSAND . ID R_BRACKET

    ID              shift and go to state 197


state 188

    (40) else_statement -> ELSE statements_block .

    COMMENT         reduce using rule 40 (else_statement -> ELSE statements_block .)
    SEMICOLON       reduce using rule 40 (else_statement -> ELSE statements_block .)
    RETURN          reduce using rule 40 (else_statement -> ELSE statements_block .)
    WHILE           reduce using rule 40 (else_statement -> ELSE statements_block .)
    DO              reduce using rule 40 (else_statement -> ELSE statements_block .)
    BREAK           reduce using rule 40 (else_statement -> ELSE statements_block .)
    FOR             reduce using rule 40 (else_statement -> ELSE statements_block .)
    IF              reduce using rule 40 (else_statement -> ELSE statements_block .)
    PRINTF          reduce using rule 40 (else_statement -> ELSE statements_block .)
    SCANF           reduce using rule 40 (else_statement -> ELSE statements_block .)
    CONST           reduce using rule 40 (else_statement -> ELSE statements_block .)
    ID              reduce using rule 40 (else_statement -> ELSE statements_block .)
    INCREMENT       reduce using rule 40 (else_statement -> ELSE statements_block .)
    DECREMENT       reduce using rule 40 (else_statement -> ELSE statements_block .)
    INT             reduce using rule 40 (else_statement -> ELSE statements_block .)
    FLOAT           reduce using rule 40 (else_statement -> ELSE statements_block .)
    DOUBLE          reduce using rule 40 (else_statement -> ELSE statements_block .)
    CHAR            reduce using rule 40 (else_statement -> ELSE statements_block .)
    BOOL            reduce using rule 40 (else_statement -> ELSE statements_block .)
    LONG            reduce using rule 40 (else_statement -> ELSE statements_block .)
    VOID            reduce using rule 40 (else_statement -> ELSE statements_block .)
    R_BRACE         reduce using rule 40 (else_statement -> ELSE statements_block .)


state 189

    (41) else_if_statement -> ELSE IF L_BRACKET . logical_expression R_BRACKET statements_block
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    NEGATION        shift and go to state 50
    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48

    logical_expression             shift and go to state 198
    value_expression               shift and go to state 83
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39

state 190

    (34) while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 86

    statements_block               shift and go to state 199

state 191

    (35) do_while_loop_statement -> DO statements_block WHILE L_BRACKET . logical_expression R_BRACKET SEMICOLON
    (64) logical_expression -> . logical_expression bool_op logical_expression
    (65) logical_expression -> . NEGATION logical_expression
    (66) logical_expression -> . value_expression comparison_op value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . function_expression
    (55) value_expression -> . value
    (56) value_expression -> . trinary_mark_expression
    (57) value_expression -> . L_BRACKET value_expression R_BRACKET
    (60) math_expression -> . L_BRACKET math_expression R_BRACKET
    (61) math_expression -> . MINUS math_expression
    (62) math_expression -> . MINUS value
    (63) math_expression -> . value math_op value
    (67) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (83) value -> . INTEGER
    (84) value -> . DECIMAL
    (85) value -> . CHARACTER
    (86) value -> . STRING
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) value -> . ID
    (90) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (68) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    NEGATION        shift and go to state 50
    L_BRACKET       shift and go to state 40
    MINUS           shift and go to state 41
    ID              shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    STRING          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48

    logical_expression             shift and go to state 200
    value_expression               shift and go to state 83
    math_expression                shift and go to state 36
    function_expression            shift and go to state 37
    value                          shift and go to state 38
    trinary_mark_expression        shift and go to state 39

state 192

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression . SEMICOLON opt_assign_expression R_BRACKET statements_block

    SEMICOLON       shift and go to state 201


state 193

    (72) opt_logical_expression -> logical_expression .
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (68) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (100) bool_op -> . AND
    (101) bool_op -> . OR

    SEMICOLON       reduce using rule 72 (opt_logical_expression -> logical_expression .)
    QUESTION_MARK   shift and go to state 78
    AND             shift and go to state 80
    OR              shift and go to state 81

    bool_op                        shift and go to state 79

state 194

    (73) opt_logical_expression -> empty .

    SEMICOLON       reduce using rule 73 (opt_logical_expression -> empty .)


state 195

    (39) if_statement -> IF L_BRACKET logical_expression R_BRACKET . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 86

    statements_block               shift and go to state 202

state 196

    (48) print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .

    COMMENT         reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    SEMICOLON       reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    RETURN          reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    WHILE           reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    DO              reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    BREAK           reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    FOR             reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    IF              reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    PRINTF          reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    SCANF           reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    CONST           reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    ID              reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    INCREMENT       reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    DECREMENT       reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    INT             reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    FLOAT           reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    DOUBLE          reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    CHAR            reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    BOOL            reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    LONG            reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    VOID            reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    R_BRACE         reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)


state 197

    (49) scan_statement -> SCANF L_BRACKET AMPERSAND ID . R_BRACKET

    R_BRACKET       shift and go to state 203


state 198

    (41) else_if_statement -> ELSE IF L_BRACKET logical_expression . R_BRACKET statements_block
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (68) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (100) bool_op -> . AND
    (101) bool_op -> . OR

    R_BRACKET       shift and go to state 204
    QUESTION_MARK   shift and go to state 78
    AND             shift and go to state 80
    OR              shift and go to state 81

    bool_op                        shift and go to state 79

state 199

    (34) while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .

    COMMENT         reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    SEMICOLON       reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    RETURN          reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    WHILE           reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    DO              reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    BREAK           reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    FOR             reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    IF              reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    PRINTF          reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    SCANF           reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    CONST           reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    ID              reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    INCREMENT       reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    DECREMENT       reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    INT             reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    FLOAT           reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    DOUBLE          reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    CHAR            reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    BOOL            reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    LONG            reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    VOID            reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    R_BRACE         reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)


state 200

    (35) do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression . R_BRACKET SEMICOLON
    (64) logical_expression -> logical_expression . bool_op logical_expression
    (68) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (100) bool_op -> . AND
    (101) bool_op -> . OR

    R_BRACKET       shift and go to state 205
    QUESTION_MARK   shift and go to state 78
    AND             shift and go to state 80
    OR              shift and go to state 81

    bool_op                        shift and go to state 79

state 201

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON . opt_assign_expression R_BRACKET statements_block
    (74) opt_assign_expression -> . assign_expression
    (75) opt_assign_expression -> . empty
    (69) assign_expression -> . ID assign_op value_expression
    (70) assign_expression -> . unary_op ID
    (71) assign_expression -> . ID unary_op
    (125) empty -> .
    (98) unary_op -> . INCREMENT
    (99) unary_op -> . DECREMENT

    ID              shift and go to state 209
    R_BRACKET       reduce using rule 125 (empty -> .)
    INCREMENT       shift and go to state 135
    DECREMENT       shift and go to state 136

    opt_assign_expression          shift and go to state 206
    assign_expression              shift and go to state 207
    empty                          shift and go to state 208
    unary_op                       shift and go to state 134

state 202

    (39) if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .

    ELSE            reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    COMMENT         reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    SEMICOLON       reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    RETURN          reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    WHILE           reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    DO              reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    BREAK           reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    FOR             reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    IF              reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    PRINTF          reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    SCANF           reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    CONST           reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    ID              reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    INCREMENT       reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    DECREMENT       reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    INT             reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    FLOAT           reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    DOUBLE          reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    CHAR            reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    BOOL            reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    LONG            reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    VOID            reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    R_BRACE         reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)


state 203

    (49) scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .

    COMMENT         reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    SEMICOLON       reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    RETURN          reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    WHILE           reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    DO              reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    BREAK           reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    FOR             reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    IF              reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    PRINTF          reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    SCANF           reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    CONST           reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    ID              reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    INCREMENT       reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    DECREMENT       reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    INT             reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    FLOAT           reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    DOUBLE          reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    CHAR            reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    BOOL            reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    LONG            reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    VOID            reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    R_BRACE         reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)


state 204

    (41) else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 86

    statements_block               shift and go to state 210

state 205

    (35) do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET . SEMICOLON

    SEMICOLON       shift and go to state 211


state 206

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression . R_BRACKET statements_block

    R_BRACKET       shift and go to state 212


state 207

    (74) opt_assign_expression -> assign_expression .

    R_BRACKET       reduce using rule 74 (opt_assign_expression -> assign_expression .)


state 208

    (75) opt_assign_expression -> empty .

    R_BRACKET       reduce using rule 75 (opt_assign_expression -> empty .)


state 209

    (69) assign_expression -> ID . assign_op value_expression
    (71) assign_expression -> ID . unary_op
    (108) assign_op -> . ASSIGN
    (109) assign_op -> . PLUS_ASSIGN
    (110) assign_op -> . MINUS_ASSIGN
    (111) assign_op -> . MUL_ASSIGN
    (112) assign_op -> . DIV_ASSIGN
    (113) assign_op -> . MOD_ASSIGN
    (98) unary_op -> . INCREMENT
    (99) unary_op -> . DECREMENT

    ASSIGN          shift and go to state 152
    PLUS_ASSIGN     shift and go to state 153
    MINUS_ASSIGN    shift and go to state 154
    MUL_ASSIGN      shift and go to state 155
    DIV_ASSIGN      shift and go to state 156
    MOD_ASSIGN      shift and go to state 157
    INCREMENT       shift and go to state 135
    DECREMENT       shift and go to state 136

    assign_op                      shift and go to state 150
    unary_op                       shift and go to state 151

state 210

    (41) else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .

    ELSE            reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    COMMENT         reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    SEMICOLON       reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    RETURN          reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    WHILE           reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    DO              reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    BREAK           reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    FOR             reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    IF              reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    PRINTF          reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    SCANF           reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    CONST           reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    ID              reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    INCREMENT       reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    DECREMENT       reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    INT             reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    FLOAT           reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    DOUBLE          reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    CHAR            reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    BOOL            reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    LONG            reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    VOID            reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    R_BRACE         reduce using rule 41 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)


state 211

    (35) do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .

    COMMENT         reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    RETURN          reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    WHILE           reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    DO              reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    BREAK           reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    FOR             reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    IF              reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    PRINTF          reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    SCANF           reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    CONST           reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    ID              reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    INCREMENT       reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    DECREMENT       reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    INT             reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    FLOAT           reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    DOUBLE          reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    CHAR            reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    BOOL            reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    LONG            reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    VOID            reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    R_BRACE         reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)


state 212

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 86

    statements_block               shift and go to state 213

state 213

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .

    COMMENT         reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    SEMICOLON       reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    RETURN          reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    WHILE           reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    DO              reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    BREAK           reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    FOR             reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    IF              reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    PRINTF          reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    SCANF           reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    CONST           reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    ID              reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    INCREMENT       reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    DECREMENT       reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    INT             reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    FLOAT           reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    DOUBLE          reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    CHAR            reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    BOOL            reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    LONG            reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    VOID            reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    R_BRACE         reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 0 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 0 resolved as shift
WARNING: shift/reduce conflict for LONG in state 0 resolved as shift
WARNING: shift/reduce conflict for VOID in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 3 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 3 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 3 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 3 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 3 resolved as shift
WARNING: shift/reduce conflict for LONG in state 3 resolved as shift
WARNING: shift/reduce conflict for VOID in state 3 resolved as shift
WARNING: shift/reduce conflict for R_BRACKET in state 71 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 82 resolved as shift
WARNING: shift/reduce conflict for AND in state 82 resolved as shift
WARNING: shift/reduce conflict for OR in state 82 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 103 resolved as shift
WARNING: shift/reduce conflict for AND in state 103 resolved as shift
WARNING: shift/reduce conflict for OR in state 103 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 120 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 148 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 171 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 171 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 171 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 171 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 171 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 171 resolved as shift
