Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CASE
    DEFAULT
    SWITCH
    UNSIGNED

Grammar

Rule 0     S' -> s_prim
Rule 1     s_prim -> program
Rule 2     program -> program_component
Rule 3     program -> program_component program
Rule 4     program_component -> declaration_statement
Rule 5     program_component -> function_definition_statement
Rule 6     program_component -> COMMENT
Rule 7     program_component -> PREPROCESSOR_LINE
Rule 8     statement -> any_statement
Rule 9     statement -> COMMENT
Rule 10    statement -> SEMICOLON
Rule 11    statements -> statement
Rule 12    statements -> statement statements
Rule 13    opt_statements -> statements
Rule 14    opt_statements -> empty
Rule 15    statements_block -> L_BRACE opt_statements R_BRACE
Rule 16    any_statement -> declaration_statement
Rule 17    any_statement -> assign_statement
Rule 18    any_statement -> function_statement
Rule 19    any_statement -> return_statement
Rule 20    any_statement -> while_loop_statement
Rule 21    any_statement -> do_while_loop_statement
Rule 22    any_statement -> break_statement
Rule 23    any_statement -> for_loop_statement
Rule 24    any_statement -> if_statement opt_else_if_statements opt_else_statement
Rule 25    any_statement -> print_statement
Rule 26    any_statement -> scan_statement
Rule 27    declaration_statement -> opt_const type ID opt_array_mark
Rule 28    declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
Rule 29    assign_statement -> assign_expression SEMICOLON
Rule 30    function_statement -> function_expression SEMICOLON
Rule 31    return_statement -> RETURN value_expression SEMICOLON
Rule 32    break_statement -> BREAK SEMICOLON
Rule 33    function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block
Rule 34    while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block
Rule 35    do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON
Rule 36    for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block
Rule 37    decl_stat_or_sem -> declaration_statement
Rule 38    decl_stat_or_sem -> SEMICOLON
Rule 39    if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block
Rule 40    else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block
Rule 41    else_if_statements -> else_if_statement
Rule 42    else_if_statements -> else_if_statement else_if_statements
Rule 43    opt_else_if_statements -> else_if_statements
Rule 44    opt_else_if_statements -> empty
Rule 45    else_statement -> ELSE
Rule 46    opt_else_statement -> else_statement
Rule 47    opt_else_statement -> empty
Rule 48    print_statement -> PRINTF L_BRACKET value_expression R_BRACKET
Rule 49    scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET
Rule 50    declaration_value_expression -> value_expression
Rule 51    declaration_value_expression -> L_BRACE listed_values R_BRACE
Rule 52    declaration_value_expression -> L_BRACE declaration_value_expression R_BRACE
Rule 53    value_expression -> math_expression
Rule 54    value_expression -> logical_expression
Rule 55    value_expression -> function_expression
Rule 56    value_expression -> value
Rule 57    value_expression -> trinary_mark_expression
Rule 58    value_expression -> L_BRACKET value_expression R_BRACKET
Rule 59    opt_value_expression -> value_expression
Rule 60    opt_value_expression -> empty
Rule 61    math_expression -> math_expression math_op math_expression
Rule 62    math_expression -> MINUS math_expression
Rule 63    math_expression -> INTEGER
Rule 64    math_expression -> DECIMAL
Rule 65    math_expression -> CHARACTER
Rule 66    math_expression -> ID
Rule 67    math_expression -> L_BRACKET math_expression R_BRACKET
Rule 68    logical_expression -> logical_expression bool_op logical_expression
Rule 69    logical_expression -> NEGATION logical_expression
Rule 70    logical_expression -> value_expression comparison_op value_expression
Rule 71    logical_expression -> value_expression
Rule 72    function_expression -> ID L_BRACKET opt_listed_values R_BRACKET
Rule 73    trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression
Rule 74    assign_expression -> ID assign_op value_expression
Rule 75    assign_expression -> unary_op ID
Rule 76    assign_expression -> ID unary_op
Rule 77    opt_logical_expression -> logical_expression
Rule 78    opt_logical_expression -> empty
Rule 79    opt_assign_expression -> assign_expression
Rule 80    opt_assign_expression -> empty
Rule 81    type -> INT
Rule 82    type -> FLOAT
Rule 83    type -> DOUBLE
Rule 84    type -> CHAR
Rule 85    type -> BOOL
Rule 86    type -> LONG
Rule 87    type -> VOID
Rule 88    value -> INTEGER
Rule 89    value -> DECIMAL
Rule 90    value -> CHARACTER
Rule 91    value -> STRING
Rule 92    value -> TRUE
Rule 93    value -> FALSE
Rule 94    value -> ID
Rule 95    value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
Rule 96    listed_values -> value_expression
Rule 97    listed_values -> listed_values COMMA listed_values
Rule 98    math_op -> PLUS
Rule 99    math_op -> MINUS
Rule 100   math_op -> MUL
Rule 101   math_op -> DIV
Rule 102   math_op -> MOD
Rule 103   unary_op -> INCREMENT
Rule 104   unary_op -> DECREMENT
Rule 105   bool_op -> AND
Rule 106   bool_op -> OR
Rule 107   comparison_op -> EQUAL
Rule 108   comparison_op -> NOT_EQUAL
Rule 109   comparison_op -> GREATER
Rule 110   comparison_op -> GREATER_EQUAL
Rule 111   comparison_op -> LESSER
Rule 112   comparison_op -> LESSER_EQUAL
Rule 113   assign_op -> ASSIGN
Rule 114   assign_op -> PLUS_ASSIGN
Rule 115   assign_op -> MINUS_ASSIGN
Rule 116   assign_op -> MUL_ASSIGN
Rule 117   assign_op -> DIV_ASSIGN
Rule 118   assign_op -> MOD_ASSIGN
Rule 119   array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET
Rule 120   opt_const -> CONST
Rule 121   opt_const -> empty
Rule 122   opt_array_mark -> array_mark
Rule 123   opt_array_mark -> empty
Rule 124   opt_listed_values -> listed_values
Rule 125   opt_listed_values -> empty
Rule 126   args -> type ID
Rule 127   args -> type ID COMMA args
Rule 128   opt_args -> args type ID
Rule 129   opt_args -> empty
Rule 130   empty -> <empty>

Terminals, with rules where they appear

AMPERSAND            : 49
AND                  : 105
ASSIGN               : 28 113
BOOL                 : 85
BREAK                : 32
CASE                 : 
CHAR                 : 84
CHARACTER            : 65 90
COLON                : 73
COMMA                : 97 127
COMMENT              : 6 9
CONST                : 120
DECIMAL              : 64 89
DECREMENT            : 104
DEFAULT              : 
DIV                  : 101
DIV_ASSIGN           : 117
DO                   : 35
DOUBLE               : 83
ELSE                 : 40 45
EQUAL                : 107
FALSE                : 93
FLOAT                : 82
FOR                  : 36
GREATER              : 109
GREATER_EQUAL        : 110
ID                   : 27 28 33 49 66 72 74 75 76 94 95 126 127 128
IF                   : 39 40
INCREMENT            : 103
INT                  : 81
INTEGER              : 63 88
LESSER               : 111
LESSER_EQUAL         : 112
LONG                 : 86
L_BRACE              : 15 51 52
L_BRACKET            : 33 34 35 36 39 40 48 49 58 67 72
L_SQUARE_BRACKET     : 95 119
MINUS                : 62 99
MINUS_ASSIGN         : 115
MOD                  : 102
MOD_ASSIGN           : 118
MUL                  : 100
MUL_ASSIGN           : 116
NEGATION             : 69
NOT_EQUAL            : 108
OR                   : 106
PLUS                 : 98
PLUS_ASSIGN          : 114
PREPROCESSOR_LINE    : 7
PRINTF               : 48
QUESTION_MARK        : 73
RETURN               : 31
R_BRACE              : 15 51 52
R_BRACKET            : 33 34 35 36 39 40 48 49 58 67 72
R_SQUARE_BRACKET     : 95 119
SCANF                : 49
SEMICOLON            : 10 28 29 30 31 32 35 36 38
STRING               : 91
SWITCH               : 
TRUE                 : 92
UNSIGNED             : 
VOID                 : 87
WHILE                : 34 35
error                : 

Nonterminals, with rules where they appear

any_statement        : 8
args                 : 127 128
array_mark           : 122
assign_expression    : 29 79
assign_op            : 74
assign_statement     : 17
bool_op              : 68
break_statement      : 22
comparison_op        : 70
decl_stat_or_sem     : 36
declaration_statement : 4 16 37
declaration_value_expression : 28 52
do_while_loop_statement : 21
else_if_statement    : 41 42
else_if_statements   : 42 43
else_statement       : 46
empty                : 14 44 47 60 78 80 121 123 125 129
for_loop_statement   : 23
function_definition_statement : 5
function_expression  : 30 55
function_statement   : 18
if_statement         : 24
listed_values        : 51 97 97 124
logical_expression   : 34 35 39 40 54 68 68 69 73 77
math_expression      : 53 61 61 62 67
math_op              : 61
opt_args             : 33
opt_array_mark       : 27 28
opt_assign_expression : 36
opt_const            : 27 28
opt_else_if_statements : 24
opt_else_statement   : 24
opt_listed_values    : 72
opt_logical_expression : 36
opt_statements       : 15
opt_value_expression : 119
print_statement      : 25
program              : 1 3
program_component    : 2 3
return_statement     : 19
s_prim               : 0
scan_statement       : 26
statement            : 11 12
statements           : 12 13
statements_block     : 33 34 35 36 39 40
trinary_mark_expression : 57
type                 : 27 28 33 126 127 128
unary_op             : 75 76
value                : 56
value_expression     : 31 48 50 58 59 70 70 71 73 73 74 95 96
while_loop_statement : 20

Parsing method: LALR

state 0

    (0) S' -> . s_prim
    (1) s_prim -> . program
    (2) program -> . program_component
    (3) program -> . program_component program
    (4) program_component -> . declaration_statement
    (5) program_component -> . function_definition_statement
    (6) program_component -> . COMMENT
    (7) program_component -> . PREPROCESSOR_LINE
    (27) declaration_statement -> . opt_const type ID opt_array_mark
    (28) declaration_statement -> . opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (33) function_definition_statement -> . type ID L_BRACKET opt_args R_BRACKET statements_block
    (120) opt_const -> . CONST
    (121) opt_const -> . empty
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . DOUBLE
    (84) type -> . CHAR
    (85) type -> . BOOL
    (86) type -> . LONG
    (87) type -> . VOID
    (130) empty -> .

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LONG resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    COMMENT         shift and go to state 6
    PREPROCESSOR_LINE shift and go to state 7
    CONST           shift and go to state 10
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

  ! INT             [ reduce using rule 130 (empty -> .) ]
  ! FLOAT           [ reduce using rule 130 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 130 (empty -> .) ]
  ! CHAR            [ reduce using rule 130 (empty -> .) ]
  ! BOOL            [ reduce using rule 130 (empty -> .) ]
  ! LONG            [ reduce using rule 130 (empty -> .) ]
  ! VOID            [ reduce using rule 130 (empty -> .) ]

    s_prim                         shift and go to state 1
    program                        shift and go to state 2
    program_component              shift and go to state 3
    declaration_statement          shift and go to state 4
    function_definition_statement  shift and go to state 5
    opt_const                      shift and go to state 8
    type                           shift and go to state 9
    empty                          shift and go to state 11

state 1

    (0) S' -> s_prim .



state 2

    (1) s_prim -> program .

    $end            reduce using rule 1 (s_prim -> program .)


state 3

    (2) program -> program_component .
    (3) program -> program_component . program
    (2) program -> . program_component
    (3) program -> . program_component program
    (4) program_component -> . declaration_statement
    (5) program_component -> . function_definition_statement
    (6) program_component -> . COMMENT
    (7) program_component -> . PREPROCESSOR_LINE
    (27) declaration_statement -> . opt_const type ID opt_array_mark
    (28) declaration_statement -> . opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (33) function_definition_statement -> . type ID L_BRACKET opt_args R_BRACKET statements_block
    (120) opt_const -> . CONST
    (121) opt_const -> . empty
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . DOUBLE
    (84) type -> . CHAR
    (85) type -> . BOOL
    (86) type -> . LONG
    (87) type -> . VOID
    (130) empty -> .

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for LONG resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    $end            reduce using rule 2 (program -> program_component .)
    COMMENT         shift and go to state 6
    PREPROCESSOR_LINE shift and go to state 7
    CONST           shift and go to state 10
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

  ! INT             [ reduce using rule 130 (empty -> .) ]
  ! FLOAT           [ reduce using rule 130 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 130 (empty -> .) ]
  ! CHAR            [ reduce using rule 130 (empty -> .) ]
  ! BOOL            [ reduce using rule 130 (empty -> .) ]
  ! LONG            [ reduce using rule 130 (empty -> .) ]
  ! VOID            [ reduce using rule 130 (empty -> .) ]

    program_component              shift and go to state 3
    program                        shift and go to state 19
    declaration_statement          shift and go to state 4
    function_definition_statement  shift and go to state 5
    opt_const                      shift and go to state 8
    type                           shift and go to state 9
    empty                          shift and go to state 11

state 4

    (4) program_component -> declaration_statement .

    COMMENT         reduce using rule 4 (program_component -> declaration_statement .)
    PREPROCESSOR_LINE reduce using rule 4 (program_component -> declaration_statement .)
    CONST           reduce using rule 4 (program_component -> declaration_statement .)
    INT             reduce using rule 4 (program_component -> declaration_statement .)
    FLOAT           reduce using rule 4 (program_component -> declaration_statement .)
    DOUBLE          reduce using rule 4 (program_component -> declaration_statement .)
    CHAR            reduce using rule 4 (program_component -> declaration_statement .)
    BOOL            reduce using rule 4 (program_component -> declaration_statement .)
    LONG            reduce using rule 4 (program_component -> declaration_statement .)
    VOID            reduce using rule 4 (program_component -> declaration_statement .)
    $end            reduce using rule 4 (program_component -> declaration_statement .)


state 5

    (5) program_component -> function_definition_statement .

    COMMENT         reduce using rule 5 (program_component -> function_definition_statement .)
    PREPROCESSOR_LINE reduce using rule 5 (program_component -> function_definition_statement .)
    CONST           reduce using rule 5 (program_component -> function_definition_statement .)
    INT             reduce using rule 5 (program_component -> function_definition_statement .)
    FLOAT           reduce using rule 5 (program_component -> function_definition_statement .)
    DOUBLE          reduce using rule 5 (program_component -> function_definition_statement .)
    CHAR            reduce using rule 5 (program_component -> function_definition_statement .)
    BOOL            reduce using rule 5 (program_component -> function_definition_statement .)
    LONG            reduce using rule 5 (program_component -> function_definition_statement .)
    VOID            reduce using rule 5 (program_component -> function_definition_statement .)
    $end            reduce using rule 5 (program_component -> function_definition_statement .)


state 6

    (6) program_component -> COMMENT .

    COMMENT         reduce using rule 6 (program_component -> COMMENT .)
    PREPROCESSOR_LINE reduce using rule 6 (program_component -> COMMENT .)
    CONST           reduce using rule 6 (program_component -> COMMENT .)
    INT             reduce using rule 6 (program_component -> COMMENT .)
    FLOAT           reduce using rule 6 (program_component -> COMMENT .)
    DOUBLE          reduce using rule 6 (program_component -> COMMENT .)
    CHAR            reduce using rule 6 (program_component -> COMMENT .)
    BOOL            reduce using rule 6 (program_component -> COMMENT .)
    LONG            reduce using rule 6 (program_component -> COMMENT .)
    VOID            reduce using rule 6 (program_component -> COMMENT .)
    $end            reduce using rule 6 (program_component -> COMMENT .)


state 7

    (7) program_component -> PREPROCESSOR_LINE .

    COMMENT         reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    PREPROCESSOR_LINE reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    CONST           reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    INT             reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    FLOAT           reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    DOUBLE          reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    CHAR            reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    BOOL            reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    LONG            reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    VOID            reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)
    $end            reduce using rule 7 (program_component -> PREPROCESSOR_LINE .)


state 8

    (27) declaration_statement -> opt_const . type ID opt_array_mark
    (28) declaration_statement -> opt_const . type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . DOUBLE
    (84) type -> . CHAR
    (85) type -> . BOOL
    (86) type -> . LONG
    (87) type -> . VOID

    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

    type                           shift and go to state 20

state 9

    (33) function_definition_statement -> type . ID L_BRACKET opt_args R_BRACKET statements_block

    ID              shift and go to state 21


state 10

    (120) opt_const -> CONST .

    INT             reduce using rule 120 (opt_const -> CONST .)
    FLOAT           reduce using rule 120 (opt_const -> CONST .)
    DOUBLE          reduce using rule 120 (opt_const -> CONST .)
    CHAR            reduce using rule 120 (opt_const -> CONST .)
    BOOL            reduce using rule 120 (opt_const -> CONST .)
    LONG            reduce using rule 120 (opt_const -> CONST .)
    VOID            reduce using rule 120 (opt_const -> CONST .)


state 11

    (121) opt_const -> empty .

    INT             reduce using rule 121 (opt_const -> empty .)
    FLOAT           reduce using rule 121 (opt_const -> empty .)
    DOUBLE          reduce using rule 121 (opt_const -> empty .)
    CHAR            reduce using rule 121 (opt_const -> empty .)
    BOOL            reduce using rule 121 (opt_const -> empty .)
    LONG            reduce using rule 121 (opt_const -> empty .)
    VOID            reduce using rule 121 (opt_const -> empty .)


state 12

    (81) type -> INT .

    ID              reduce using rule 81 (type -> INT .)


state 13

    (82) type -> FLOAT .

    ID              reduce using rule 82 (type -> FLOAT .)


state 14

    (83) type -> DOUBLE .

    ID              reduce using rule 83 (type -> DOUBLE .)


state 15

    (84) type -> CHAR .

    ID              reduce using rule 84 (type -> CHAR .)


state 16

    (85) type -> BOOL .

    ID              reduce using rule 85 (type -> BOOL .)


state 17

    (86) type -> LONG .

    ID              reduce using rule 86 (type -> LONG .)


state 18

    (87) type -> VOID .

    ID              reduce using rule 87 (type -> VOID .)


state 19

    (3) program -> program_component program .

    $end            reduce using rule 3 (program -> program_component program .)


state 20

    (27) declaration_statement -> opt_const type . ID opt_array_mark
    (28) declaration_statement -> opt_const type . ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON

    ID              shift and go to state 22


state 21

    (33) function_definition_statement -> type ID . L_BRACKET opt_args R_BRACKET statements_block

    L_BRACKET       shift and go to state 23


state 22

    (27) declaration_statement -> opt_const type ID . opt_array_mark
    (28) declaration_statement -> opt_const type ID . opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (122) opt_array_mark -> . array_mark
    (123) opt_array_mark -> . empty
    (119) array_mark -> . L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET
    (130) empty -> .

    L_SQUARE_BRACKET shift and go to state 27
    ASSIGN          reduce using rule 130 (empty -> .)
    COMMENT         reduce using rule 130 (empty -> .)
    PREPROCESSOR_LINE reduce using rule 130 (empty -> .)
    CONST           reduce using rule 130 (empty -> .)
    INT             reduce using rule 130 (empty -> .)
    FLOAT           reduce using rule 130 (empty -> .)
    DOUBLE          reduce using rule 130 (empty -> .)
    CHAR            reduce using rule 130 (empty -> .)
    BOOL            reduce using rule 130 (empty -> .)
    LONG            reduce using rule 130 (empty -> .)
    VOID            reduce using rule 130 (empty -> .)
    $end            reduce using rule 130 (empty -> .)
    SEMICOLON       reduce using rule 130 (empty -> .)
    RETURN          reduce using rule 130 (empty -> .)
    WHILE           reduce using rule 130 (empty -> .)
    DO              reduce using rule 130 (empty -> .)
    BREAK           reduce using rule 130 (empty -> .)
    FOR             reduce using rule 130 (empty -> .)
    IF              reduce using rule 130 (empty -> .)
    PRINTF          reduce using rule 130 (empty -> .)
    SCANF           reduce using rule 130 (empty -> .)
    ID              reduce using rule 130 (empty -> .)
    INCREMENT       reduce using rule 130 (empty -> .)
    DECREMENT       reduce using rule 130 (empty -> .)
    R_BRACE         reduce using rule 130 (empty -> .)
    NEGATION        reduce using rule 130 (empty -> .)
    L_BRACKET       reduce using rule 130 (empty -> .)
    MINUS           reduce using rule 130 (empty -> .)
    INTEGER         reduce using rule 130 (empty -> .)
    DECIMAL         reduce using rule 130 (empty -> .)
    CHARACTER       reduce using rule 130 (empty -> .)
    STRING          reduce using rule 130 (empty -> .)
    TRUE            reduce using rule 130 (empty -> .)
    FALSE           reduce using rule 130 (empty -> .)

    opt_array_mark                 shift and go to state 24
    array_mark                     shift and go to state 25
    empty                          shift and go to state 26

state 23

    (33) function_definition_statement -> type ID L_BRACKET . opt_args R_BRACKET statements_block
    (128) opt_args -> . args type ID
    (129) opt_args -> . empty
    (126) args -> . type ID
    (127) args -> . type ID COMMA args
    (130) empty -> .
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . DOUBLE
    (84) type -> . CHAR
    (85) type -> . BOOL
    (86) type -> . LONG
    (87) type -> . VOID

    R_BRACKET       reduce using rule 130 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

    type                           shift and go to state 28
    opt_args                       shift and go to state 29
    args                           shift and go to state 30
    empty                          shift and go to state 31

state 24

    (27) declaration_statement -> opt_const type ID opt_array_mark .
    (28) declaration_statement -> opt_const type ID opt_array_mark . ASSIGN declaration_value_expression SEMICOLON

    COMMENT         reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    PREPROCESSOR_LINE reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    CONST           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    INT             reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    FLOAT           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    DOUBLE          reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    CHAR            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    BOOL            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    LONG            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    VOID            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    $end            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    SEMICOLON       reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    RETURN          reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    WHILE           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    DO              reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    BREAK           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    FOR             reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    IF              reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    PRINTF          reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    SCANF           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    ID              reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    INCREMENT       reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    DECREMENT       reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    R_BRACE         reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    NEGATION        reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    L_BRACKET       reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    MINUS           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    INTEGER         reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    DECIMAL         reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    CHARACTER       reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    STRING          reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    TRUE            reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    FALSE           reduce using rule 27 (declaration_statement -> opt_const type ID opt_array_mark .)
    ASSIGN          shift and go to state 32


state 25

    (122) opt_array_mark -> array_mark .

    ASSIGN          reduce using rule 122 (opt_array_mark -> array_mark .)
    COMMENT         reduce using rule 122 (opt_array_mark -> array_mark .)
    PREPROCESSOR_LINE reduce using rule 122 (opt_array_mark -> array_mark .)
    CONST           reduce using rule 122 (opt_array_mark -> array_mark .)
    INT             reduce using rule 122 (opt_array_mark -> array_mark .)
    FLOAT           reduce using rule 122 (opt_array_mark -> array_mark .)
    DOUBLE          reduce using rule 122 (opt_array_mark -> array_mark .)
    CHAR            reduce using rule 122 (opt_array_mark -> array_mark .)
    BOOL            reduce using rule 122 (opt_array_mark -> array_mark .)
    LONG            reduce using rule 122 (opt_array_mark -> array_mark .)
    VOID            reduce using rule 122 (opt_array_mark -> array_mark .)
    $end            reduce using rule 122 (opt_array_mark -> array_mark .)
    SEMICOLON       reduce using rule 122 (opt_array_mark -> array_mark .)
    RETURN          reduce using rule 122 (opt_array_mark -> array_mark .)
    WHILE           reduce using rule 122 (opt_array_mark -> array_mark .)
    DO              reduce using rule 122 (opt_array_mark -> array_mark .)
    BREAK           reduce using rule 122 (opt_array_mark -> array_mark .)
    FOR             reduce using rule 122 (opt_array_mark -> array_mark .)
    IF              reduce using rule 122 (opt_array_mark -> array_mark .)
    PRINTF          reduce using rule 122 (opt_array_mark -> array_mark .)
    SCANF           reduce using rule 122 (opt_array_mark -> array_mark .)
    ID              reduce using rule 122 (opt_array_mark -> array_mark .)
    INCREMENT       reduce using rule 122 (opt_array_mark -> array_mark .)
    DECREMENT       reduce using rule 122 (opt_array_mark -> array_mark .)
    R_BRACE         reduce using rule 122 (opt_array_mark -> array_mark .)
    NEGATION        reduce using rule 122 (opt_array_mark -> array_mark .)
    L_BRACKET       reduce using rule 122 (opt_array_mark -> array_mark .)
    MINUS           reduce using rule 122 (opt_array_mark -> array_mark .)
    INTEGER         reduce using rule 122 (opt_array_mark -> array_mark .)
    DECIMAL         reduce using rule 122 (opt_array_mark -> array_mark .)
    CHARACTER       reduce using rule 122 (opt_array_mark -> array_mark .)
    STRING          reduce using rule 122 (opt_array_mark -> array_mark .)
    TRUE            reduce using rule 122 (opt_array_mark -> array_mark .)
    FALSE           reduce using rule 122 (opt_array_mark -> array_mark .)


state 26

    (123) opt_array_mark -> empty .

    ASSIGN          reduce using rule 123 (opt_array_mark -> empty .)
    COMMENT         reduce using rule 123 (opt_array_mark -> empty .)
    PREPROCESSOR_LINE reduce using rule 123 (opt_array_mark -> empty .)
    CONST           reduce using rule 123 (opt_array_mark -> empty .)
    INT             reduce using rule 123 (opt_array_mark -> empty .)
    FLOAT           reduce using rule 123 (opt_array_mark -> empty .)
    DOUBLE          reduce using rule 123 (opt_array_mark -> empty .)
    CHAR            reduce using rule 123 (opt_array_mark -> empty .)
    BOOL            reduce using rule 123 (opt_array_mark -> empty .)
    LONG            reduce using rule 123 (opt_array_mark -> empty .)
    VOID            reduce using rule 123 (opt_array_mark -> empty .)
    $end            reduce using rule 123 (opt_array_mark -> empty .)
    SEMICOLON       reduce using rule 123 (opt_array_mark -> empty .)
    RETURN          reduce using rule 123 (opt_array_mark -> empty .)
    WHILE           reduce using rule 123 (opt_array_mark -> empty .)
    DO              reduce using rule 123 (opt_array_mark -> empty .)
    BREAK           reduce using rule 123 (opt_array_mark -> empty .)
    FOR             reduce using rule 123 (opt_array_mark -> empty .)
    IF              reduce using rule 123 (opt_array_mark -> empty .)
    PRINTF          reduce using rule 123 (opt_array_mark -> empty .)
    SCANF           reduce using rule 123 (opt_array_mark -> empty .)
    ID              reduce using rule 123 (opt_array_mark -> empty .)
    INCREMENT       reduce using rule 123 (opt_array_mark -> empty .)
    DECREMENT       reduce using rule 123 (opt_array_mark -> empty .)
    R_BRACE         reduce using rule 123 (opt_array_mark -> empty .)
    NEGATION        reduce using rule 123 (opt_array_mark -> empty .)
    L_BRACKET       reduce using rule 123 (opt_array_mark -> empty .)
    MINUS           reduce using rule 123 (opt_array_mark -> empty .)
    INTEGER         reduce using rule 123 (opt_array_mark -> empty .)
    DECIMAL         reduce using rule 123 (opt_array_mark -> empty .)
    CHARACTER       reduce using rule 123 (opt_array_mark -> empty .)
    STRING          reduce using rule 123 (opt_array_mark -> empty .)
    TRUE            reduce using rule 123 (opt_array_mark -> empty .)
    FALSE           reduce using rule 123 (opt_array_mark -> empty .)


state 27

    (119) array_mark -> L_SQUARE_BRACKET . opt_value_expression R_SQUARE_BRACKET
    (59) opt_value_expression -> . value_expression
    (60) opt_value_expression -> . empty
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (130) empty -> .
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    L_BRACKET       shift and go to state 41
    R_SQUARE_BRACKET reduce using rule 130 (empty -> .)
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    NEGATION        shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    opt_value_expression           shift and go to state 33
    value_expression               shift and go to state 34
    empty                          shift and go to state 35
    math_expression                shift and go to state 36
    logical_expression             shift and go to state 37
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 28

    (126) args -> type . ID
    (127) args -> type . ID COMMA args

    ID              shift and go to state 51


state 29

    (33) function_definition_statement -> type ID L_BRACKET opt_args . R_BRACKET statements_block

    R_BRACKET       shift and go to state 52


state 30

    (128) opt_args -> args . type ID
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . DOUBLE
    (84) type -> . CHAR
    (85) type -> . BOOL
    (86) type -> . LONG
    (87) type -> . VOID

    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

    type                           shift and go to state 53

state 31

    (129) opt_args -> empty .

    R_BRACKET       reduce using rule 129 (opt_args -> empty .)


state 32

    (28) declaration_statement -> opt_const type ID opt_array_mark ASSIGN . declaration_value_expression SEMICOLON
    (50) declaration_value_expression -> . value_expression
    (51) declaration_value_expression -> . L_BRACE listed_values R_BRACE
    (52) declaration_value_expression -> . L_BRACE declaration_value_expression R_BRACE
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    L_BRACE         shift and go to state 56
    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    NEGATION        shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    declaration_value_expression   shift and go to state 54
    value_expression               shift and go to state 55
    math_expression                shift and go to state 36
    logical_expression             shift and go to state 37
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 33

    (119) array_mark -> L_SQUARE_BRACKET opt_value_expression . R_SQUARE_BRACKET

    R_SQUARE_BRACKET shift and go to state 57


state 34

    (59) opt_value_expression -> value_expression .
    (70) logical_expression -> value_expression . comparison_op value_expression
    (71) logical_expression -> value_expression .
    (107) comparison_op -> . EQUAL
    (108) comparison_op -> . NOT_EQUAL
    (109) comparison_op -> . GREATER
    (110) comparison_op -> . GREATER_EQUAL
    (111) comparison_op -> . LESSER
    (112) comparison_op -> . LESSER_EQUAL

  ! reduce/reduce conflict for R_SQUARE_BRACKET resolved using rule 59 (opt_value_expression -> value_expression .)
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
    R_SQUARE_BRACKET reduce using rule 59 (opt_value_expression -> value_expression .)
    QUESTION_MARK   reduce using rule 71 (logical_expression -> value_expression .)
    AND             reduce using rule 71 (logical_expression -> value_expression .)
    OR              reduce using rule 71 (logical_expression -> value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

  ! EQUAL           [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER         [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER          [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! R_SQUARE_BRACKET [ reduce using rule 71 (logical_expression -> value_expression .) ]

    comparison_op                  shift and go to state 58

state 35

    (60) opt_value_expression -> empty .

    R_SQUARE_BRACKET reduce using rule 60 (opt_value_expression -> empty .)


state 36

    (53) value_expression -> math_expression .
    (61) math_expression -> math_expression . math_op math_expression
    (98) math_op -> . PLUS
    (99) math_op -> . MINUS
    (100) math_op -> . MUL
    (101) math_op -> . DIV
    (102) math_op -> . MOD

    EQUAL           reduce using rule 53 (value_expression -> math_expression .)
    NOT_EQUAL       reduce using rule 53 (value_expression -> math_expression .)
    GREATER         reduce using rule 53 (value_expression -> math_expression .)
    GREATER_EQUAL   reduce using rule 53 (value_expression -> math_expression .)
    LESSER          reduce using rule 53 (value_expression -> math_expression .)
    LESSER_EQUAL    reduce using rule 53 (value_expression -> math_expression .)
    R_SQUARE_BRACKET reduce using rule 53 (value_expression -> math_expression .)
    QUESTION_MARK   reduce using rule 53 (value_expression -> math_expression .)
    AND             reduce using rule 53 (value_expression -> math_expression .)
    OR              reduce using rule 53 (value_expression -> math_expression .)
    SEMICOLON       reduce using rule 53 (value_expression -> math_expression .)
    R_BRACKET       reduce using rule 53 (value_expression -> math_expression .)
    R_BRACE         reduce using rule 53 (value_expression -> math_expression .)
    COMMA           reduce using rule 53 (value_expression -> math_expression .)
    COLON           reduce using rule 53 (value_expression -> math_expression .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    MUL             shift and go to state 68
    DIV             shift and go to state 69
    MOD             shift and go to state 70

    math_op                        shift and go to state 65

state 37

    (54) value_expression -> logical_expression .
    (68) logical_expression -> logical_expression . bool_op logical_expression
    (73) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (105) bool_op -> . AND
    (106) bool_op -> . OR

  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    EQUAL           reduce using rule 54 (value_expression -> logical_expression .)
    NOT_EQUAL       reduce using rule 54 (value_expression -> logical_expression .)
    GREATER         reduce using rule 54 (value_expression -> logical_expression .)
    GREATER_EQUAL   reduce using rule 54 (value_expression -> logical_expression .)
    LESSER          reduce using rule 54 (value_expression -> logical_expression .)
    LESSER_EQUAL    reduce using rule 54 (value_expression -> logical_expression .)
    R_SQUARE_BRACKET reduce using rule 54 (value_expression -> logical_expression .)
    SEMICOLON       reduce using rule 54 (value_expression -> logical_expression .)
    R_BRACKET       reduce using rule 54 (value_expression -> logical_expression .)
    R_BRACE         reduce using rule 54 (value_expression -> logical_expression .)
    COMMA           reduce using rule 54 (value_expression -> logical_expression .)
    COLON           reduce using rule 54 (value_expression -> logical_expression .)
    QUESTION_MARK   shift and go to state 72
    AND             shift and go to state 73
    OR              shift and go to state 74

  ! QUESTION_MARK   [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! AND             [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! OR              [ reduce using rule 54 (value_expression -> logical_expression .) ]

    bool_op                        shift and go to state 71

state 38

    (55) value_expression -> function_expression .

    EQUAL           reduce using rule 55 (value_expression -> function_expression .)
    NOT_EQUAL       reduce using rule 55 (value_expression -> function_expression .)
    GREATER         reduce using rule 55 (value_expression -> function_expression .)
    GREATER_EQUAL   reduce using rule 55 (value_expression -> function_expression .)
    LESSER          reduce using rule 55 (value_expression -> function_expression .)
    LESSER_EQUAL    reduce using rule 55 (value_expression -> function_expression .)
    R_SQUARE_BRACKET reduce using rule 55 (value_expression -> function_expression .)
    QUESTION_MARK   reduce using rule 55 (value_expression -> function_expression .)
    AND             reduce using rule 55 (value_expression -> function_expression .)
    OR              reduce using rule 55 (value_expression -> function_expression .)
    SEMICOLON       reduce using rule 55 (value_expression -> function_expression .)
    R_BRACKET       reduce using rule 55 (value_expression -> function_expression .)
    R_BRACE         reduce using rule 55 (value_expression -> function_expression .)
    COMMA           reduce using rule 55 (value_expression -> function_expression .)
    COLON           reduce using rule 55 (value_expression -> function_expression .)


state 39

    (56) value_expression -> value .

    EQUAL           reduce using rule 56 (value_expression -> value .)
    NOT_EQUAL       reduce using rule 56 (value_expression -> value .)
    GREATER         reduce using rule 56 (value_expression -> value .)
    GREATER_EQUAL   reduce using rule 56 (value_expression -> value .)
    LESSER          reduce using rule 56 (value_expression -> value .)
    LESSER_EQUAL    reduce using rule 56 (value_expression -> value .)
    R_SQUARE_BRACKET reduce using rule 56 (value_expression -> value .)
    QUESTION_MARK   reduce using rule 56 (value_expression -> value .)
    AND             reduce using rule 56 (value_expression -> value .)
    OR              reduce using rule 56 (value_expression -> value .)
    SEMICOLON       reduce using rule 56 (value_expression -> value .)
    R_BRACKET       reduce using rule 56 (value_expression -> value .)
    R_BRACE         reduce using rule 56 (value_expression -> value .)
    COMMA           reduce using rule 56 (value_expression -> value .)
    COLON           reduce using rule 56 (value_expression -> value .)


state 40

    (57) value_expression -> trinary_mark_expression .

    EQUAL           reduce using rule 57 (value_expression -> trinary_mark_expression .)
    NOT_EQUAL       reduce using rule 57 (value_expression -> trinary_mark_expression .)
    GREATER         reduce using rule 57 (value_expression -> trinary_mark_expression .)
    GREATER_EQUAL   reduce using rule 57 (value_expression -> trinary_mark_expression .)
    LESSER          reduce using rule 57 (value_expression -> trinary_mark_expression .)
    LESSER_EQUAL    reduce using rule 57 (value_expression -> trinary_mark_expression .)
    R_SQUARE_BRACKET reduce using rule 57 (value_expression -> trinary_mark_expression .)
    QUESTION_MARK   reduce using rule 57 (value_expression -> trinary_mark_expression .)
    AND             reduce using rule 57 (value_expression -> trinary_mark_expression .)
    OR              reduce using rule 57 (value_expression -> trinary_mark_expression .)
    SEMICOLON       reduce using rule 57 (value_expression -> trinary_mark_expression .)
    R_BRACKET       reduce using rule 57 (value_expression -> trinary_mark_expression .)
    R_BRACE         reduce using rule 57 (value_expression -> trinary_mark_expression .)
    COMMA           reduce using rule 57 (value_expression -> trinary_mark_expression .)
    COLON           reduce using rule 57 (value_expression -> trinary_mark_expression .)


state 41

    (58) value_expression -> L_BRACKET . value_expression R_BRACKET
    (67) math_expression -> L_BRACKET . math_expression R_BRACKET
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    NEGATION        shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    value_expression               shift and go to state 75
    math_expression                shift and go to state 76
    logical_expression             shift and go to state 37
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 42

    (62) math_expression -> MINUS . math_expression
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET

    MINUS           shift and go to state 42
    INTEGER         shift and go to state 78
    DECIMAL         shift and go to state 79
    CHARACTER       shift and go to state 80
    ID              shift and go to state 81
    L_BRACKET       shift and go to state 82

    math_expression                shift and go to state 77

state 43

    (63) math_expression -> INTEGER .
    (88) value -> INTEGER .

  ! reduce/reduce conflict for EQUAL resolved using rule 63 (math_expression -> INTEGER .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 63 (math_expression -> INTEGER .)
  ! reduce/reduce conflict for GREATER resolved using rule 63 (math_expression -> INTEGER .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 63 (math_expression -> INTEGER .)
  ! reduce/reduce conflict for LESSER resolved using rule 63 (math_expression -> INTEGER .)
  ! reduce/reduce conflict for LESSER_EQUAL resolved using rule 63 (math_expression -> INTEGER .)
  ! reduce/reduce conflict for R_SQUARE_BRACKET resolved using rule 63 (math_expression -> INTEGER .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 63 (math_expression -> INTEGER .)
  ! reduce/reduce conflict for AND resolved using rule 63 (math_expression -> INTEGER .)
  ! reduce/reduce conflict for OR resolved using rule 63 (math_expression -> INTEGER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 63 (math_expression -> INTEGER .)
  ! reduce/reduce conflict for R_BRACKET resolved using rule 63 (math_expression -> INTEGER .)
  ! reduce/reduce conflict for R_BRACE resolved using rule 63 (math_expression -> INTEGER .)
  ! reduce/reduce conflict for COMMA resolved using rule 63 (math_expression -> INTEGER .)
  ! reduce/reduce conflict for COLON resolved using rule 63 (math_expression -> INTEGER .)
    PLUS            reduce using rule 63 (math_expression -> INTEGER .)
    MINUS           reduce using rule 63 (math_expression -> INTEGER .)
    MUL             reduce using rule 63 (math_expression -> INTEGER .)
    DIV             reduce using rule 63 (math_expression -> INTEGER .)
    MOD             reduce using rule 63 (math_expression -> INTEGER .)
    EQUAL           reduce using rule 63 (math_expression -> INTEGER .)
    NOT_EQUAL       reduce using rule 63 (math_expression -> INTEGER .)
    GREATER         reduce using rule 63 (math_expression -> INTEGER .)
    GREATER_EQUAL   reduce using rule 63 (math_expression -> INTEGER .)
    LESSER          reduce using rule 63 (math_expression -> INTEGER .)
    LESSER_EQUAL    reduce using rule 63 (math_expression -> INTEGER .)
    R_SQUARE_BRACKET reduce using rule 63 (math_expression -> INTEGER .)
    QUESTION_MARK   reduce using rule 63 (math_expression -> INTEGER .)
    AND             reduce using rule 63 (math_expression -> INTEGER .)
    OR              reduce using rule 63 (math_expression -> INTEGER .)
    SEMICOLON       reduce using rule 63 (math_expression -> INTEGER .)
    R_BRACKET       reduce using rule 63 (math_expression -> INTEGER .)
    R_BRACE         reduce using rule 63 (math_expression -> INTEGER .)
    COMMA           reduce using rule 63 (math_expression -> INTEGER .)
    COLON           reduce using rule 63 (math_expression -> INTEGER .)

  ! EQUAL           [ reduce using rule 88 (value -> INTEGER .) ]
  ! NOT_EQUAL       [ reduce using rule 88 (value -> INTEGER .) ]
  ! GREATER         [ reduce using rule 88 (value -> INTEGER .) ]
  ! GREATER_EQUAL   [ reduce using rule 88 (value -> INTEGER .) ]
  ! LESSER          [ reduce using rule 88 (value -> INTEGER .) ]
  ! LESSER_EQUAL    [ reduce using rule 88 (value -> INTEGER .) ]
  ! R_SQUARE_BRACKET [ reduce using rule 88 (value -> INTEGER .) ]
  ! QUESTION_MARK   [ reduce using rule 88 (value -> INTEGER .) ]
  ! AND             [ reduce using rule 88 (value -> INTEGER .) ]
  ! OR              [ reduce using rule 88 (value -> INTEGER .) ]
  ! SEMICOLON       [ reduce using rule 88 (value -> INTEGER .) ]
  ! R_BRACKET       [ reduce using rule 88 (value -> INTEGER .) ]
  ! R_BRACE         [ reduce using rule 88 (value -> INTEGER .) ]
  ! COMMA           [ reduce using rule 88 (value -> INTEGER .) ]
  ! COLON           [ reduce using rule 88 (value -> INTEGER .) ]


state 44

    (64) math_expression -> DECIMAL .
    (89) value -> DECIMAL .

  ! reduce/reduce conflict for EQUAL resolved using rule 64 (math_expression -> DECIMAL .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 64 (math_expression -> DECIMAL .)
  ! reduce/reduce conflict for GREATER resolved using rule 64 (math_expression -> DECIMAL .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 64 (math_expression -> DECIMAL .)
  ! reduce/reduce conflict for LESSER resolved using rule 64 (math_expression -> DECIMAL .)
  ! reduce/reduce conflict for LESSER_EQUAL resolved using rule 64 (math_expression -> DECIMAL .)
  ! reduce/reduce conflict for R_SQUARE_BRACKET resolved using rule 64 (math_expression -> DECIMAL .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 64 (math_expression -> DECIMAL .)
  ! reduce/reduce conflict for AND resolved using rule 64 (math_expression -> DECIMAL .)
  ! reduce/reduce conflict for OR resolved using rule 64 (math_expression -> DECIMAL .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 64 (math_expression -> DECIMAL .)
  ! reduce/reduce conflict for R_BRACKET resolved using rule 64 (math_expression -> DECIMAL .)
  ! reduce/reduce conflict for R_BRACE resolved using rule 64 (math_expression -> DECIMAL .)
  ! reduce/reduce conflict for COMMA resolved using rule 64 (math_expression -> DECIMAL .)
  ! reduce/reduce conflict for COLON resolved using rule 64 (math_expression -> DECIMAL .)
    PLUS            reduce using rule 64 (math_expression -> DECIMAL .)
    MINUS           reduce using rule 64 (math_expression -> DECIMAL .)
    MUL             reduce using rule 64 (math_expression -> DECIMAL .)
    DIV             reduce using rule 64 (math_expression -> DECIMAL .)
    MOD             reduce using rule 64 (math_expression -> DECIMAL .)
    EQUAL           reduce using rule 64 (math_expression -> DECIMAL .)
    NOT_EQUAL       reduce using rule 64 (math_expression -> DECIMAL .)
    GREATER         reduce using rule 64 (math_expression -> DECIMAL .)
    GREATER_EQUAL   reduce using rule 64 (math_expression -> DECIMAL .)
    LESSER          reduce using rule 64 (math_expression -> DECIMAL .)
    LESSER_EQUAL    reduce using rule 64 (math_expression -> DECIMAL .)
    R_SQUARE_BRACKET reduce using rule 64 (math_expression -> DECIMAL .)
    QUESTION_MARK   reduce using rule 64 (math_expression -> DECIMAL .)
    AND             reduce using rule 64 (math_expression -> DECIMAL .)
    OR              reduce using rule 64 (math_expression -> DECIMAL .)
    SEMICOLON       reduce using rule 64 (math_expression -> DECIMAL .)
    R_BRACKET       reduce using rule 64 (math_expression -> DECIMAL .)
    R_BRACE         reduce using rule 64 (math_expression -> DECIMAL .)
    COMMA           reduce using rule 64 (math_expression -> DECIMAL .)
    COLON           reduce using rule 64 (math_expression -> DECIMAL .)

  ! EQUAL           [ reduce using rule 89 (value -> DECIMAL .) ]
  ! NOT_EQUAL       [ reduce using rule 89 (value -> DECIMAL .) ]
  ! GREATER         [ reduce using rule 89 (value -> DECIMAL .) ]
  ! GREATER_EQUAL   [ reduce using rule 89 (value -> DECIMAL .) ]
  ! LESSER          [ reduce using rule 89 (value -> DECIMAL .) ]
  ! LESSER_EQUAL    [ reduce using rule 89 (value -> DECIMAL .) ]
  ! R_SQUARE_BRACKET [ reduce using rule 89 (value -> DECIMAL .) ]
  ! QUESTION_MARK   [ reduce using rule 89 (value -> DECIMAL .) ]
  ! AND             [ reduce using rule 89 (value -> DECIMAL .) ]
  ! OR              [ reduce using rule 89 (value -> DECIMAL .) ]
  ! SEMICOLON       [ reduce using rule 89 (value -> DECIMAL .) ]
  ! R_BRACKET       [ reduce using rule 89 (value -> DECIMAL .) ]
  ! R_BRACE         [ reduce using rule 89 (value -> DECIMAL .) ]
  ! COMMA           [ reduce using rule 89 (value -> DECIMAL .) ]
  ! COLON           [ reduce using rule 89 (value -> DECIMAL .) ]


state 45

    (65) math_expression -> CHARACTER .
    (90) value -> CHARACTER .

  ! reduce/reduce conflict for EQUAL resolved using rule 65 (math_expression -> CHARACTER .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 65 (math_expression -> CHARACTER .)
  ! reduce/reduce conflict for GREATER resolved using rule 65 (math_expression -> CHARACTER .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 65 (math_expression -> CHARACTER .)
  ! reduce/reduce conflict for LESSER resolved using rule 65 (math_expression -> CHARACTER .)
  ! reduce/reduce conflict for LESSER_EQUAL resolved using rule 65 (math_expression -> CHARACTER .)
  ! reduce/reduce conflict for R_SQUARE_BRACKET resolved using rule 65 (math_expression -> CHARACTER .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 65 (math_expression -> CHARACTER .)
  ! reduce/reduce conflict for AND resolved using rule 65 (math_expression -> CHARACTER .)
  ! reduce/reduce conflict for OR resolved using rule 65 (math_expression -> CHARACTER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 65 (math_expression -> CHARACTER .)
  ! reduce/reduce conflict for R_BRACKET resolved using rule 65 (math_expression -> CHARACTER .)
  ! reduce/reduce conflict for R_BRACE resolved using rule 65 (math_expression -> CHARACTER .)
  ! reduce/reduce conflict for COMMA resolved using rule 65 (math_expression -> CHARACTER .)
  ! reduce/reduce conflict for COLON resolved using rule 65 (math_expression -> CHARACTER .)
    PLUS            reduce using rule 65 (math_expression -> CHARACTER .)
    MINUS           reduce using rule 65 (math_expression -> CHARACTER .)
    MUL             reduce using rule 65 (math_expression -> CHARACTER .)
    DIV             reduce using rule 65 (math_expression -> CHARACTER .)
    MOD             reduce using rule 65 (math_expression -> CHARACTER .)
    EQUAL           reduce using rule 65 (math_expression -> CHARACTER .)
    NOT_EQUAL       reduce using rule 65 (math_expression -> CHARACTER .)
    GREATER         reduce using rule 65 (math_expression -> CHARACTER .)
    GREATER_EQUAL   reduce using rule 65 (math_expression -> CHARACTER .)
    LESSER          reduce using rule 65 (math_expression -> CHARACTER .)
    LESSER_EQUAL    reduce using rule 65 (math_expression -> CHARACTER .)
    R_SQUARE_BRACKET reduce using rule 65 (math_expression -> CHARACTER .)
    QUESTION_MARK   reduce using rule 65 (math_expression -> CHARACTER .)
    AND             reduce using rule 65 (math_expression -> CHARACTER .)
    OR              reduce using rule 65 (math_expression -> CHARACTER .)
    SEMICOLON       reduce using rule 65 (math_expression -> CHARACTER .)
    R_BRACKET       reduce using rule 65 (math_expression -> CHARACTER .)
    R_BRACE         reduce using rule 65 (math_expression -> CHARACTER .)
    COMMA           reduce using rule 65 (math_expression -> CHARACTER .)
    COLON           reduce using rule 65 (math_expression -> CHARACTER .)

  ! EQUAL           [ reduce using rule 90 (value -> CHARACTER .) ]
  ! NOT_EQUAL       [ reduce using rule 90 (value -> CHARACTER .) ]
  ! GREATER         [ reduce using rule 90 (value -> CHARACTER .) ]
  ! GREATER_EQUAL   [ reduce using rule 90 (value -> CHARACTER .) ]
  ! LESSER          [ reduce using rule 90 (value -> CHARACTER .) ]
  ! LESSER_EQUAL    [ reduce using rule 90 (value -> CHARACTER .) ]
  ! R_SQUARE_BRACKET [ reduce using rule 90 (value -> CHARACTER .) ]
  ! QUESTION_MARK   [ reduce using rule 90 (value -> CHARACTER .) ]
  ! AND             [ reduce using rule 90 (value -> CHARACTER .) ]
  ! OR              [ reduce using rule 90 (value -> CHARACTER .) ]
  ! SEMICOLON       [ reduce using rule 90 (value -> CHARACTER .) ]
  ! R_BRACKET       [ reduce using rule 90 (value -> CHARACTER .) ]
  ! R_BRACE         [ reduce using rule 90 (value -> CHARACTER .) ]
  ! COMMA           [ reduce using rule 90 (value -> CHARACTER .) ]
  ! COLON           [ reduce using rule 90 (value -> CHARACTER .) ]


state 46

    (66) math_expression -> ID .
    (72) function_expression -> ID . L_BRACKET opt_listed_values R_BRACKET
    (94) value -> ID .
    (95) value -> ID . L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET

  ! reduce/reduce conflict for EQUAL resolved using rule 66 (math_expression -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 66 (math_expression -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 66 (math_expression -> ID .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 66 (math_expression -> ID .)
  ! reduce/reduce conflict for LESSER resolved using rule 66 (math_expression -> ID .)
  ! reduce/reduce conflict for LESSER_EQUAL resolved using rule 66 (math_expression -> ID .)
  ! reduce/reduce conflict for R_SQUARE_BRACKET resolved using rule 66 (math_expression -> ID .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 66 (math_expression -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 66 (math_expression -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 66 (math_expression -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 66 (math_expression -> ID .)
  ! reduce/reduce conflict for R_BRACKET resolved using rule 66 (math_expression -> ID .)
  ! reduce/reduce conflict for R_BRACE resolved using rule 66 (math_expression -> ID .)
  ! reduce/reduce conflict for COMMA resolved using rule 66 (math_expression -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 66 (math_expression -> ID .)
    PLUS            reduce using rule 66 (math_expression -> ID .)
    MINUS           reduce using rule 66 (math_expression -> ID .)
    MUL             reduce using rule 66 (math_expression -> ID .)
    DIV             reduce using rule 66 (math_expression -> ID .)
    MOD             reduce using rule 66 (math_expression -> ID .)
    EQUAL           reduce using rule 66 (math_expression -> ID .)
    NOT_EQUAL       reduce using rule 66 (math_expression -> ID .)
    GREATER         reduce using rule 66 (math_expression -> ID .)
    GREATER_EQUAL   reduce using rule 66 (math_expression -> ID .)
    LESSER          reduce using rule 66 (math_expression -> ID .)
    LESSER_EQUAL    reduce using rule 66 (math_expression -> ID .)
    R_SQUARE_BRACKET reduce using rule 66 (math_expression -> ID .)
    QUESTION_MARK   reduce using rule 66 (math_expression -> ID .)
    AND             reduce using rule 66 (math_expression -> ID .)
    OR              reduce using rule 66 (math_expression -> ID .)
    SEMICOLON       reduce using rule 66 (math_expression -> ID .)
    R_BRACKET       reduce using rule 66 (math_expression -> ID .)
    R_BRACE         reduce using rule 66 (math_expression -> ID .)
    COMMA           reduce using rule 66 (math_expression -> ID .)
    COLON           reduce using rule 66 (math_expression -> ID .)
    L_BRACKET       shift and go to state 83
    L_SQUARE_BRACKET shift and go to state 84

  ! EQUAL           [ reduce using rule 94 (value -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 94 (value -> ID .) ]
  ! GREATER         [ reduce using rule 94 (value -> ID .) ]
  ! GREATER_EQUAL   [ reduce using rule 94 (value -> ID .) ]
  ! LESSER          [ reduce using rule 94 (value -> ID .) ]
  ! LESSER_EQUAL    [ reduce using rule 94 (value -> ID .) ]
  ! R_SQUARE_BRACKET [ reduce using rule 94 (value -> ID .) ]
  ! QUESTION_MARK   [ reduce using rule 94 (value -> ID .) ]
  ! AND             [ reduce using rule 94 (value -> ID .) ]
  ! OR              [ reduce using rule 94 (value -> ID .) ]
  ! SEMICOLON       [ reduce using rule 94 (value -> ID .) ]
  ! R_BRACKET       [ reduce using rule 94 (value -> ID .) ]
  ! R_BRACE         [ reduce using rule 94 (value -> ID .) ]
  ! COMMA           [ reduce using rule 94 (value -> ID .) ]
  ! COLON           [ reduce using rule 94 (value -> ID .) ]


state 47

    (69) logical_expression -> NEGATION . logical_expression
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    NEGATION        shift and go to state 47
    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    logical_expression             shift and go to state 85
    value_expression               shift and go to state 86
    math_expression                shift and go to state 36
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 48

    (91) value -> STRING .

    EQUAL           reduce using rule 91 (value -> STRING .)
    NOT_EQUAL       reduce using rule 91 (value -> STRING .)
    GREATER         reduce using rule 91 (value -> STRING .)
    GREATER_EQUAL   reduce using rule 91 (value -> STRING .)
    LESSER          reduce using rule 91 (value -> STRING .)
    LESSER_EQUAL    reduce using rule 91 (value -> STRING .)
    R_SQUARE_BRACKET reduce using rule 91 (value -> STRING .)
    QUESTION_MARK   reduce using rule 91 (value -> STRING .)
    AND             reduce using rule 91 (value -> STRING .)
    OR              reduce using rule 91 (value -> STRING .)
    SEMICOLON       reduce using rule 91 (value -> STRING .)
    R_BRACKET       reduce using rule 91 (value -> STRING .)
    R_BRACE         reduce using rule 91 (value -> STRING .)
    COMMA           reduce using rule 91 (value -> STRING .)
    COLON           reduce using rule 91 (value -> STRING .)


state 49

    (92) value -> TRUE .

    EQUAL           reduce using rule 92 (value -> TRUE .)
    NOT_EQUAL       reduce using rule 92 (value -> TRUE .)
    GREATER         reduce using rule 92 (value -> TRUE .)
    GREATER_EQUAL   reduce using rule 92 (value -> TRUE .)
    LESSER          reduce using rule 92 (value -> TRUE .)
    LESSER_EQUAL    reduce using rule 92 (value -> TRUE .)
    R_SQUARE_BRACKET reduce using rule 92 (value -> TRUE .)
    QUESTION_MARK   reduce using rule 92 (value -> TRUE .)
    AND             reduce using rule 92 (value -> TRUE .)
    OR              reduce using rule 92 (value -> TRUE .)
    SEMICOLON       reduce using rule 92 (value -> TRUE .)
    R_BRACKET       reduce using rule 92 (value -> TRUE .)
    R_BRACE         reduce using rule 92 (value -> TRUE .)
    COMMA           reduce using rule 92 (value -> TRUE .)
    COLON           reduce using rule 92 (value -> TRUE .)


state 50

    (93) value -> FALSE .

    EQUAL           reduce using rule 93 (value -> FALSE .)
    NOT_EQUAL       reduce using rule 93 (value -> FALSE .)
    GREATER         reduce using rule 93 (value -> FALSE .)
    GREATER_EQUAL   reduce using rule 93 (value -> FALSE .)
    LESSER          reduce using rule 93 (value -> FALSE .)
    LESSER_EQUAL    reduce using rule 93 (value -> FALSE .)
    R_SQUARE_BRACKET reduce using rule 93 (value -> FALSE .)
    QUESTION_MARK   reduce using rule 93 (value -> FALSE .)
    AND             reduce using rule 93 (value -> FALSE .)
    OR              reduce using rule 93 (value -> FALSE .)
    SEMICOLON       reduce using rule 93 (value -> FALSE .)
    R_BRACKET       reduce using rule 93 (value -> FALSE .)
    R_BRACE         reduce using rule 93 (value -> FALSE .)
    COMMA           reduce using rule 93 (value -> FALSE .)
    COLON           reduce using rule 93 (value -> FALSE .)


state 51

    (126) args -> type ID .
    (127) args -> type ID . COMMA args

    INT             reduce using rule 126 (args -> type ID .)
    FLOAT           reduce using rule 126 (args -> type ID .)
    DOUBLE          reduce using rule 126 (args -> type ID .)
    CHAR            reduce using rule 126 (args -> type ID .)
    BOOL            reduce using rule 126 (args -> type ID .)
    LONG            reduce using rule 126 (args -> type ID .)
    VOID            reduce using rule 126 (args -> type ID .)
    COMMA           shift and go to state 87


state 52

    (33) function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 89

    statements_block               shift and go to state 88

state 53

    (128) opt_args -> args type . ID

    ID              shift and go to state 90


state 54

    (28) declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression . SEMICOLON

    SEMICOLON       shift and go to state 91


state 55

    (50) declaration_value_expression -> value_expression .
    (70) logical_expression -> value_expression . comparison_op value_expression
    (71) logical_expression -> value_expression .
    (107) comparison_op -> . EQUAL
    (108) comparison_op -> . NOT_EQUAL
    (109) comparison_op -> . GREATER
    (110) comparison_op -> . GREATER_EQUAL
    (111) comparison_op -> . LESSER
    (112) comparison_op -> . LESSER_EQUAL

  ! reduce/reduce conflict for SEMICOLON resolved using rule 50 (declaration_value_expression -> value_expression .)
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
    SEMICOLON       reduce using rule 50 (declaration_value_expression -> value_expression .)
    QUESTION_MARK   reduce using rule 71 (logical_expression -> value_expression .)
    AND             reduce using rule 71 (logical_expression -> value_expression .)
    OR              reduce using rule 71 (logical_expression -> value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

  ! EQUAL           [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER         [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER          [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! SEMICOLON       [ reduce using rule 71 (logical_expression -> value_expression .) ]

    comparison_op                  shift and go to state 58

state 56

    (51) declaration_value_expression -> L_BRACE . listed_values R_BRACE
    (52) declaration_value_expression -> L_BRACE . declaration_value_expression R_BRACE
    (96) listed_values -> . value_expression
    (97) listed_values -> . listed_values COMMA listed_values
    (50) declaration_value_expression -> . value_expression
    (51) declaration_value_expression -> . L_BRACE listed_values R_BRACE
    (52) declaration_value_expression -> . L_BRACE declaration_value_expression R_BRACE
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    L_BRACE         shift and go to state 56
    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    NEGATION        shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    listed_values                  shift and go to state 92
    declaration_value_expression   shift and go to state 93
    value_expression               shift and go to state 94
    math_expression                shift and go to state 36
    logical_expression             shift and go to state 37
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 57

    (119) array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .

    ASSIGN          reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    COMMENT         reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    PREPROCESSOR_LINE reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    CONST           reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    INT             reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    FLOAT           reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    DOUBLE          reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    CHAR            reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    BOOL            reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    LONG            reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    VOID            reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    $end            reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    SEMICOLON       reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    RETURN          reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    WHILE           reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    DO              reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    BREAK           reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    FOR             reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    IF              reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    PRINTF          reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    SCANF           reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    ID              reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    INCREMENT       reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    DECREMENT       reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    R_BRACE         reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    NEGATION        reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    L_BRACKET       reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    MINUS           reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    INTEGER         reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    DECIMAL         reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    CHARACTER       reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    STRING          reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    TRUE            reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)
    FALSE           reduce using rule 119 (array_mark -> L_SQUARE_BRACKET opt_value_expression R_SQUARE_BRACKET .)


state 58

    (70) logical_expression -> value_expression comparison_op . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    NEGATION        shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    value_expression               shift and go to state 95
    math_expression                shift and go to state 36
    logical_expression             shift and go to state 37
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 59

    (107) comparison_op -> EQUAL .

    L_BRACKET       reduce using rule 107 (comparison_op -> EQUAL .)
    MINUS           reduce using rule 107 (comparison_op -> EQUAL .)
    INTEGER         reduce using rule 107 (comparison_op -> EQUAL .)
    DECIMAL         reduce using rule 107 (comparison_op -> EQUAL .)
    CHARACTER       reduce using rule 107 (comparison_op -> EQUAL .)
    ID              reduce using rule 107 (comparison_op -> EQUAL .)
    NEGATION        reduce using rule 107 (comparison_op -> EQUAL .)
    STRING          reduce using rule 107 (comparison_op -> EQUAL .)
    TRUE            reduce using rule 107 (comparison_op -> EQUAL .)
    FALSE           reduce using rule 107 (comparison_op -> EQUAL .)


state 60

    (108) comparison_op -> NOT_EQUAL .

    L_BRACKET       reduce using rule 108 (comparison_op -> NOT_EQUAL .)
    MINUS           reduce using rule 108 (comparison_op -> NOT_EQUAL .)
    INTEGER         reduce using rule 108 (comparison_op -> NOT_EQUAL .)
    DECIMAL         reduce using rule 108 (comparison_op -> NOT_EQUAL .)
    CHARACTER       reduce using rule 108 (comparison_op -> NOT_EQUAL .)
    ID              reduce using rule 108 (comparison_op -> NOT_EQUAL .)
    NEGATION        reduce using rule 108 (comparison_op -> NOT_EQUAL .)
    STRING          reduce using rule 108 (comparison_op -> NOT_EQUAL .)
    TRUE            reduce using rule 108 (comparison_op -> NOT_EQUAL .)
    FALSE           reduce using rule 108 (comparison_op -> NOT_EQUAL .)


state 61

    (109) comparison_op -> GREATER .

    L_BRACKET       reduce using rule 109 (comparison_op -> GREATER .)
    MINUS           reduce using rule 109 (comparison_op -> GREATER .)
    INTEGER         reduce using rule 109 (comparison_op -> GREATER .)
    DECIMAL         reduce using rule 109 (comparison_op -> GREATER .)
    CHARACTER       reduce using rule 109 (comparison_op -> GREATER .)
    ID              reduce using rule 109 (comparison_op -> GREATER .)
    NEGATION        reduce using rule 109 (comparison_op -> GREATER .)
    STRING          reduce using rule 109 (comparison_op -> GREATER .)
    TRUE            reduce using rule 109 (comparison_op -> GREATER .)
    FALSE           reduce using rule 109 (comparison_op -> GREATER .)


state 62

    (110) comparison_op -> GREATER_EQUAL .

    L_BRACKET       reduce using rule 110 (comparison_op -> GREATER_EQUAL .)
    MINUS           reduce using rule 110 (comparison_op -> GREATER_EQUAL .)
    INTEGER         reduce using rule 110 (comparison_op -> GREATER_EQUAL .)
    DECIMAL         reduce using rule 110 (comparison_op -> GREATER_EQUAL .)
    CHARACTER       reduce using rule 110 (comparison_op -> GREATER_EQUAL .)
    ID              reduce using rule 110 (comparison_op -> GREATER_EQUAL .)
    NEGATION        reduce using rule 110 (comparison_op -> GREATER_EQUAL .)
    STRING          reduce using rule 110 (comparison_op -> GREATER_EQUAL .)
    TRUE            reduce using rule 110 (comparison_op -> GREATER_EQUAL .)
    FALSE           reduce using rule 110 (comparison_op -> GREATER_EQUAL .)


state 63

    (111) comparison_op -> LESSER .

    L_BRACKET       reduce using rule 111 (comparison_op -> LESSER .)
    MINUS           reduce using rule 111 (comparison_op -> LESSER .)
    INTEGER         reduce using rule 111 (comparison_op -> LESSER .)
    DECIMAL         reduce using rule 111 (comparison_op -> LESSER .)
    CHARACTER       reduce using rule 111 (comparison_op -> LESSER .)
    ID              reduce using rule 111 (comparison_op -> LESSER .)
    NEGATION        reduce using rule 111 (comparison_op -> LESSER .)
    STRING          reduce using rule 111 (comparison_op -> LESSER .)
    TRUE            reduce using rule 111 (comparison_op -> LESSER .)
    FALSE           reduce using rule 111 (comparison_op -> LESSER .)


state 64

    (112) comparison_op -> LESSER_EQUAL .

    L_BRACKET       reduce using rule 112 (comparison_op -> LESSER_EQUAL .)
    MINUS           reduce using rule 112 (comparison_op -> LESSER_EQUAL .)
    INTEGER         reduce using rule 112 (comparison_op -> LESSER_EQUAL .)
    DECIMAL         reduce using rule 112 (comparison_op -> LESSER_EQUAL .)
    CHARACTER       reduce using rule 112 (comparison_op -> LESSER_EQUAL .)
    ID              reduce using rule 112 (comparison_op -> LESSER_EQUAL .)
    NEGATION        reduce using rule 112 (comparison_op -> LESSER_EQUAL .)
    STRING          reduce using rule 112 (comparison_op -> LESSER_EQUAL .)
    TRUE            reduce using rule 112 (comparison_op -> LESSER_EQUAL .)
    FALSE           reduce using rule 112 (comparison_op -> LESSER_EQUAL .)


state 65

    (61) math_expression -> math_expression math_op . math_expression
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET

    MINUS           shift and go to state 42
    INTEGER         shift and go to state 78
    DECIMAL         shift and go to state 79
    CHARACTER       shift and go to state 80
    ID              shift and go to state 81
    L_BRACKET       shift and go to state 82

    math_expression                shift and go to state 96

state 66

    (98) math_op -> PLUS .

    MINUS           reduce using rule 98 (math_op -> PLUS .)
    INTEGER         reduce using rule 98 (math_op -> PLUS .)
    DECIMAL         reduce using rule 98 (math_op -> PLUS .)
    CHARACTER       reduce using rule 98 (math_op -> PLUS .)
    ID              reduce using rule 98 (math_op -> PLUS .)
    L_BRACKET       reduce using rule 98 (math_op -> PLUS .)


state 67

    (99) math_op -> MINUS .

    MINUS           reduce using rule 99 (math_op -> MINUS .)
    INTEGER         reduce using rule 99 (math_op -> MINUS .)
    DECIMAL         reduce using rule 99 (math_op -> MINUS .)
    CHARACTER       reduce using rule 99 (math_op -> MINUS .)
    ID              reduce using rule 99 (math_op -> MINUS .)
    L_BRACKET       reduce using rule 99 (math_op -> MINUS .)


state 68

    (100) math_op -> MUL .

    MINUS           reduce using rule 100 (math_op -> MUL .)
    INTEGER         reduce using rule 100 (math_op -> MUL .)
    DECIMAL         reduce using rule 100 (math_op -> MUL .)
    CHARACTER       reduce using rule 100 (math_op -> MUL .)
    ID              reduce using rule 100 (math_op -> MUL .)
    L_BRACKET       reduce using rule 100 (math_op -> MUL .)


state 69

    (101) math_op -> DIV .

    MINUS           reduce using rule 101 (math_op -> DIV .)
    INTEGER         reduce using rule 101 (math_op -> DIV .)
    DECIMAL         reduce using rule 101 (math_op -> DIV .)
    CHARACTER       reduce using rule 101 (math_op -> DIV .)
    ID              reduce using rule 101 (math_op -> DIV .)
    L_BRACKET       reduce using rule 101 (math_op -> DIV .)


state 70

    (102) math_op -> MOD .

    MINUS           reduce using rule 102 (math_op -> MOD .)
    INTEGER         reduce using rule 102 (math_op -> MOD .)
    DECIMAL         reduce using rule 102 (math_op -> MOD .)
    CHARACTER       reduce using rule 102 (math_op -> MOD .)
    ID              reduce using rule 102 (math_op -> MOD .)
    L_BRACKET       reduce using rule 102 (math_op -> MOD .)


state 71

    (68) logical_expression -> logical_expression bool_op . logical_expression
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    NEGATION        shift and go to state 47
    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    logical_expression             shift and go to state 97
    value_expression               shift and go to state 86
    math_expression                shift and go to state 36
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 72

    (73) trinary_mark_expression -> logical_expression QUESTION_MARK . value_expression COLON value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    NEGATION        shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    logical_expression             shift and go to state 37
    value_expression               shift and go to state 98
    math_expression                shift and go to state 36
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 73

    (105) bool_op -> AND .

    NEGATION        reduce using rule 105 (bool_op -> AND .)
    L_BRACKET       reduce using rule 105 (bool_op -> AND .)
    MINUS           reduce using rule 105 (bool_op -> AND .)
    INTEGER         reduce using rule 105 (bool_op -> AND .)
    DECIMAL         reduce using rule 105 (bool_op -> AND .)
    CHARACTER       reduce using rule 105 (bool_op -> AND .)
    ID              reduce using rule 105 (bool_op -> AND .)
    STRING          reduce using rule 105 (bool_op -> AND .)
    TRUE            reduce using rule 105 (bool_op -> AND .)
    FALSE           reduce using rule 105 (bool_op -> AND .)


state 74

    (106) bool_op -> OR .

    NEGATION        reduce using rule 106 (bool_op -> OR .)
    L_BRACKET       reduce using rule 106 (bool_op -> OR .)
    MINUS           reduce using rule 106 (bool_op -> OR .)
    INTEGER         reduce using rule 106 (bool_op -> OR .)
    DECIMAL         reduce using rule 106 (bool_op -> OR .)
    CHARACTER       reduce using rule 106 (bool_op -> OR .)
    ID              reduce using rule 106 (bool_op -> OR .)
    STRING          reduce using rule 106 (bool_op -> OR .)
    TRUE            reduce using rule 106 (bool_op -> OR .)
    FALSE           reduce using rule 106 (bool_op -> OR .)


state 75

    (58) value_expression -> L_BRACKET value_expression . R_BRACKET
    (70) logical_expression -> value_expression . comparison_op value_expression
    (71) logical_expression -> value_expression .
    (107) comparison_op -> . EQUAL
    (108) comparison_op -> . NOT_EQUAL
    (109) comparison_op -> . GREATER
    (110) comparison_op -> . GREATER_EQUAL
    (111) comparison_op -> . LESSER
    (112) comparison_op -> . LESSER_EQUAL

  ! shift/reduce conflict for R_BRACKET resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
    R_BRACKET       shift and go to state 99
    QUESTION_MARK   reduce using rule 71 (logical_expression -> value_expression .)
    AND             reduce using rule 71 (logical_expression -> value_expression .)
    OR              reduce using rule 71 (logical_expression -> value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

  ! R_BRACKET       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! EQUAL           [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER         [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER          [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 71 (logical_expression -> value_expression .) ]

    comparison_op                  shift and go to state 58

state 76

    (67) math_expression -> L_BRACKET math_expression . R_BRACKET
    (53) value_expression -> math_expression .
    (61) math_expression -> math_expression . math_op math_expression
    (98) math_op -> . PLUS
    (99) math_op -> . MINUS
    (100) math_op -> . MUL
    (101) math_op -> . DIV
    (102) math_op -> . MOD

  ! shift/reduce conflict for R_BRACKET resolved as shift
    R_BRACKET       shift and go to state 100
    EQUAL           reduce using rule 53 (value_expression -> math_expression .)
    NOT_EQUAL       reduce using rule 53 (value_expression -> math_expression .)
    GREATER         reduce using rule 53 (value_expression -> math_expression .)
    GREATER_EQUAL   reduce using rule 53 (value_expression -> math_expression .)
    LESSER          reduce using rule 53 (value_expression -> math_expression .)
    LESSER_EQUAL    reduce using rule 53 (value_expression -> math_expression .)
    QUESTION_MARK   reduce using rule 53 (value_expression -> math_expression .)
    AND             reduce using rule 53 (value_expression -> math_expression .)
    OR              reduce using rule 53 (value_expression -> math_expression .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    MUL             shift and go to state 68
    DIV             shift and go to state 69
    MOD             shift and go to state 70

  ! R_BRACKET       [ reduce using rule 53 (value_expression -> math_expression .) ]

    math_op                        shift and go to state 65

state 77

    (62) math_expression -> MINUS math_expression .
    (61) math_expression -> math_expression . math_op math_expression
    (98) math_op -> . PLUS
    (99) math_op -> . MINUS
    (100) math_op -> . MUL
    (101) math_op -> . DIV
    (102) math_op -> . MOD

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
    EQUAL           reduce using rule 62 (math_expression -> MINUS math_expression .)
    NOT_EQUAL       reduce using rule 62 (math_expression -> MINUS math_expression .)
    GREATER         reduce using rule 62 (math_expression -> MINUS math_expression .)
    GREATER_EQUAL   reduce using rule 62 (math_expression -> MINUS math_expression .)
    LESSER          reduce using rule 62 (math_expression -> MINUS math_expression .)
    LESSER_EQUAL    reduce using rule 62 (math_expression -> MINUS math_expression .)
    R_SQUARE_BRACKET reduce using rule 62 (math_expression -> MINUS math_expression .)
    QUESTION_MARK   reduce using rule 62 (math_expression -> MINUS math_expression .)
    AND             reduce using rule 62 (math_expression -> MINUS math_expression .)
    OR              reduce using rule 62 (math_expression -> MINUS math_expression .)
    SEMICOLON       reduce using rule 62 (math_expression -> MINUS math_expression .)
    R_BRACKET       reduce using rule 62 (math_expression -> MINUS math_expression .)
    R_BRACE         reduce using rule 62 (math_expression -> MINUS math_expression .)
    COMMA           reduce using rule 62 (math_expression -> MINUS math_expression .)
    COLON           reduce using rule 62 (math_expression -> MINUS math_expression .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    MUL             shift and go to state 68
    DIV             shift and go to state 69
    MOD             shift and go to state 70

  ! PLUS            [ reduce using rule 62 (math_expression -> MINUS math_expression .) ]
  ! MINUS           [ reduce using rule 62 (math_expression -> MINUS math_expression .) ]
  ! MUL             [ reduce using rule 62 (math_expression -> MINUS math_expression .) ]
  ! DIV             [ reduce using rule 62 (math_expression -> MINUS math_expression .) ]
  ! MOD             [ reduce using rule 62 (math_expression -> MINUS math_expression .) ]

    math_op                        shift and go to state 65

state 78

    (63) math_expression -> INTEGER .

    PLUS            reduce using rule 63 (math_expression -> INTEGER .)
    MINUS           reduce using rule 63 (math_expression -> INTEGER .)
    MUL             reduce using rule 63 (math_expression -> INTEGER .)
    DIV             reduce using rule 63 (math_expression -> INTEGER .)
    MOD             reduce using rule 63 (math_expression -> INTEGER .)
    EQUAL           reduce using rule 63 (math_expression -> INTEGER .)
    NOT_EQUAL       reduce using rule 63 (math_expression -> INTEGER .)
    GREATER         reduce using rule 63 (math_expression -> INTEGER .)
    GREATER_EQUAL   reduce using rule 63 (math_expression -> INTEGER .)
    LESSER          reduce using rule 63 (math_expression -> INTEGER .)
    LESSER_EQUAL    reduce using rule 63 (math_expression -> INTEGER .)
    R_SQUARE_BRACKET reduce using rule 63 (math_expression -> INTEGER .)
    QUESTION_MARK   reduce using rule 63 (math_expression -> INTEGER .)
    AND             reduce using rule 63 (math_expression -> INTEGER .)
    OR              reduce using rule 63 (math_expression -> INTEGER .)
    SEMICOLON       reduce using rule 63 (math_expression -> INTEGER .)
    R_BRACKET       reduce using rule 63 (math_expression -> INTEGER .)
    R_BRACE         reduce using rule 63 (math_expression -> INTEGER .)
    COMMA           reduce using rule 63 (math_expression -> INTEGER .)
    COLON           reduce using rule 63 (math_expression -> INTEGER .)


state 79

    (64) math_expression -> DECIMAL .

    PLUS            reduce using rule 64 (math_expression -> DECIMAL .)
    MINUS           reduce using rule 64 (math_expression -> DECIMAL .)
    MUL             reduce using rule 64 (math_expression -> DECIMAL .)
    DIV             reduce using rule 64 (math_expression -> DECIMAL .)
    MOD             reduce using rule 64 (math_expression -> DECIMAL .)
    EQUAL           reduce using rule 64 (math_expression -> DECIMAL .)
    NOT_EQUAL       reduce using rule 64 (math_expression -> DECIMAL .)
    GREATER         reduce using rule 64 (math_expression -> DECIMAL .)
    GREATER_EQUAL   reduce using rule 64 (math_expression -> DECIMAL .)
    LESSER          reduce using rule 64 (math_expression -> DECIMAL .)
    LESSER_EQUAL    reduce using rule 64 (math_expression -> DECIMAL .)
    R_SQUARE_BRACKET reduce using rule 64 (math_expression -> DECIMAL .)
    QUESTION_MARK   reduce using rule 64 (math_expression -> DECIMAL .)
    AND             reduce using rule 64 (math_expression -> DECIMAL .)
    OR              reduce using rule 64 (math_expression -> DECIMAL .)
    SEMICOLON       reduce using rule 64 (math_expression -> DECIMAL .)
    R_BRACKET       reduce using rule 64 (math_expression -> DECIMAL .)
    R_BRACE         reduce using rule 64 (math_expression -> DECIMAL .)
    COMMA           reduce using rule 64 (math_expression -> DECIMAL .)
    COLON           reduce using rule 64 (math_expression -> DECIMAL .)


state 80

    (65) math_expression -> CHARACTER .

    PLUS            reduce using rule 65 (math_expression -> CHARACTER .)
    MINUS           reduce using rule 65 (math_expression -> CHARACTER .)
    MUL             reduce using rule 65 (math_expression -> CHARACTER .)
    DIV             reduce using rule 65 (math_expression -> CHARACTER .)
    MOD             reduce using rule 65 (math_expression -> CHARACTER .)
    EQUAL           reduce using rule 65 (math_expression -> CHARACTER .)
    NOT_EQUAL       reduce using rule 65 (math_expression -> CHARACTER .)
    GREATER         reduce using rule 65 (math_expression -> CHARACTER .)
    GREATER_EQUAL   reduce using rule 65 (math_expression -> CHARACTER .)
    LESSER          reduce using rule 65 (math_expression -> CHARACTER .)
    LESSER_EQUAL    reduce using rule 65 (math_expression -> CHARACTER .)
    R_SQUARE_BRACKET reduce using rule 65 (math_expression -> CHARACTER .)
    QUESTION_MARK   reduce using rule 65 (math_expression -> CHARACTER .)
    AND             reduce using rule 65 (math_expression -> CHARACTER .)
    OR              reduce using rule 65 (math_expression -> CHARACTER .)
    SEMICOLON       reduce using rule 65 (math_expression -> CHARACTER .)
    R_BRACKET       reduce using rule 65 (math_expression -> CHARACTER .)
    R_BRACE         reduce using rule 65 (math_expression -> CHARACTER .)
    COMMA           reduce using rule 65 (math_expression -> CHARACTER .)
    COLON           reduce using rule 65 (math_expression -> CHARACTER .)


state 81

    (66) math_expression -> ID .

    PLUS            reduce using rule 66 (math_expression -> ID .)
    MINUS           reduce using rule 66 (math_expression -> ID .)
    MUL             reduce using rule 66 (math_expression -> ID .)
    DIV             reduce using rule 66 (math_expression -> ID .)
    MOD             reduce using rule 66 (math_expression -> ID .)
    EQUAL           reduce using rule 66 (math_expression -> ID .)
    NOT_EQUAL       reduce using rule 66 (math_expression -> ID .)
    GREATER         reduce using rule 66 (math_expression -> ID .)
    GREATER_EQUAL   reduce using rule 66 (math_expression -> ID .)
    LESSER          reduce using rule 66 (math_expression -> ID .)
    LESSER_EQUAL    reduce using rule 66 (math_expression -> ID .)
    R_SQUARE_BRACKET reduce using rule 66 (math_expression -> ID .)
    QUESTION_MARK   reduce using rule 66 (math_expression -> ID .)
    AND             reduce using rule 66 (math_expression -> ID .)
    OR              reduce using rule 66 (math_expression -> ID .)
    SEMICOLON       reduce using rule 66 (math_expression -> ID .)
    R_BRACKET       reduce using rule 66 (math_expression -> ID .)
    R_BRACE         reduce using rule 66 (math_expression -> ID .)
    COMMA           reduce using rule 66 (math_expression -> ID .)
    COLON           reduce using rule 66 (math_expression -> ID .)


state 82

    (67) math_expression -> L_BRACKET . math_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET

    MINUS           shift and go to state 42
    INTEGER         shift and go to state 78
    DECIMAL         shift and go to state 79
    CHARACTER       shift and go to state 80
    ID              shift and go to state 81
    L_BRACKET       shift and go to state 82

    math_expression                shift and go to state 101

state 83

    (72) function_expression -> ID L_BRACKET . opt_listed_values R_BRACKET
    (124) opt_listed_values -> . listed_values
    (125) opt_listed_values -> . empty
    (96) listed_values -> . value_expression
    (97) listed_values -> . listed_values COMMA listed_values
    (130) empty -> .
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    R_BRACKET       reduce using rule 130 (empty -> .)
    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    NEGATION        shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    opt_listed_values              shift and go to state 102
    listed_values                  shift and go to state 103
    empty                          shift and go to state 104
    value_expression               shift and go to state 105
    math_expression                shift and go to state 36
    logical_expression             shift and go to state 37
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 84

    (95) value -> ID L_SQUARE_BRACKET . value_expression R_SQUARE_BRACKET
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    NEGATION        shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    value_expression               shift and go to state 106
    math_expression                shift and go to state 36
    logical_expression             shift and go to state 37
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 85

    (69) logical_expression -> NEGATION logical_expression .
    (68) logical_expression -> logical_expression . bool_op logical_expression
    (54) value_expression -> logical_expression .
    (73) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (105) bool_op -> . AND
    (106) bool_op -> . OR

  ! reduce/reduce conflict for EQUAL resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for GREATER resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for LESSER resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for LESSER_EQUAL resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for AND resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for OR resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for R_SQUARE_BRACKET resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for R_BRACKET resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for R_BRACE resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for COLON resolved using rule 54 (value_expression -> logical_expression .)
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    EQUAL           reduce using rule 54 (value_expression -> logical_expression .)
    NOT_EQUAL       reduce using rule 54 (value_expression -> logical_expression .)
    GREATER         reduce using rule 54 (value_expression -> logical_expression .)
    GREATER_EQUAL   reduce using rule 54 (value_expression -> logical_expression .)
    LESSER          reduce using rule 54 (value_expression -> logical_expression .)
    LESSER_EQUAL    reduce using rule 54 (value_expression -> logical_expression .)
    R_SQUARE_BRACKET reduce using rule 54 (value_expression -> logical_expression .)
    SEMICOLON       reduce using rule 54 (value_expression -> logical_expression .)
    R_BRACKET       reduce using rule 54 (value_expression -> logical_expression .)
    R_BRACE         reduce using rule 54 (value_expression -> logical_expression .)
    COMMA           reduce using rule 54 (value_expression -> logical_expression .)
    COLON           reduce using rule 54 (value_expression -> logical_expression .)
    QUESTION_MARK   shift and go to state 72
    AND             shift and go to state 73
    OR              shift and go to state 74

  ! EQUAL           [ reduce using rule 69 (logical_expression -> NEGATION logical_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 69 (logical_expression -> NEGATION logical_expression .) ]
  ! GREATER         [ reduce using rule 69 (logical_expression -> NEGATION logical_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 69 (logical_expression -> NEGATION logical_expression .) ]
  ! LESSER          [ reduce using rule 69 (logical_expression -> NEGATION logical_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 69 (logical_expression -> NEGATION logical_expression .) ]
  ! R_SQUARE_BRACKET [ reduce using rule 69 (logical_expression -> NEGATION logical_expression .) ]
  ! QUESTION_MARK   [ reduce using rule 69 (logical_expression -> NEGATION logical_expression .) ]
  ! AND             [ reduce using rule 69 (logical_expression -> NEGATION logical_expression .) ]
  ! OR              [ reduce using rule 69 (logical_expression -> NEGATION logical_expression .) ]
  ! SEMICOLON       [ reduce using rule 69 (logical_expression -> NEGATION logical_expression .) ]
  ! R_BRACKET       [ reduce using rule 69 (logical_expression -> NEGATION logical_expression .) ]
  ! R_BRACE         [ reduce using rule 69 (logical_expression -> NEGATION logical_expression .) ]
  ! COMMA           [ reduce using rule 69 (logical_expression -> NEGATION logical_expression .) ]
  ! COLON           [ reduce using rule 69 (logical_expression -> NEGATION logical_expression .) ]
  ! QUESTION_MARK   [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! AND             [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! OR              [ reduce using rule 54 (value_expression -> logical_expression .) ]

    bool_op                        shift and go to state 71

state 86

    (70) logical_expression -> value_expression . comparison_op value_expression
    (71) logical_expression -> value_expression .
    (107) comparison_op -> . EQUAL
    (108) comparison_op -> . NOT_EQUAL
    (109) comparison_op -> . GREATER
    (110) comparison_op -> . GREATER_EQUAL
    (111) comparison_op -> . LESSER
    (112) comparison_op -> . LESSER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
    QUESTION_MARK   reduce using rule 71 (logical_expression -> value_expression .)
    AND             reduce using rule 71 (logical_expression -> value_expression .)
    OR              reduce using rule 71 (logical_expression -> value_expression .)
    R_SQUARE_BRACKET reduce using rule 71 (logical_expression -> value_expression .)
    SEMICOLON       reduce using rule 71 (logical_expression -> value_expression .)
    R_BRACKET       reduce using rule 71 (logical_expression -> value_expression .)
    R_BRACE         reduce using rule 71 (logical_expression -> value_expression .)
    COMMA           reduce using rule 71 (logical_expression -> value_expression .)
    COLON           reduce using rule 71 (logical_expression -> value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

  ! EQUAL           [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER         [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER          [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 71 (logical_expression -> value_expression .) ]

    comparison_op                  shift and go to state 58

state 87

    (127) args -> type ID COMMA . args
    (126) args -> . type ID
    (127) args -> . type ID COMMA args
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . DOUBLE
    (84) type -> . CHAR
    (85) type -> . BOOL
    (86) type -> . LONG
    (87) type -> . VOID

    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    CHAR            shift and go to state 15
    BOOL            shift and go to state 16
    LONG            shift and go to state 17
    VOID            shift and go to state 18

    type                           shift and go to state 28
    args                           shift and go to state 107

state 88

    (33) function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .

    COMMENT         reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    PREPROCESSOR_LINE reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    CONST           reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    INT             reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    FLOAT           reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    DOUBLE          reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    CHAR            reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    BOOL            reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    LONG            reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    VOID            reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)
    $end            reduce using rule 33 (function_definition_statement -> type ID L_BRACKET opt_args R_BRACKET statements_block .)


state 89

    (15) statements_block -> L_BRACE . opt_statements R_BRACE
    (13) opt_statements -> . statements
    (14) opt_statements -> . empty
    (11) statements -> . statement
    (12) statements -> . statement statements
    (130) empty -> .
    (8) statement -> . any_statement
    (9) statement -> . COMMENT
    (10) statement -> . SEMICOLON
    (16) any_statement -> . declaration_statement
    (17) any_statement -> . assign_statement
    (18) any_statement -> . function_statement
    (19) any_statement -> . return_statement
    (20) any_statement -> . while_loop_statement
    (21) any_statement -> . do_while_loop_statement
    (22) any_statement -> . break_statement
    (23) any_statement -> . for_loop_statement
    (24) any_statement -> . if_statement opt_else_if_statements opt_else_statement
    (25) any_statement -> . print_statement
    (26) any_statement -> . scan_statement
    (27) declaration_statement -> . opt_const type ID opt_array_mark
    (28) declaration_statement -> . opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (29) assign_statement -> . assign_expression SEMICOLON
    (30) function_statement -> . function_expression SEMICOLON
    (31) return_statement -> . RETURN value_expression SEMICOLON
    (34) while_loop_statement -> . WHILE L_BRACKET logical_expression R_BRACKET statements_block
    (35) do_while_loop_statement -> . DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON
    (32) break_statement -> . BREAK SEMICOLON
    (36) for_loop_statement -> . FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block
    (39) if_statement -> . IF L_BRACKET logical_expression R_BRACKET statements_block
    (48) print_statement -> . PRINTF L_BRACKET value_expression R_BRACKET
    (49) scan_statement -> . SCANF L_BRACKET AMPERSAND ID R_BRACKET
    (120) opt_const -> . CONST
    (121) opt_const -> . empty
    (74) assign_expression -> . ID assign_op value_expression
    (75) assign_expression -> . unary_op ID
    (76) assign_expression -> . ID unary_op
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (103) unary_op -> . INCREMENT
    (104) unary_op -> . DECREMENT

    R_BRACE         reduce using rule 130 (empty -> .)
    INT             reduce using rule 130 (empty -> .)
    FLOAT           reduce using rule 130 (empty -> .)
    DOUBLE          reduce using rule 130 (empty -> .)
    CHAR            reduce using rule 130 (empty -> .)
    BOOL            reduce using rule 130 (empty -> .)
    LONG            reduce using rule 130 (empty -> .)
    VOID            reduce using rule 130 (empty -> .)
    COMMENT         shift and go to state 113
    SEMICOLON       shift and go to state 114
    RETURN          shift and go to state 129
    WHILE           shift and go to state 130
    DO              shift and go to state 131
    BREAK           shift and go to state 132
    FOR             shift and go to state 133
    IF              shift and go to state 134
    PRINTF          shift and go to state 135
    SCANF           shift and go to state 136
    CONST           shift and go to state 10
    ID              shift and go to state 126
    INCREMENT       shift and go to state 138
    DECREMENT       shift and go to state 139

    opt_statements                 shift and go to state 108
    statements                     shift and go to state 109
    empty                          shift and go to state 110
    statement                      shift and go to state 111
    any_statement                  shift and go to state 112
    declaration_statement          shift and go to state 115
    assign_statement               shift and go to state 116
    function_statement             shift and go to state 117
    return_statement               shift and go to state 118
    while_loop_statement           shift and go to state 119
    do_while_loop_statement        shift and go to state 120
    break_statement                shift and go to state 121
    for_loop_statement             shift and go to state 122
    if_statement                   shift and go to state 123
    print_statement                shift and go to state 124
    scan_statement                 shift and go to state 125
    opt_const                      shift and go to state 8
    assign_expression              shift and go to state 127
    function_expression            shift and go to state 128
    unary_op                       shift and go to state 137

state 90

    (128) opt_args -> args type ID .

    R_BRACKET       reduce using rule 128 (opt_args -> args type ID .)


state 91

    (28) declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .

    COMMENT         reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    PREPROCESSOR_LINE reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    CONST           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    INT             reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    FLOAT           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    DOUBLE          reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    CHAR            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    BOOL            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    LONG            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    VOID            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    $end            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    SEMICOLON       reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    RETURN          reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    WHILE           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    DO              reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    BREAK           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    FOR             reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    IF              reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    PRINTF          reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    SCANF           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    ID              reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    INCREMENT       reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    DECREMENT       reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    R_BRACE         reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    NEGATION        reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    L_BRACKET       reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    MINUS           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    INTEGER         reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    DECIMAL         reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    CHARACTER       reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    STRING          reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    TRUE            reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)
    FALSE           reduce using rule 28 (declaration_statement -> opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON .)


state 92

    (51) declaration_value_expression -> L_BRACE listed_values . R_BRACE
    (97) listed_values -> listed_values . COMMA listed_values

    R_BRACE         shift and go to state 140
    COMMA           shift and go to state 141


state 93

    (52) declaration_value_expression -> L_BRACE declaration_value_expression . R_BRACE

    R_BRACE         shift and go to state 142


state 94

    (96) listed_values -> value_expression .
    (50) declaration_value_expression -> value_expression .
    (70) logical_expression -> value_expression . comparison_op value_expression
    (71) logical_expression -> value_expression .
    (107) comparison_op -> . EQUAL
    (108) comparison_op -> . NOT_EQUAL
    (109) comparison_op -> . GREATER
    (110) comparison_op -> . GREATER_EQUAL
    (111) comparison_op -> . LESSER
    (112) comparison_op -> . LESSER_EQUAL

  ! reduce/reduce conflict for R_BRACE resolved using rule 50 (declaration_value_expression -> value_expression .)
  ! reduce/reduce conflict for R_BRACE resolved using rule 50 (declaration_value_expression -> value_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 71 (logical_expression -> value_expression .)
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
    R_BRACE         reduce using rule 50 (declaration_value_expression -> value_expression .)
    QUESTION_MARK   reduce using rule 71 (logical_expression -> value_expression .)
    AND             reduce using rule 71 (logical_expression -> value_expression .)
    OR              reduce using rule 71 (logical_expression -> value_expression .)
    COMMA           reduce using rule 71 (logical_expression -> value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

  ! R_BRACE         [ reduce using rule 96 (listed_values -> value_expression .) ]
  ! COMMA           [ reduce using rule 96 (listed_values -> value_expression .) ]
  ! EQUAL           [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER         [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER          [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! R_BRACE         [ reduce using rule 71 (logical_expression -> value_expression .) ]

    comparison_op                  shift and go to state 58

state 95

    (70) logical_expression -> value_expression comparison_op value_expression .
    (70) logical_expression -> value_expression . comparison_op value_expression
    (71) logical_expression -> value_expression .
    (107) comparison_op -> . EQUAL
    (108) comparison_op -> . NOT_EQUAL
    (109) comparison_op -> . GREATER
    (110) comparison_op -> . GREATER_EQUAL
    (111) comparison_op -> . LESSER
    (112) comparison_op -> . LESSER_EQUAL

  ! reduce/reduce conflict for EQUAL resolved using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
  ! reduce/reduce conflict for GREATER resolved using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
  ! reduce/reduce conflict for LESSER resolved using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
  ! reduce/reduce conflict for LESSER_EQUAL resolved using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
  ! reduce/reduce conflict for AND resolved using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
  ! reduce/reduce conflict for OR resolved using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
  ! reduce/reduce conflict for R_SQUARE_BRACKET resolved using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
  ! reduce/reduce conflict for R_BRACKET resolved using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
  ! reduce/reduce conflict for R_BRACE resolved using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
  ! reduce/reduce conflict for COLON resolved using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
    R_SQUARE_BRACKET reduce using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
    QUESTION_MARK   reduce using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
    AND             reduce using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
    OR              reduce using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
    SEMICOLON       reduce using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
    R_BRACKET       reduce using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
    R_BRACE         reduce using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
    COMMA           reduce using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
    COLON           reduce using rule 70 (logical_expression -> value_expression comparison_op value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

  ! EQUAL           [ reduce using rule 70 (logical_expression -> value_expression comparison_op value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 70 (logical_expression -> value_expression comparison_op value_expression .) ]
  ! GREATER         [ reduce using rule 70 (logical_expression -> value_expression comparison_op value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 70 (logical_expression -> value_expression comparison_op value_expression .) ]
  ! LESSER          [ reduce using rule 70 (logical_expression -> value_expression comparison_op value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 70 (logical_expression -> value_expression comparison_op value_expression .) ]
  ! EQUAL           [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER         [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER          [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! QUESTION_MARK   [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! AND             [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! OR              [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! R_SQUARE_BRACKET [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! SEMICOLON       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! R_BRACKET       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! R_BRACE         [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! COMMA           [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! COLON           [ reduce using rule 71 (logical_expression -> value_expression .) ]

    comparison_op                  shift and go to state 58

state 96

    (61) math_expression -> math_expression math_op math_expression .
    (61) math_expression -> math_expression . math_op math_expression
    (98) math_op -> . PLUS
    (99) math_op -> . MINUS
    (100) math_op -> . MUL
    (101) math_op -> . DIV
    (102) math_op -> . MOD

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
    EQUAL           reduce using rule 61 (math_expression -> math_expression math_op math_expression .)
    NOT_EQUAL       reduce using rule 61 (math_expression -> math_expression math_op math_expression .)
    GREATER         reduce using rule 61 (math_expression -> math_expression math_op math_expression .)
    GREATER_EQUAL   reduce using rule 61 (math_expression -> math_expression math_op math_expression .)
    LESSER          reduce using rule 61 (math_expression -> math_expression math_op math_expression .)
    LESSER_EQUAL    reduce using rule 61 (math_expression -> math_expression math_op math_expression .)
    R_SQUARE_BRACKET reduce using rule 61 (math_expression -> math_expression math_op math_expression .)
    QUESTION_MARK   reduce using rule 61 (math_expression -> math_expression math_op math_expression .)
    AND             reduce using rule 61 (math_expression -> math_expression math_op math_expression .)
    OR              reduce using rule 61 (math_expression -> math_expression math_op math_expression .)
    SEMICOLON       reduce using rule 61 (math_expression -> math_expression math_op math_expression .)
    R_BRACKET       reduce using rule 61 (math_expression -> math_expression math_op math_expression .)
    R_BRACE         reduce using rule 61 (math_expression -> math_expression math_op math_expression .)
    COMMA           reduce using rule 61 (math_expression -> math_expression math_op math_expression .)
    COLON           reduce using rule 61 (math_expression -> math_expression math_op math_expression .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    MUL             shift and go to state 68
    DIV             shift and go to state 69
    MOD             shift and go to state 70

  ! PLUS            [ reduce using rule 61 (math_expression -> math_expression math_op math_expression .) ]
  ! MINUS           [ reduce using rule 61 (math_expression -> math_expression math_op math_expression .) ]
  ! MUL             [ reduce using rule 61 (math_expression -> math_expression math_op math_expression .) ]
  ! DIV             [ reduce using rule 61 (math_expression -> math_expression math_op math_expression .) ]
  ! MOD             [ reduce using rule 61 (math_expression -> math_expression math_op math_expression .) ]

    math_op                        shift and go to state 65

state 97

    (68) logical_expression -> logical_expression bool_op logical_expression .
    (68) logical_expression -> logical_expression . bool_op logical_expression
    (54) value_expression -> logical_expression .
    (73) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (105) bool_op -> . AND
    (106) bool_op -> . OR

  ! reduce/reduce conflict for EQUAL resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for GREATER resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for LESSER resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for LESSER_EQUAL resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for AND resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for OR resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for R_SQUARE_BRACKET resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for R_BRACKET resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for R_BRACE resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 54 (value_expression -> logical_expression .)
  ! reduce/reduce conflict for COLON resolved using rule 54 (value_expression -> logical_expression .)
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    EQUAL           reduce using rule 54 (value_expression -> logical_expression .)
    NOT_EQUAL       reduce using rule 54 (value_expression -> logical_expression .)
    GREATER         reduce using rule 54 (value_expression -> logical_expression .)
    GREATER_EQUAL   reduce using rule 54 (value_expression -> logical_expression .)
    LESSER          reduce using rule 54 (value_expression -> logical_expression .)
    LESSER_EQUAL    reduce using rule 54 (value_expression -> logical_expression .)
    R_SQUARE_BRACKET reduce using rule 54 (value_expression -> logical_expression .)
    SEMICOLON       reduce using rule 54 (value_expression -> logical_expression .)
    R_BRACKET       reduce using rule 54 (value_expression -> logical_expression .)
    R_BRACE         reduce using rule 54 (value_expression -> logical_expression .)
    COMMA           reduce using rule 54 (value_expression -> logical_expression .)
    COLON           reduce using rule 54 (value_expression -> logical_expression .)
    QUESTION_MARK   shift and go to state 72
    AND             shift and go to state 73
    OR              shift and go to state 74

  ! EQUAL           [ reduce using rule 68 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 68 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! GREATER         [ reduce using rule 68 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 68 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! LESSER          [ reduce using rule 68 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 68 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! R_SQUARE_BRACKET [ reduce using rule 68 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! QUESTION_MARK   [ reduce using rule 68 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! AND             [ reduce using rule 68 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! OR              [ reduce using rule 68 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! SEMICOLON       [ reduce using rule 68 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! R_BRACKET       [ reduce using rule 68 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! R_BRACE         [ reduce using rule 68 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! COMMA           [ reduce using rule 68 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! COLON           [ reduce using rule 68 (logical_expression -> logical_expression bool_op logical_expression .) ]
  ! QUESTION_MARK   [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! AND             [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! OR              [ reduce using rule 54 (value_expression -> logical_expression .) ]

    bool_op                        shift and go to state 71

state 98

    (73) trinary_mark_expression -> logical_expression QUESTION_MARK value_expression . COLON value_expression
    (70) logical_expression -> value_expression . comparison_op value_expression
    (71) logical_expression -> value_expression .
    (107) comparison_op -> . EQUAL
    (108) comparison_op -> . NOT_EQUAL
    (109) comparison_op -> . GREATER
    (110) comparison_op -> . GREATER_EQUAL
    (111) comparison_op -> . LESSER
    (112) comparison_op -> . LESSER_EQUAL

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
    COLON           shift and go to state 143
    QUESTION_MARK   reduce using rule 71 (logical_expression -> value_expression .)
    AND             reduce using rule 71 (logical_expression -> value_expression .)
    OR              reduce using rule 71 (logical_expression -> value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

  ! COLON           [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! EQUAL           [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER         [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER          [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 71 (logical_expression -> value_expression .) ]

    comparison_op                  shift and go to state 58

state 99

    (58) value_expression -> L_BRACKET value_expression R_BRACKET .

    EQUAL           reduce using rule 58 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    NOT_EQUAL       reduce using rule 58 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    GREATER         reduce using rule 58 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    GREATER_EQUAL   reduce using rule 58 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    LESSER          reduce using rule 58 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    LESSER_EQUAL    reduce using rule 58 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    R_SQUARE_BRACKET reduce using rule 58 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    QUESTION_MARK   reduce using rule 58 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    AND             reduce using rule 58 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    OR              reduce using rule 58 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    SEMICOLON       reduce using rule 58 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    R_BRACKET       reduce using rule 58 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    R_BRACE         reduce using rule 58 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    COMMA           reduce using rule 58 (value_expression -> L_BRACKET value_expression R_BRACKET .)
    COLON           reduce using rule 58 (value_expression -> L_BRACKET value_expression R_BRACKET .)


state 100

    (67) math_expression -> L_BRACKET math_expression R_BRACKET .

    PLUS            reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    MINUS           reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    MUL             reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    DIV             reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    MOD             reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    EQUAL           reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    NOT_EQUAL       reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    GREATER         reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    GREATER_EQUAL   reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    LESSER          reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    LESSER_EQUAL    reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    R_SQUARE_BRACKET reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    QUESTION_MARK   reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    AND             reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    OR              reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    SEMICOLON       reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    R_BRACKET       reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    R_BRACE         reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    COMMA           reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)
    COLON           reduce using rule 67 (math_expression -> L_BRACKET math_expression R_BRACKET .)


state 101

    (67) math_expression -> L_BRACKET math_expression . R_BRACKET
    (61) math_expression -> math_expression . math_op math_expression
    (98) math_op -> . PLUS
    (99) math_op -> . MINUS
    (100) math_op -> . MUL
    (101) math_op -> . DIV
    (102) math_op -> . MOD

    R_BRACKET       shift and go to state 100
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    MUL             shift and go to state 68
    DIV             shift and go to state 69
    MOD             shift and go to state 70

    math_op                        shift and go to state 65

state 102

    (72) function_expression -> ID L_BRACKET opt_listed_values . R_BRACKET

    R_BRACKET       shift and go to state 144


state 103

    (124) opt_listed_values -> listed_values .
    (97) listed_values -> listed_values . COMMA listed_values

    R_BRACKET       reduce using rule 124 (opt_listed_values -> listed_values .)
    COMMA           shift and go to state 141


state 104

    (125) opt_listed_values -> empty .

    R_BRACKET       reduce using rule 125 (opt_listed_values -> empty .)


state 105

    (96) listed_values -> value_expression .
    (70) logical_expression -> value_expression . comparison_op value_expression
    (71) logical_expression -> value_expression .
    (107) comparison_op -> . EQUAL
    (108) comparison_op -> . NOT_EQUAL
    (109) comparison_op -> . GREATER
    (110) comparison_op -> . GREATER_EQUAL
    (111) comparison_op -> . LESSER
    (112) comparison_op -> . LESSER_EQUAL

  ! reduce/reduce conflict for COMMA resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for R_BRACKET resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for R_BRACE resolved using rule 71 (logical_expression -> value_expression .)
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
    QUESTION_MARK   reduce using rule 71 (logical_expression -> value_expression .)
    AND             reduce using rule 71 (logical_expression -> value_expression .)
    OR              reduce using rule 71 (logical_expression -> value_expression .)
    COMMA           reduce using rule 71 (logical_expression -> value_expression .)
    R_BRACKET       reduce using rule 71 (logical_expression -> value_expression .)
    R_BRACE         reduce using rule 71 (logical_expression -> value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

  ! COMMA           [ reduce using rule 96 (listed_values -> value_expression .) ]
  ! R_BRACKET       [ reduce using rule 96 (listed_values -> value_expression .) ]
  ! R_BRACE         [ reduce using rule 96 (listed_values -> value_expression .) ]
  ! EQUAL           [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER         [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER          [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 71 (logical_expression -> value_expression .) ]

    comparison_op                  shift and go to state 58

state 106

    (95) value -> ID L_SQUARE_BRACKET value_expression . R_SQUARE_BRACKET
    (70) logical_expression -> value_expression . comparison_op value_expression
    (71) logical_expression -> value_expression .
    (107) comparison_op -> . EQUAL
    (108) comparison_op -> . NOT_EQUAL
    (109) comparison_op -> . GREATER
    (110) comparison_op -> . GREATER_EQUAL
    (111) comparison_op -> . LESSER
    (112) comparison_op -> . LESSER_EQUAL

  ! shift/reduce conflict for R_SQUARE_BRACKET resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
    R_SQUARE_BRACKET shift and go to state 145
    QUESTION_MARK   reduce using rule 71 (logical_expression -> value_expression .)
    AND             reduce using rule 71 (logical_expression -> value_expression .)
    OR              reduce using rule 71 (logical_expression -> value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

  ! R_SQUARE_BRACKET [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! EQUAL           [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER         [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER          [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 71 (logical_expression -> value_expression .) ]

    comparison_op                  shift and go to state 58

state 107

    (127) args -> type ID COMMA args .

    INT             reduce using rule 127 (args -> type ID COMMA args .)
    FLOAT           reduce using rule 127 (args -> type ID COMMA args .)
    DOUBLE          reduce using rule 127 (args -> type ID COMMA args .)
    CHAR            reduce using rule 127 (args -> type ID COMMA args .)
    BOOL            reduce using rule 127 (args -> type ID COMMA args .)
    LONG            reduce using rule 127 (args -> type ID COMMA args .)
    VOID            reduce using rule 127 (args -> type ID COMMA args .)


state 108

    (15) statements_block -> L_BRACE opt_statements . R_BRACE

    R_BRACE         shift and go to state 146


state 109

    (13) opt_statements -> statements .

    R_BRACE         reduce using rule 13 (opt_statements -> statements .)


state 110

    (14) opt_statements -> empty .
    (121) opt_const -> empty .

    R_BRACE         reduce using rule 14 (opt_statements -> empty .)
    INT             reduce using rule 121 (opt_const -> empty .)
    FLOAT           reduce using rule 121 (opt_const -> empty .)
    DOUBLE          reduce using rule 121 (opt_const -> empty .)
    CHAR            reduce using rule 121 (opt_const -> empty .)
    BOOL            reduce using rule 121 (opt_const -> empty .)
    LONG            reduce using rule 121 (opt_const -> empty .)
    VOID            reduce using rule 121 (opt_const -> empty .)


state 111

    (11) statements -> statement .
    (12) statements -> statement . statements
    (11) statements -> . statement
    (12) statements -> . statement statements
    (8) statement -> . any_statement
    (9) statement -> . COMMENT
    (10) statement -> . SEMICOLON
    (16) any_statement -> . declaration_statement
    (17) any_statement -> . assign_statement
    (18) any_statement -> . function_statement
    (19) any_statement -> . return_statement
    (20) any_statement -> . while_loop_statement
    (21) any_statement -> . do_while_loop_statement
    (22) any_statement -> . break_statement
    (23) any_statement -> . for_loop_statement
    (24) any_statement -> . if_statement opt_else_if_statements opt_else_statement
    (25) any_statement -> . print_statement
    (26) any_statement -> . scan_statement
    (27) declaration_statement -> . opt_const type ID opt_array_mark
    (28) declaration_statement -> . opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (29) assign_statement -> . assign_expression SEMICOLON
    (30) function_statement -> . function_expression SEMICOLON
    (31) return_statement -> . RETURN value_expression SEMICOLON
    (34) while_loop_statement -> . WHILE L_BRACKET logical_expression R_BRACKET statements_block
    (35) do_while_loop_statement -> . DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON
    (32) break_statement -> . BREAK SEMICOLON
    (36) for_loop_statement -> . FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block
    (39) if_statement -> . IF L_BRACKET logical_expression R_BRACKET statements_block
    (48) print_statement -> . PRINTF L_BRACKET value_expression R_BRACKET
    (49) scan_statement -> . SCANF L_BRACKET AMPERSAND ID R_BRACKET
    (120) opt_const -> . CONST
    (121) opt_const -> . empty
    (74) assign_expression -> . ID assign_op value_expression
    (75) assign_expression -> . unary_op ID
    (76) assign_expression -> . ID unary_op
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (130) empty -> .
    (103) unary_op -> . INCREMENT
    (104) unary_op -> . DECREMENT

    R_BRACE         reduce using rule 11 (statements -> statement .)
    COMMENT         shift and go to state 113
    SEMICOLON       shift and go to state 114
    RETURN          shift and go to state 129
    WHILE           shift and go to state 130
    DO              shift and go to state 131
    BREAK           shift and go to state 132
    FOR             shift and go to state 133
    IF              shift and go to state 134
    PRINTF          shift and go to state 135
    SCANF           shift and go to state 136
    CONST           shift and go to state 10
    ID              shift and go to state 126
    INT             reduce using rule 130 (empty -> .)
    FLOAT           reduce using rule 130 (empty -> .)
    DOUBLE          reduce using rule 130 (empty -> .)
    CHAR            reduce using rule 130 (empty -> .)
    BOOL            reduce using rule 130 (empty -> .)
    LONG            reduce using rule 130 (empty -> .)
    VOID            reduce using rule 130 (empty -> .)
    INCREMENT       shift and go to state 138
    DECREMENT       shift and go to state 139

    statement                      shift and go to state 111
    statements                     shift and go to state 147
    any_statement                  shift and go to state 112
    declaration_statement          shift and go to state 115
    assign_statement               shift and go to state 116
    function_statement             shift and go to state 117
    return_statement               shift and go to state 118
    while_loop_statement           shift and go to state 119
    do_while_loop_statement        shift and go to state 120
    break_statement                shift and go to state 121
    for_loop_statement             shift and go to state 122
    if_statement                   shift and go to state 123
    print_statement                shift and go to state 124
    scan_statement                 shift and go to state 125
    opt_const                      shift and go to state 8
    assign_expression              shift and go to state 127
    function_expression            shift and go to state 128
    empty                          shift and go to state 11
    unary_op                       shift and go to state 137

state 112

    (8) statement -> any_statement .

    COMMENT         reduce using rule 8 (statement -> any_statement .)
    SEMICOLON       reduce using rule 8 (statement -> any_statement .)
    RETURN          reduce using rule 8 (statement -> any_statement .)
    WHILE           reduce using rule 8 (statement -> any_statement .)
    DO              reduce using rule 8 (statement -> any_statement .)
    BREAK           reduce using rule 8 (statement -> any_statement .)
    FOR             reduce using rule 8 (statement -> any_statement .)
    IF              reduce using rule 8 (statement -> any_statement .)
    PRINTF          reduce using rule 8 (statement -> any_statement .)
    SCANF           reduce using rule 8 (statement -> any_statement .)
    CONST           reduce using rule 8 (statement -> any_statement .)
    ID              reduce using rule 8 (statement -> any_statement .)
    INCREMENT       reduce using rule 8 (statement -> any_statement .)
    DECREMENT       reduce using rule 8 (statement -> any_statement .)
    INT             reduce using rule 8 (statement -> any_statement .)
    FLOAT           reduce using rule 8 (statement -> any_statement .)
    DOUBLE          reduce using rule 8 (statement -> any_statement .)
    CHAR            reduce using rule 8 (statement -> any_statement .)
    BOOL            reduce using rule 8 (statement -> any_statement .)
    LONG            reduce using rule 8 (statement -> any_statement .)
    VOID            reduce using rule 8 (statement -> any_statement .)
    R_BRACE         reduce using rule 8 (statement -> any_statement .)


state 113

    (9) statement -> COMMENT .

    COMMENT         reduce using rule 9 (statement -> COMMENT .)
    SEMICOLON       reduce using rule 9 (statement -> COMMENT .)
    RETURN          reduce using rule 9 (statement -> COMMENT .)
    WHILE           reduce using rule 9 (statement -> COMMENT .)
    DO              reduce using rule 9 (statement -> COMMENT .)
    BREAK           reduce using rule 9 (statement -> COMMENT .)
    FOR             reduce using rule 9 (statement -> COMMENT .)
    IF              reduce using rule 9 (statement -> COMMENT .)
    PRINTF          reduce using rule 9 (statement -> COMMENT .)
    SCANF           reduce using rule 9 (statement -> COMMENT .)
    CONST           reduce using rule 9 (statement -> COMMENT .)
    ID              reduce using rule 9 (statement -> COMMENT .)
    INCREMENT       reduce using rule 9 (statement -> COMMENT .)
    DECREMENT       reduce using rule 9 (statement -> COMMENT .)
    INT             reduce using rule 9 (statement -> COMMENT .)
    FLOAT           reduce using rule 9 (statement -> COMMENT .)
    DOUBLE          reduce using rule 9 (statement -> COMMENT .)
    CHAR            reduce using rule 9 (statement -> COMMENT .)
    BOOL            reduce using rule 9 (statement -> COMMENT .)
    LONG            reduce using rule 9 (statement -> COMMENT .)
    VOID            reduce using rule 9 (statement -> COMMENT .)
    R_BRACE         reduce using rule 9 (statement -> COMMENT .)


state 114

    (10) statement -> SEMICOLON .

    COMMENT         reduce using rule 10 (statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 10 (statement -> SEMICOLON .)
    RETURN          reduce using rule 10 (statement -> SEMICOLON .)
    WHILE           reduce using rule 10 (statement -> SEMICOLON .)
    DO              reduce using rule 10 (statement -> SEMICOLON .)
    BREAK           reduce using rule 10 (statement -> SEMICOLON .)
    FOR             reduce using rule 10 (statement -> SEMICOLON .)
    IF              reduce using rule 10 (statement -> SEMICOLON .)
    PRINTF          reduce using rule 10 (statement -> SEMICOLON .)
    SCANF           reduce using rule 10 (statement -> SEMICOLON .)
    CONST           reduce using rule 10 (statement -> SEMICOLON .)
    ID              reduce using rule 10 (statement -> SEMICOLON .)
    INCREMENT       reduce using rule 10 (statement -> SEMICOLON .)
    DECREMENT       reduce using rule 10 (statement -> SEMICOLON .)
    INT             reduce using rule 10 (statement -> SEMICOLON .)
    FLOAT           reduce using rule 10 (statement -> SEMICOLON .)
    DOUBLE          reduce using rule 10 (statement -> SEMICOLON .)
    CHAR            reduce using rule 10 (statement -> SEMICOLON .)
    BOOL            reduce using rule 10 (statement -> SEMICOLON .)
    LONG            reduce using rule 10 (statement -> SEMICOLON .)
    VOID            reduce using rule 10 (statement -> SEMICOLON .)
    R_BRACE         reduce using rule 10 (statement -> SEMICOLON .)


state 115

    (16) any_statement -> declaration_statement .

    COMMENT         reduce using rule 16 (any_statement -> declaration_statement .)
    SEMICOLON       reduce using rule 16 (any_statement -> declaration_statement .)
    RETURN          reduce using rule 16 (any_statement -> declaration_statement .)
    WHILE           reduce using rule 16 (any_statement -> declaration_statement .)
    DO              reduce using rule 16 (any_statement -> declaration_statement .)
    BREAK           reduce using rule 16 (any_statement -> declaration_statement .)
    FOR             reduce using rule 16 (any_statement -> declaration_statement .)
    IF              reduce using rule 16 (any_statement -> declaration_statement .)
    PRINTF          reduce using rule 16 (any_statement -> declaration_statement .)
    SCANF           reduce using rule 16 (any_statement -> declaration_statement .)
    CONST           reduce using rule 16 (any_statement -> declaration_statement .)
    ID              reduce using rule 16 (any_statement -> declaration_statement .)
    INCREMENT       reduce using rule 16 (any_statement -> declaration_statement .)
    DECREMENT       reduce using rule 16 (any_statement -> declaration_statement .)
    INT             reduce using rule 16 (any_statement -> declaration_statement .)
    FLOAT           reduce using rule 16 (any_statement -> declaration_statement .)
    DOUBLE          reduce using rule 16 (any_statement -> declaration_statement .)
    CHAR            reduce using rule 16 (any_statement -> declaration_statement .)
    BOOL            reduce using rule 16 (any_statement -> declaration_statement .)
    LONG            reduce using rule 16 (any_statement -> declaration_statement .)
    VOID            reduce using rule 16 (any_statement -> declaration_statement .)
    R_BRACE         reduce using rule 16 (any_statement -> declaration_statement .)


state 116

    (17) any_statement -> assign_statement .

    COMMENT         reduce using rule 17 (any_statement -> assign_statement .)
    SEMICOLON       reduce using rule 17 (any_statement -> assign_statement .)
    RETURN          reduce using rule 17 (any_statement -> assign_statement .)
    WHILE           reduce using rule 17 (any_statement -> assign_statement .)
    DO              reduce using rule 17 (any_statement -> assign_statement .)
    BREAK           reduce using rule 17 (any_statement -> assign_statement .)
    FOR             reduce using rule 17 (any_statement -> assign_statement .)
    IF              reduce using rule 17 (any_statement -> assign_statement .)
    PRINTF          reduce using rule 17 (any_statement -> assign_statement .)
    SCANF           reduce using rule 17 (any_statement -> assign_statement .)
    CONST           reduce using rule 17 (any_statement -> assign_statement .)
    ID              reduce using rule 17 (any_statement -> assign_statement .)
    INCREMENT       reduce using rule 17 (any_statement -> assign_statement .)
    DECREMENT       reduce using rule 17 (any_statement -> assign_statement .)
    INT             reduce using rule 17 (any_statement -> assign_statement .)
    FLOAT           reduce using rule 17 (any_statement -> assign_statement .)
    DOUBLE          reduce using rule 17 (any_statement -> assign_statement .)
    CHAR            reduce using rule 17 (any_statement -> assign_statement .)
    BOOL            reduce using rule 17 (any_statement -> assign_statement .)
    LONG            reduce using rule 17 (any_statement -> assign_statement .)
    VOID            reduce using rule 17 (any_statement -> assign_statement .)
    R_BRACE         reduce using rule 17 (any_statement -> assign_statement .)


state 117

    (18) any_statement -> function_statement .

    COMMENT         reduce using rule 18 (any_statement -> function_statement .)
    SEMICOLON       reduce using rule 18 (any_statement -> function_statement .)
    RETURN          reduce using rule 18 (any_statement -> function_statement .)
    WHILE           reduce using rule 18 (any_statement -> function_statement .)
    DO              reduce using rule 18 (any_statement -> function_statement .)
    BREAK           reduce using rule 18 (any_statement -> function_statement .)
    FOR             reduce using rule 18 (any_statement -> function_statement .)
    IF              reduce using rule 18 (any_statement -> function_statement .)
    PRINTF          reduce using rule 18 (any_statement -> function_statement .)
    SCANF           reduce using rule 18 (any_statement -> function_statement .)
    CONST           reduce using rule 18 (any_statement -> function_statement .)
    ID              reduce using rule 18 (any_statement -> function_statement .)
    INCREMENT       reduce using rule 18 (any_statement -> function_statement .)
    DECREMENT       reduce using rule 18 (any_statement -> function_statement .)
    INT             reduce using rule 18 (any_statement -> function_statement .)
    FLOAT           reduce using rule 18 (any_statement -> function_statement .)
    DOUBLE          reduce using rule 18 (any_statement -> function_statement .)
    CHAR            reduce using rule 18 (any_statement -> function_statement .)
    BOOL            reduce using rule 18 (any_statement -> function_statement .)
    LONG            reduce using rule 18 (any_statement -> function_statement .)
    VOID            reduce using rule 18 (any_statement -> function_statement .)
    R_BRACE         reduce using rule 18 (any_statement -> function_statement .)


state 118

    (19) any_statement -> return_statement .

    COMMENT         reduce using rule 19 (any_statement -> return_statement .)
    SEMICOLON       reduce using rule 19 (any_statement -> return_statement .)
    RETURN          reduce using rule 19 (any_statement -> return_statement .)
    WHILE           reduce using rule 19 (any_statement -> return_statement .)
    DO              reduce using rule 19 (any_statement -> return_statement .)
    BREAK           reduce using rule 19 (any_statement -> return_statement .)
    FOR             reduce using rule 19 (any_statement -> return_statement .)
    IF              reduce using rule 19 (any_statement -> return_statement .)
    PRINTF          reduce using rule 19 (any_statement -> return_statement .)
    SCANF           reduce using rule 19 (any_statement -> return_statement .)
    CONST           reduce using rule 19 (any_statement -> return_statement .)
    ID              reduce using rule 19 (any_statement -> return_statement .)
    INCREMENT       reduce using rule 19 (any_statement -> return_statement .)
    DECREMENT       reduce using rule 19 (any_statement -> return_statement .)
    INT             reduce using rule 19 (any_statement -> return_statement .)
    FLOAT           reduce using rule 19 (any_statement -> return_statement .)
    DOUBLE          reduce using rule 19 (any_statement -> return_statement .)
    CHAR            reduce using rule 19 (any_statement -> return_statement .)
    BOOL            reduce using rule 19 (any_statement -> return_statement .)
    LONG            reduce using rule 19 (any_statement -> return_statement .)
    VOID            reduce using rule 19 (any_statement -> return_statement .)
    R_BRACE         reduce using rule 19 (any_statement -> return_statement .)


state 119

    (20) any_statement -> while_loop_statement .

    COMMENT         reduce using rule 20 (any_statement -> while_loop_statement .)
    SEMICOLON       reduce using rule 20 (any_statement -> while_loop_statement .)
    RETURN          reduce using rule 20 (any_statement -> while_loop_statement .)
    WHILE           reduce using rule 20 (any_statement -> while_loop_statement .)
    DO              reduce using rule 20 (any_statement -> while_loop_statement .)
    BREAK           reduce using rule 20 (any_statement -> while_loop_statement .)
    FOR             reduce using rule 20 (any_statement -> while_loop_statement .)
    IF              reduce using rule 20 (any_statement -> while_loop_statement .)
    PRINTF          reduce using rule 20 (any_statement -> while_loop_statement .)
    SCANF           reduce using rule 20 (any_statement -> while_loop_statement .)
    CONST           reduce using rule 20 (any_statement -> while_loop_statement .)
    ID              reduce using rule 20 (any_statement -> while_loop_statement .)
    INCREMENT       reduce using rule 20 (any_statement -> while_loop_statement .)
    DECREMENT       reduce using rule 20 (any_statement -> while_loop_statement .)
    INT             reduce using rule 20 (any_statement -> while_loop_statement .)
    FLOAT           reduce using rule 20 (any_statement -> while_loop_statement .)
    DOUBLE          reduce using rule 20 (any_statement -> while_loop_statement .)
    CHAR            reduce using rule 20 (any_statement -> while_loop_statement .)
    BOOL            reduce using rule 20 (any_statement -> while_loop_statement .)
    LONG            reduce using rule 20 (any_statement -> while_loop_statement .)
    VOID            reduce using rule 20 (any_statement -> while_loop_statement .)
    R_BRACE         reduce using rule 20 (any_statement -> while_loop_statement .)


state 120

    (21) any_statement -> do_while_loop_statement .

    COMMENT         reduce using rule 21 (any_statement -> do_while_loop_statement .)
    SEMICOLON       reduce using rule 21 (any_statement -> do_while_loop_statement .)
    RETURN          reduce using rule 21 (any_statement -> do_while_loop_statement .)
    WHILE           reduce using rule 21 (any_statement -> do_while_loop_statement .)
    DO              reduce using rule 21 (any_statement -> do_while_loop_statement .)
    BREAK           reduce using rule 21 (any_statement -> do_while_loop_statement .)
    FOR             reduce using rule 21 (any_statement -> do_while_loop_statement .)
    IF              reduce using rule 21 (any_statement -> do_while_loop_statement .)
    PRINTF          reduce using rule 21 (any_statement -> do_while_loop_statement .)
    SCANF           reduce using rule 21 (any_statement -> do_while_loop_statement .)
    CONST           reduce using rule 21 (any_statement -> do_while_loop_statement .)
    ID              reduce using rule 21 (any_statement -> do_while_loop_statement .)
    INCREMENT       reduce using rule 21 (any_statement -> do_while_loop_statement .)
    DECREMENT       reduce using rule 21 (any_statement -> do_while_loop_statement .)
    INT             reduce using rule 21 (any_statement -> do_while_loop_statement .)
    FLOAT           reduce using rule 21 (any_statement -> do_while_loop_statement .)
    DOUBLE          reduce using rule 21 (any_statement -> do_while_loop_statement .)
    CHAR            reduce using rule 21 (any_statement -> do_while_loop_statement .)
    BOOL            reduce using rule 21 (any_statement -> do_while_loop_statement .)
    LONG            reduce using rule 21 (any_statement -> do_while_loop_statement .)
    VOID            reduce using rule 21 (any_statement -> do_while_loop_statement .)
    R_BRACE         reduce using rule 21 (any_statement -> do_while_loop_statement .)


state 121

    (22) any_statement -> break_statement .

    COMMENT         reduce using rule 22 (any_statement -> break_statement .)
    SEMICOLON       reduce using rule 22 (any_statement -> break_statement .)
    RETURN          reduce using rule 22 (any_statement -> break_statement .)
    WHILE           reduce using rule 22 (any_statement -> break_statement .)
    DO              reduce using rule 22 (any_statement -> break_statement .)
    BREAK           reduce using rule 22 (any_statement -> break_statement .)
    FOR             reduce using rule 22 (any_statement -> break_statement .)
    IF              reduce using rule 22 (any_statement -> break_statement .)
    PRINTF          reduce using rule 22 (any_statement -> break_statement .)
    SCANF           reduce using rule 22 (any_statement -> break_statement .)
    CONST           reduce using rule 22 (any_statement -> break_statement .)
    ID              reduce using rule 22 (any_statement -> break_statement .)
    INCREMENT       reduce using rule 22 (any_statement -> break_statement .)
    DECREMENT       reduce using rule 22 (any_statement -> break_statement .)
    INT             reduce using rule 22 (any_statement -> break_statement .)
    FLOAT           reduce using rule 22 (any_statement -> break_statement .)
    DOUBLE          reduce using rule 22 (any_statement -> break_statement .)
    CHAR            reduce using rule 22 (any_statement -> break_statement .)
    BOOL            reduce using rule 22 (any_statement -> break_statement .)
    LONG            reduce using rule 22 (any_statement -> break_statement .)
    VOID            reduce using rule 22 (any_statement -> break_statement .)
    R_BRACE         reduce using rule 22 (any_statement -> break_statement .)


state 122

    (23) any_statement -> for_loop_statement .

    COMMENT         reduce using rule 23 (any_statement -> for_loop_statement .)
    SEMICOLON       reduce using rule 23 (any_statement -> for_loop_statement .)
    RETURN          reduce using rule 23 (any_statement -> for_loop_statement .)
    WHILE           reduce using rule 23 (any_statement -> for_loop_statement .)
    DO              reduce using rule 23 (any_statement -> for_loop_statement .)
    BREAK           reduce using rule 23 (any_statement -> for_loop_statement .)
    FOR             reduce using rule 23 (any_statement -> for_loop_statement .)
    IF              reduce using rule 23 (any_statement -> for_loop_statement .)
    PRINTF          reduce using rule 23 (any_statement -> for_loop_statement .)
    SCANF           reduce using rule 23 (any_statement -> for_loop_statement .)
    CONST           reduce using rule 23 (any_statement -> for_loop_statement .)
    ID              reduce using rule 23 (any_statement -> for_loop_statement .)
    INCREMENT       reduce using rule 23 (any_statement -> for_loop_statement .)
    DECREMENT       reduce using rule 23 (any_statement -> for_loop_statement .)
    INT             reduce using rule 23 (any_statement -> for_loop_statement .)
    FLOAT           reduce using rule 23 (any_statement -> for_loop_statement .)
    DOUBLE          reduce using rule 23 (any_statement -> for_loop_statement .)
    CHAR            reduce using rule 23 (any_statement -> for_loop_statement .)
    BOOL            reduce using rule 23 (any_statement -> for_loop_statement .)
    LONG            reduce using rule 23 (any_statement -> for_loop_statement .)
    VOID            reduce using rule 23 (any_statement -> for_loop_statement .)
    R_BRACE         reduce using rule 23 (any_statement -> for_loop_statement .)


state 123

    (24) any_statement -> if_statement . opt_else_if_statements opt_else_statement
    (43) opt_else_if_statements -> . else_if_statements
    (44) opt_else_if_statements -> . empty
    (41) else_if_statements -> . else_if_statement
    (42) else_if_statements -> . else_if_statement else_if_statements
    (130) empty -> .
    (40) else_if_statement -> . ELSE IF L_BRACKET logical_expression R_BRACKET statements_block

  ! shift/reduce conflict for ELSE resolved as shift
    COMMENT         reduce using rule 130 (empty -> .)
    SEMICOLON       reduce using rule 130 (empty -> .)
    RETURN          reduce using rule 130 (empty -> .)
    WHILE           reduce using rule 130 (empty -> .)
    DO              reduce using rule 130 (empty -> .)
    BREAK           reduce using rule 130 (empty -> .)
    FOR             reduce using rule 130 (empty -> .)
    IF              reduce using rule 130 (empty -> .)
    PRINTF          reduce using rule 130 (empty -> .)
    SCANF           reduce using rule 130 (empty -> .)
    CONST           reduce using rule 130 (empty -> .)
    ID              reduce using rule 130 (empty -> .)
    INCREMENT       reduce using rule 130 (empty -> .)
    DECREMENT       reduce using rule 130 (empty -> .)
    INT             reduce using rule 130 (empty -> .)
    FLOAT           reduce using rule 130 (empty -> .)
    DOUBLE          reduce using rule 130 (empty -> .)
    CHAR            reduce using rule 130 (empty -> .)
    BOOL            reduce using rule 130 (empty -> .)
    LONG            reduce using rule 130 (empty -> .)
    VOID            reduce using rule 130 (empty -> .)
    R_BRACE         reduce using rule 130 (empty -> .)
    ELSE            shift and go to state 152

  ! ELSE            [ reduce using rule 130 (empty -> .) ]

    opt_else_if_statements         shift and go to state 148
    else_if_statements             shift and go to state 149
    empty                          shift and go to state 150
    else_if_statement              shift and go to state 151

state 124

    (25) any_statement -> print_statement .

    COMMENT         reduce using rule 25 (any_statement -> print_statement .)
    SEMICOLON       reduce using rule 25 (any_statement -> print_statement .)
    RETURN          reduce using rule 25 (any_statement -> print_statement .)
    WHILE           reduce using rule 25 (any_statement -> print_statement .)
    DO              reduce using rule 25 (any_statement -> print_statement .)
    BREAK           reduce using rule 25 (any_statement -> print_statement .)
    FOR             reduce using rule 25 (any_statement -> print_statement .)
    IF              reduce using rule 25 (any_statement -> print_statement .)
    PRINTF          reduce using rule 25 (any_statement -> print_statement .)
    SCANF           reduce using rule 25 (any_statement -> print_statement .)
    CONST           reduce using rule 25 (any_statement -> print_statement .)
    ID              reduce using rule 25 (any_statement -> print_statement .)
    INCREMENT       reduce using rule 25 (any_statement -> print_statement .)
    DECREMENT       reduce using rule 25 (any_statement -> print_statement .)
    INT             reduce using rule 25 (any_statement -> print_statement .)
    FLOAT           reduce using rule 25 (any_statement -> print_statement .)
    DOUBLE          reduce using rule 25 (any_statement -> print_statement .)
    CHAR            reduce using rule 25 (any_statement -> print_statement .)
    BOOL            reduce using rule 25 (any_statement -> print_statement .)
    LONG            reduce using rule 25 (any_statement -> print_statement .)
    VOID            reduce using rule 25 (any_statement -> print_statement .)
    R_BRACE         reduce using rule 25 (any_statement -> print_statement .)


state 125

    (26) any_statement -> scan_statement .

    COMMENT         reduce using rule 26 (any_statement -> scan_statement .)
    SEMICOLON       reduce using rule 26 (any_statement -> scan_statement .)
    RETURN          reduce using rule 26 (any_statement -> scan_statement .)
    WHILE           reduce using rule 26 (any_statement -> scan_statement .)
    DO              reduce using rule 26 (any_statement -> scan_statement .)
    BREAK           reduce using rule 26 (any_statement -> scan_statement .)
    FOR             reduce using rule 26 (any_statement -> scan_statement .)
    IF              reduce using rule 26 (any_statement -> scan_statement .)
    PRINTF          reduce using rule 26 (any_statement -> scan_statement .)
    SCANF           reduce using rule 26 (any_statement -> scan_statement .)
    CONST           reduce using rule 26 (any_statement -> scan_statement .)
    ID              reduce using rule 26 (any_statement -> scan_statement .)
    INCREMENT       reduce using rule 26 (any_statement -> scan_statement .)
    DECREMENT       reduce using rule 26 (any_statement -> scan_statement .)
    INT             reduce using rule 26 (any_statement -> scan_statement .)
    FLOAT           reduce using rule 26 (any_statement -> scan_statement .)
    DOUBLE          reduce using rule 26 (any_statement -> scan_statement .)
    CHAR            reduce using rule 26 (any_statement -> scan_statement .)
    BOOL            reduce using rule 26 (any_statement -> scan_statement .)
    LONG            reduce using rule 26 (any_statement -> scan_statement .)
    VOID            reduce using rule 26 (any_statement -> scan_statement .)
    R_BRACE         reduce using rule 26 (any_statement -> scan_statement .)


state 126

    (74) assign_expression -> ID . assign_op value_expression
    (76) assign_expression -> ID . unary_op
    (72) function_expression -> ID . L_BRACKET opt_listed_values R_BRACKET
    (113) assign_op -> . ASSIGN
    (114) assign_op -> . PLUS_ASSIGN
    (115) assign_op -> . MINUS_ASSIGN
    (116) assign_op -> . MUL_ASSIGN
    (117) assign_op -> . DIV_ASSIGN
    (118) assign_op -> . MOD_ASSIGN
    (103) unary_op -> . INCREMENT
    (104) unary_op -> . DECREMENT

    L_BRACKET       shift and go to state 83
    ASSIGN          shift and go to state 155
    PLUS_ASSIGN     shift and go to state 156
    MINUS_ASSIGN    shift and go to state 157
    MUL_ASSIGN      shift and go to state 158
    DIV_ASSIGN      shift and go to state 159
    MOD_ASSIGN      shift and go to state 160
    INCREMENT       shift and go to state 138
    DECREMENT       shift and go to state 139

    assign_op                      shift and go to state 153
    unary_op                       shift and go to state 154

state 127

    (29) assign_statement -> assign_expression . SEMICOLON

    SEMICOLON       shift and go to state 161


state 128

    (30) function_statement -> function_expression . SEMICOLON

    SEMICOLON       shift and go to state 162


state 129

    (31) return_statement -> RETURN . value_expression SEMICOLON
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    NEGATION        shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    value_expression               shift and go to state 163
    math_expression                shift and go to state 36
    logical_expression             shift and go to state 37
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 130

    (34) while_loop_statement -> WHILE . L_BRACKET logical_expression R_BRACKET statements_block

    L_BRACKET       shift and go to state 164


state 131

    (35) do_while_loop_statement -> DO . statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 89

    statements_block               shift and go to state 165

state 132

    (32) break_statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 166


state 133

    (36) for_loop_statement -> FOR . L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block

    L_BRACKET       shift and go to state 167


state 134

    (39) if_statement -> IF . L_BRACKET logical_expression R_BRACKET statements_block

    L_BRACKET       shift and go to state 168


state 135

    (48) print_statement -> PRINTF . L_BRACKET value_expression R_BRACKET

    L_BRACKET       shift and go to state 169


state 136

    (49) scan_statement -> SCANF . L_BRACKET AMPERSAND ID R_BRACKET

    L_BRACKET       shift and go to state 170


state 137

    (75) assign_expression -> unary_op . ID

    ID              shift and go to state 171


state 138

    (103) unary_op -> INCREMENT .

    ID              reduce using rule 103 (unary_op -> INCREMENT .)
    SEMICOLON       reduce using rule 103 (unary_op -> INCREMENT .)
    R_BRACKET       reduce using rule 103 (unary_op -> INCREMENT .)


state 139

    (104) unary_op -> DECREMENT .

    ID              reduce using rule 104 (unary_op -> DECREMENT .)
    SEMICOLON       reduce using rule 104 (unary_op -> DECREMENT .)
    R_BRACKET       reduce using rule 104 (unary_op -> DECREMENT .)


state 140

    (51) declaration_value_expression -> L_BRACE listed_values R_BRACE .

    SEMICOLON       reduce using rule 51 (declaration_value_expression -> L_BRACE listed_values R_BRACE .)
    R_BRACE         reduce using rule 51 (declaration_value_expression -> L_BRACE listed_values R_BRACE .)


state 141

    (97) listed_values -> listed_values COMMA . listed_values
    (96) listed_values -> . value_expression
    (97) listed_values -> . listed_values COMMA listed_values
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    NEGATION        shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    listed_values                  shift and go to state 172
    value_expression               shift and go to state 105
    math_expression                shift and go to state 36
    logical_expression             shift and go to state 37
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 142

    (52) declaration_value_expression -> L_BRACE declaration_value_expression R_BRACE .

    SEMICOLON       reduce using rule 52 (declaration_value_expression -> L_BRACE declaration_value_expression R_BRACE .)
    R_BRACE         reduce using rule 52 (declaration_value_expression -> L_BRACE declaration_value_expression R_BRACE .)


state 143

    (73) trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    NEGATION        shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    logical_expression             shift and go to state 37
    value_expression               shift and go to state 173
    math_expression                shift and go to state 36
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 144

    (72) function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .

    EQUAL           reduce using rule 72 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    NOT_EQUAL       reduce using rule 72 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    GREATER         reduce using rule 72 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    GREATER_EQUAL   reduce using rule 72 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    LESSER          reduce using rule 72 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    LESSER_EQUAL    reduce using rule 72 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    R_SQUARE_BRACKET reduce using rule 72 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    QUESTION_MARK   reduce using rule 72 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    AND             reduce using rule 72 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    OR              reduce using rule 72 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    SEMICOLON       reduce using rule 72 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    R_BRACKET       reduce using rule 72 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    R_BRACE         reduce using rule 72 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    COMMA           reduce using rule 72 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)
    COLON           reduce using rule 72 (function_expression -> ID L_BRACKET opt_listed_values R_BRACKET .)


state 145

    (95) value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .

    EQUAL           reduce using rule 95 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    NOT_EQUAL       reduce using rule 95 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    GREATER         reduce using rule 95 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    GREATER_EQUAL   reduce using rule 95 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    LESSER          reduce using rule 95 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    LESSER_EQUAL    reduce using rule 95 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    R_SQUARE_BRACKET reduce using rule 95 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    QUESTION_MARK   reduce using rule 95 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    AND             reduce using rule 95 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    OR              reduce using rule 95 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    SEMICOLON       reduce using rule 95 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    R_BRACKET       reduce using rule 95 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    R_BRACE         reduce using rule 95 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    COMMA           reduce using rule 95 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)
    COLON           reduce using rule 95 (value -> ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET .)


state 146

    (15) statements_block -> L_BRACE opt_statements R_BRACE .

    COMMENT         reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    PREPROCESSOR_LINE reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    CONST           reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    INT             reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    FLOAT           reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    DOUBLE          reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    CHAR            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    BOOL            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    LONG            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    VOID            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    $end            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    WHILE           reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    SEMICOLON       reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    RETURN          reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    DO              reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    BREAK           reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    FOR             reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    IF              reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    PRINTF          reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    SCANF           reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    ID              reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    INCREMENT       reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    DECREMENT       reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    R_BRACE         reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)
    ELSE            reduce using rule 15 (statements_block -> L_BRACE opt_statements R_BRACE .)


state 147

    (12) statements -> statement statements .

    R_BRACE         reduce using rule 12 (statements -> statement statements .)


state 148

    (24) any_statement -> if_statement opt_else_if_statements . opt_else_statement
    (46) opt_else_statement -> . else_statement
    (47) opt_else_statement -> . empty
    (45) else_statement -> . ELSE
    (130) empty -> .

    ELSE            shift and go to state 177
    COMMENT         reduce using rule 130 (empty -> .)
    SEMICOLON       reduce using rule 130 (empty -> .)
    RETURN          reduce using rule 130 (empty -> .)
    WHILE           reduce using rule 130 (empty -> .)
    DO              reduce using rule 130 (empty -> .)
    BREAK           reduce using rule 130 (empty -> .)
    FOR             reduce using rule 130 (empty -> .)
    IF              reduce using rule 130 (empty -> .)
    PRINTF          reduce using rule 130 (empty -> .)
    SCANF           reduce using rule 130 (empty -> .)
    CONST           reduce using rule 130 (empty -> .)
    ID              reduce using rule 130 (empty -> .)
    INCREMENT       reduce using rule 130 (empty -> .)
    DECREMENT       reduce using rule 130 (empty -> .)
    INT             reduce using rule 130 (empty -> .)
    FLOAT           reduce using rule 130 (empty -> .)
    DOUBLE          reduce using rule 130 (empty -> .)
    CHAR            reduce using rule 130 (empty -> .)
    BOOL            reduce using rule 130 (empty -> .)
    LONG            reduce using rule 130 (empty -> .)
    VOID            reduce using rule 130 (empty -> .)
    R_BRACE         reduce using rule 130 (empty -> .)

    opt_else_statement             shift and go to state 174
    else_statement                 shift and go to state 175
    empty                          shift and go to state 176

state 149

    (43) opt_else_if_statements -> else_if_statements .

    ELSE            reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    COMMENT         reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    SEMICOLON       reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    RETURN          reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    WHILE           reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    DO              reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    BREAK           reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    FOR             reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    IF              reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    PRINTF          reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    SCANF           reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    CONST           reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    ID              reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    INCREMENT       reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    DECREMENT       reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    INT             reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    FLOAT           reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    DOUBLE          reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    CHAR            reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    BOOL            reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    LONG            reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    VOID            reduce using rule 43 (opt_else_if_statements -> else_if_statements .)
    R_BRACE         reduce using rule 43 (opt_else_if_statements -> else_if_statements .)


state 150

    (44) opt_else_if_statements -> empty .

    ELSE            reduce using rule 44 (opt_else_if_statements -> empty .)
    COMMENT         reduce using rule 44 (opt_else_if_statements -> empty .)
    SEMICOLON       reduce using rule 44 (opt_else_if_statements -> empty .)
    RETURN          reduce using rule 44 (opt_else_if_statements -> empty .)
    WHILE           reduce using rule 44 (opt_else_if_statements -> empty .)
    DO              reduce using rule 44 (opt_else_if_statements -> empty .)
    BREAK           reduce using rule 44 (opt_else_if_statements -> empty .)
    FOR             reduce using rule 44 (opt_else_if_statements -> empty .)
    IF              reduce using rule 44 (opt_else_if_statements -> empty .)
    PRINTF          reduce using rule 44 (opt_else_if_statements -> empty .)
    SCANF           reduce using rule 44 (opt_else_if_statements -> empty .)
    CONST           reduce using rule 44 (opt_else_if_statements -> empty .)
    ID              reduce using rule 44 (opt_else_if_statements -> empty .)
    INCREMENT       reduce using rule 44 (opt_else_if_statements -> empty .)
    DECREMENT       reduce using rule 44 (opt_else_if_statements -> empty .)
    INT             reduce using rule 44 (opt_else_if_statements -> empty .)
    FLOAT           reduce using rule 44 (opt_else_if_statements -> empty .)
    DOUBLE          reduce using rule 44 (opt_else_if_statements -> empty .)
    CHAR            reduce using rule 44 (opt_else_if_statements -> empty .)
    BOOL            reduce using rule 44 (opt_else_if_statements -> empty .)
    LONG            reduce using rule 44 (opt_else_if_statements -> empty .)
    VOID            reduce using rule 44 (opt_else_if_statements -> empty .)
    R_BRACE         reduce using rule 44 (opt_else_if_statements -> empty .)


state 151

    (41) else_if_statements -> else_if_statement .
    (42) else_if_statements -> else_if_statement . else_if_statements
    (41) else_if_statements -> . else_if_statement
    (42) else_if_statements -> . else_if_statement else_if_statements
    (40) else_if_statement -> . ELSE IF L_BRACKET logical_expression R_BRACKET statements_block

  ! shift/reduce conflict for ELSE resolved as shift
    COMMENT         reduce using rule 41 (else_if_statements -> else_if_statement .)
    SEMICOLON       reduce using rule 41 (else_if_statements -> else_if_statement .)
    RETURN          reduce using rule 41 (else_if_statements -> else_if_statement .)
    WHILE           reduce using rule 41 (else_if_statements -> else_if_statement .)
    DO              reduce using rule 41 (else_if_statements -> else_if_statement .)
    BREAK           reduce using rule 41 (else_if_statements -> else_if_statement .)
    FOR             reduce using rule 41 (else_if_statements -> else_if_statement .)
    IF              reduce using rule 41 (else_if_statements -> else_if_statement .)
    PRINTF          reduce using rule 41 (else_if_statements -> else_if_statement .)
    SCANF           reduce using rule 41 (else_if_statements -> else_if_statement .)
    CONST           reduce using rule 41 (else_if_statements -> else_if_statement .)
    ID              reduce using rule 41 (else_if_statements -> else_if_statement .)
    INCREMENT       reduce using rule 41 (else_if_statements -> else_if_statement .)
    DECREMENT       reduce using rule 41 (else_if_statements -> else_if_statement .)
    INT             reduce using rule 41 (else_if_statements -> else_if_statement .)
    FLOAT           reduce using rule 41 (else_if_statements -> else_if_statement .)
    DOUBLE          reduce using rule 41 (else_if_statements -> else_if_statement .)
    CHAR            reduce using rule 41 (else_if_statements -> else_if_statement .)
    BOOL            reduce using rule 41 (else_if_statements -> else_if_statement .)
    LONG            reduce using rule 41 (else_if_statements -> else_if_statement .)
    VOID            reduce using rule 41 (else_if_statements -> else_if_statement .)
    R_BRACE         reduce using rule 41 (else_if_statements -> else_if_statement .)
    ELSE            shift and go to state 152

  ! ELSE            [ reduce using rule 41 (else_if_statements -> else_if_statement .) ]

    else_if_statement              shift and go to state 151
    else_if_statements             shift and go to state 178

state 152

    (40) else_if_statement -> ELSE . IF L_BRACKET logical_expression R_BRACKET statements_block

    IF              shift and go to state 179


state 153

    (74) assign_expression -> ID assign_op . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    NEGATION        shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    value_expression               shift and go to state 180
    math_expression                shift and go to state 36
    logical_expression             shift and go to state 37
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 154

    (76) assign_expression -> ID unary_op .

    SEMICOLON       reduce using rule 76 (assign_expression -> ID unary_op .)
    R_BRACKET       reduce using rule 76 (assign_expression -> ID unary_op .)


state 155

    (113) assign_op -> ASSIGN .

    L_BRACKET       reduce using rule 113 (assign_op -> ASSIGN .)
    MINUS           reduce using rule 113 (assign_op -> ASSIGN .)
    INTEGER         reduce using rule 113 (assign_op -> ASSIGN .)
    DECIMAL         reduce using rule 113 (assign_op -> ASSIGN .)
    CHARACTER       reduce using rule 113 (assign_op -> ASSIGN .)
    ID              reduce using rule 113 (assign_op -> ASSIGN .)
    NEGATION        reduce using rule 113 (assign_op -> ASSIGN .)
    STRING          reduce using rule 113 (assign_op -> ASSIGN .)
    TRUE            reduce using rule 113 (assign_op -> ASSIGN .)
    FALSE           reduce using rule 113 (assign_op -> ASSIGN .)


state 156

    (114) assign_op -> PLUS_ASSIGN .

    L_BRACKET       reduce using rule 114 (assign_op -> PLUS_ASSIGN .)
    MINUS           reduce using rule 114 (assign_op -> PLUS_ASSIGN .)
    INTEGER         reduce using rule 114 (assign_op -> PLUS_ASSIGN .)
    DECIMAL         reduce using rule 114 (assign_op -> PLUS_ASSIGN .)
    CHARACTER       reduce using rule 114 (assign_op -> PLUS_ASSIGN .)
    ID              reduce using rule 114 (assign_op -> PLUS_ASSIGN .)
    NEGATION        reduce using rule 114 (assign_op -> PLUS_ASSIGN .)
    STRING          reduce using rule 114 (assign_op -> PLUS_ASSIGN .)
    TRUE            reduce using rule 114 (assign_op -> PLUS_ASSIGN .)
    FALSE           reduce using rule 114 (assign_op -> PLUS_ASSIGN .)


state 157

    (115) assign_op -> MINUS_ASSIGN .

    L_BRACKET       reduce using rule 115 (assign_op -> MINUS_ASSIGN .)
    MINUS           reduce using rule 115 (assign_op -> MINUS_ASSIGN .)
    INTEGER         reduce using rule 115 (assign_op -> MINUS_ASSIGN .)
    DECIMAL         reduce using rule 115 (assign_op -> MINUS_ASSIGN .)
    CHARACTER       reduce using rule 115 (assign_op -> MINUS_ASSIGN .)
    ID              reduce using rule 115 (assign_op -> MINUS_ASSIGN .)
    NEGATION        reduce using rule 115 (assign_op -> MINUS_ASSIGN .)
    STRING          reduce using rule 115 (assign_op -> MINUS_ASSIGN .)
    TRUE            reduce using rule 115 (assign_op -> MINUS_ASSIGN .)
    FALSE           reduce using rule 115 (assign_op -> MINUS_ASSIGN .)


state 158

    (116) assign_op -> MUL_ASSIGN .

    L_BRACKET       reduce using rule 116 (assign_op -> MUL_ASSIGN .)
    MINUS           reduce using rule 116 (assign_op -> MUL_ASSIGN .)
    INTEGER         reduce using rule 116 (assign_op -> MUL_ASSIGN .)
    DECIMAL         reduce using rule 116 (assign_op -> MUL_ASSIGN .)
    CHARACTER       reduce using rule 116 (assign_op -> MUL_ASSIGN .)
    ID              reduce using rule 116 (assign_op -> MUL_ASSIGN .)
    NEGATION        reduce using rule 116 (assign_op -> MUL_ASSIGN .)
    STRING          reduce using rule 116 (assign_op -> MUL_ASSIGN .)
    TRUE            reduce using rule 116 (assign_op -> MUL_ASSIGN .)
    FALSE           reduce using rule 116 (assign_op -> MUL_ASSIGN .)


state 159

    (117) assign_op -> DIV_ASSIGN .

    L_BRACKET       reduce using rule 117 (assign_op -> DIV_ASSIGN .)
    MINUS           reduce using rule 117 (assign_op -> DIV_ASSIGN .)
    INTEGER         reduce using rule 117 (assign_op -> DIV_ASSIGN .)
    DECIMAL         reduce using rule 117 (assign_op -> DIV_ASSIGN .)
    CHARACTER       reduce using rule 117 (assign_op -> DIV_ASSIGN .)
    ID              reduce using rule 117 (assign_op -> DIV_ASSIGN .)
    NEGATION        reduce using rule 117 (assign_op -> DIV_ASSIGN .)
    STRING          reduce using rule 117 (assign_op -> DIV_ASSIGN .)
    TRUE            reduce using rule 117 (assign_op -> DIV_ASSIGN .)
    FALSE           reduce using rule 117 (assign_op -> DIV_ASSIGN .)


state 160

    (118) assign_op -> MOD_ASSIGN .

    L_BRACKET       reduce using rule 118 (assign_op -> MOD_ASSIGN .)
    MINUS           reduce using rule 118 (assign_op -> MOD_ASSIGN .)
    INTEGER         reduce using rule 118 (assign_op -> MOD_ASSIGN .)
    DECIMAL         reduce using rule 118 (assign_op -> MOD_ASSIGN .)
    CHARACTER       reduce using rule 118 (assign_op -> MOD_ASSIGN .)
    ID              reduce using rule 118 (assign_op -> MOD_ASSIGN .)
    NEGATION        reduce using rule 118 (assign_op -> MOD_ASSIGN .)
    STRING          reduce using rule 118 (assign_op -> MOD_ASSIGN .)
    TRUE            reduce using rule 118 (assign_op -> MOD_ASSIGN .)
    FALSE           reduce using rule 118 (assign_op -> MOD_ASSIGN .)


state 161

    (29) assign_statement -> assign_expression SEMICOLON .

    COMMENT         reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    SEMICOLON       reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    RETURN          reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    WHILE           reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    DO              reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    BREAK           reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    FOR             reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    IF              reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    PRINTF          reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    SCANF           reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    CONST           reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    ID              reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    INCREMENT       reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    DECREMENT       reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    INT             reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    FLOAT           reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    DOUBLE          reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    CHAR            reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    BOOL            reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    LONG            reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    VOID            reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)
    R_BRACE         reduce using rule 29 (assign_statement -> assign_expression SEMICOLON .)


state 162

    (30) function_statement -> function_expression SEMICOLON .

    COMMENT         reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    SEMICOLON       reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    RETURN          reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    WHILE           reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    DO              reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    BREAK           reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    FOR             reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    IF              reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    PRINTF          reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    SCANF           reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    CONST           reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    ID              reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    INCREMENT       reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    DECREMENT       reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    INT             reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    FLOAT           reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    DOUBLE          reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    CHAR            reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    BOOL            reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    LONG            reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    VOID            reduce using rule 30 (function_statement -> function_expression SEMICOLON .)
    R_BRACE         reduce using rule 30 (function_statement -> function_expression SEMICOLON .)


state 163

    (31) return_statement -> RETURN value_expression . SEMICOLON
    (70) logical_expression -> value_expression . comparison_op value_expression
    (71) logical_expression -> value_expression .
    (107) comparison_op -> . EQUAL
    (108) comparison_op -> . NOT_EQUAL
    (109) comparison_op -> . GREATER
    (110) comparison_op -> . GREATER_EQUAL
    (111) comparison_op -> . LESSER
    (112) comparison_op -> . LESSER_EQUAL

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
    SEMICOLON       shift and go to state 181
    QUESTION_MARK   reduce using rule 71 (logical_expression -> value_expression .)
    AND             reduce using rule 71 (logical_expression -> value_expression .)
    OR              reduce using rule 71 (logical_expression -> value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

  ! SEMICOLON       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! EQUAL           [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER         [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER          [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 71 (logical_expression -> value_expression .) ]

    comparison_op                  shift and go to state 58

state 164

    (34) while_loop_statement -> WHILE L_BRACKET . logical_expression R_BRACKET statements_block
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    NEGATION        shift and go to state 47
    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    logical_expression             shift and go to state 182
    value_expression               shift and go to state 86
    math_expression                shift and go to state 36
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 165

    (35) do_while_loop_statement -> DO statements_block . WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON

    WHILE           shift and go to state 183


state 166

    (32) break_statement -> BREAK SEMICOLON .

    COMMENT         reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    DO              reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    IF              reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    PRINTF          reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    SCANF           reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    CONST           reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    ID              reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    INCREMENT       reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    DECREMENT       reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    INT             reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    DOUBLE          reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    CHAR            reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    BOOL            reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    LONG            reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    VOID            reduce using rule 32 (break_statement -> BREAK SEMICOLON .)
    R_BRACE         reduce using rule 32 (break_statement -> BREAK SEMICOLON .)


state 167

    (36) for_loop_statement -> FOR L_BRACKET . decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block
    (37) decl_stat_or_sem -> . declaration_statement
    (38) decl_stat_or_sem -> . SEMICOLON
    (27) declaration_statement -> . opt_const type ID opt_array_mark
    (28) declaration_statement -> . opt_const type ID opt_array_mark ASSIGN declaration_value_expression SEMICOLON
    (120) opt_const -> . CONST
    (121) opt_const -> . empty
    (130) empty -> .

    SEMICOLON       shift and go to state 185
    CONST           shift and go to state 10
    INT             reduce using rule 130 (empty -> .)
    FLOAT           reduce using rule 130 (empty -> .)
    DOUBLE          reduce using rule 130 (empty -> .)
    CHAR            reduce using rule 130 (empty -> .)
    BOOL            reduce using rule 130 (empty -> .)
    LONG            reduce using rule 130 (empty -> .)
    VOID            reduce using rule 130 (empty -> .)

    decl_stat_or_sem               shift and go to state 184
    declaration_statement          shift and go to state 186
    opt_const                      shift and go to state 8
    empty                          shift and go to state 11

state 168

    (39) if_statement -> IF L_BRACKET . logical_expression R_BRACKET statements_block
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    NEGATION        shift and go to state 47
    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    logical_expression             shift and go to state 187
    value_expression               shift and go to state 86
    math_expression                shift and go to state 36
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 169

    (48) print_statement -> PRINTF L_BRACKET . value_expression R_BRACKET
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    NEGATION        shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    value_expression               shift and go to state 188
    math_expression                shift and go to state 36
    logical_expression             shift and go to state 37
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 170

    (49) scan_statement -> SCANF L_BRACKET . AMPERSAND ID R_BRACKET

    AMPERSAND       shift and go to state 189


state 171

    (75) assign_expression -> unary_op ID .

    SEMICOLON       reduce using rule 75 (assign_expression -> unary_op ID .)
    R_BRACKET       reduce using rule 75 (assign_expression -> unary_op ID .)


state 172

    (97) listed_values -> listed_values COMMA listed_values .
    (97) listed_values -> listed_values . COMMA listed_values

  ! shift/reduce conflict for COMMA resolved as shift
    R_BRACE         reduce using rule 97 (listed_values -> listed_values COMMA listed_values .)
    R_BRACKET       reduce using rule 97 (listed_values -> listed_values COMMA listed_values .)
    COMMA           shift and go to state 141

  ! COMMA           [ reduce using rule 97 (listed_values -> listed_values COMMA listed_values .) ]


state 173

    (73) trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .
    (70) logical_expression -> value_expression . comparison_op value_expression
    (71) logical_expression -> value_expression .
    (107) comparison_op -> . EQUAL
    (108) comparison_op -> . NOT_EQUAL
    (109) comparison_op -> . GREATER
    (110) comparison_op -> . GREATER_EQUAL
    (111) comparison_op -> . LESSER
    (112) comparison_op -> . LESSER_EQUAL

  ! reduce/reduce conflict for EQUAL resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for GREATER resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for LESSER resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for LESSER_EQUAL resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for AND resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for OR resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for R_SQUARE_BRACKET resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for R_BRACKET resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for R_BRACE resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for COLON resolved using rule 71 (logical_expression -> value_expression .)
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
    QUESTION_MARK   reduce using rule 71 (logical_expression -> value_expression .)
    AND             reduce using rule 71 (logical_expression -> value_expression .)
    OR              reduce using rule 71 (logical_expression -> value_expression .)
    R_SQUARE_BRACKET reduce using rule 71 (logical_expression -> value_expression .)
    SEMICOLON       reduce using rule 71 (logical_expression -> value_expression .)
    R_BRACKET       reduce using rule 71 (logical_expression -> value_expression .)
    R_BRACE         reduce using rule 71 (logical_expression -> value_expression .)
    COMMA           reduce using rule 71 (logical_expression -> value_expression .)
    COLON           reduce using rule 71 (logical_expression -> value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

  ! EQUAL           [ reduce using rule 73 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 73 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! GREATER         [ reduce using rule 73 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 73 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! LESSER          [ reduce using rule 73 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 73 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! R_SQUARE_BRACKET [ reduce using rule 73 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! QUESTION_MARK   [ reduce using rule 73 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! AND             [ reduce using rule 73 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! OR              [ reduce using rule 73 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! SEMICOLON       [ reduce using rule 73 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! R_BRACKET       [ reduce using rule 73 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! R_BRACE         [ reduce using rule 73 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! COMMA           [ reduce using rule 73 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! COLON           [ reduce using rule 73 (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression .) ]
  ! EQUAL           [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER         [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER          [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 71 (logical_expression -> value_expression .) ]

    comparison_op                  shift and go to state 58

state 174

    (24) any_statement -> if_statement opt_else_if_statements opt_else_statement .

    COMMENT         reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    SEMICOLON       reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    RETURN          reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    WHILE           reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    DO              reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    BREAK           reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    FOR             reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    IF              reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    PRINTF          reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    SCANF           reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    CONST           reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    ID              reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    INCREMENT       reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    DECREMENT       reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    INT             reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    FLOAT           reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    DOUBLE          reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    CHAR            reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    BOOL            reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    LONG            reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    VOID            reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)
    R_BRACE         reduce using rule 24 (any_statement -> if_statement opt_else_if_statements opt_else_statement .)


state 175

    (46) opt_else_statement -> else_statement .

    COMMENT         reduce using rule 46 (opt_else_statement -> else_statement .)
    SEMICOLON       reduce using rule 46 (opt_else_statement -> else_statement .)
    RETURN          reduce using rule 46 (opt_else_statement -> else_statement .)
    WHILE           reduce using rule 46 (opt_else_statement -> else_statement .)
    DO              reduce using rule 46 (opt_else_statement -> else_statement .)
    BREAK           reduce using rule 46 (opt_else_statement -> else_statement .)
    FOR             reduce using rule 46 (opt_else_statement -> else_statement .)
    IF              reduce using rule 46 (opt_else_statement -> else_statement .)
    PRINTF          reduce using rule 46 (opt_else_statement -> else_statement .)
    SCANF           reduce using rule 46 (opt_else_statement -> else_statement .)
    CONST           reduce using rule 46 (opt_else_statement -> else_statement .)
    ID              reduce using rule 46 (opt_else_statement -> else_statement .)
    INCREMENT       reduce using rule 46 (opt_else_statement -> else_statement .)
    DECREMENT       reduce using rule 46 (opt_else_statement -> else_statement .)
    INT             reduce using rule 46 (opt_else_statement -> else_statement .)
    FLOAT           reduce using rule 46 (opt_else_statement -> else_statement .)
    DOUBLE          reduce using rule 46 (opt_else_statement -> else_statement .)
    CHAR            reduce using rule 46 (opt_else_statement -> else_statement .)
    BOOL            reduce using rule 46 (opt_else_statement -> else_statement .)
    LONG            reduce using rule 46 (opt_else_statement -> else_statement .)
    VOID            reduce using rule 46 (opt_else_statement -> else_statement .)
    R_BRACE         reduce using rule 46 (opt_else_statement -> else_statement .)


state 176

    (47) opt_else_statement -> empty .

    COMMENT         reduce using rule 47 (opt_else_statement -> empty .)
    SEMICOLON       reduce using rule 47 (opt_else_statement -> empty .)
    RETURN          reduce using rule 47 (opt_else_statement -> empty .)
    WHILE           reduce using rule 47 (opt_else_statement -> empty .)
    DO              reduce using rule 47 (opt_else_statement -> empty .)
    BREAK           reduce using rule 47 (opt_else_statement -> empty .)
    FOR             reduce using rule 47 (opt_else_statement -> empty .)
    IF              reduce using rule 47 (opt_else_statement -> empty .)
    PRINTF          reduce using rule 47 (opt_else_statement -> empty .)
    SCANF           reduce using rule 47 (opt_else_statement -> empty .)
    CONST           reduce using rule 47 (opt_else_statement -> empty .)
    ID              reduce using rule 47 (opt_else_statement -> empty .)
    INCREMENT       reduce using rule 47 (opt_else_statement -> empty .)
    DECREMENT       reduce using rule 47 (opt_else_statement -> empty .)
    INT             reduce using rule 47 (opt_else_statement -> empty .)
    FLOAT           reduce using rule 47 (opt_else_statement -> empty .)
    DOUBLE          reduce using rule 47 (opt_else_statement -> empty .)
    CHAR            reduce using rule 47 (opt_else_statement -> empty .)
    BOOL            reduce using rule 47 (opt_else_statement -> empty .)
    LONG            reduce using rule 47 (opt_else_statement -> empty .)
    VOID            reduce using rule 47 (opt_else_statement -> empty .)
    R_BRACE         reduce using rule 47 (opt_else_statement -> empty .)


state 177

    (45) else_statement -> ELSE .

    COMMENT         reduce using rule 45 (else_statement -> ELSE .)
    SEMICOLON       reduce using rule 45 (else_statement -> ELSE .)
    RETURN          reduce using rule 45 (else_statement -> ELSE .)
    WHILE           reduce using rule 45 (else_statement -> ELSE .)
    DO              reduce using rule 45 (else_statement -> ELSE .)
    BREAK           reduce using rule 45 (else_statement -> ELSE .)
    FOR             reduce using rule 45 (else_statement -> ELSE .)
    IF              reduce using rule 45 (else_statement -> ELSE .)
    PRINTF          reduce using rule 45 (else_statement -> ELSE .)
    SCANF           reduce using rule 45 (else_statement -> ELSE .)
    CONST           reduce using rule 45 (else_statement -> ELSE .)
    ID              reduce using rule 45 (else_statement -> ELSE .)
    INCREMENT       reduce using rule 45 (else_statement -> ELSE .)
    DECREMENT       reduce using rule 45 (else_statement -> ELSE .)
    INT             reduce using rule 45 (else_statement -> ELSE .)
    FLOAT           reduce using rule 45 (else_statement -> ELSE .)
    DOUBLE          reduce using rule 45 (else_statement -> ELSE .)
    CHAR            reduce using rule 45 (else_statement -> ELSE .)
    BOOL            reduce using rule 45 (else_statement -> ELSE .)
    LONG            reduce using rule 45 (else_statement -> ELSE .)
    VOID            reduce using rule 45 (else_statement -> ELSE .)
    R_BRACE         reduce using rule 45 (else_statement -> ELSE .)


state 178

    (42) else_if_statements -> else_if_statement else_if_statements .

    ELSE            reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    COMMENT         reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    SEMICOLON       reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    RETURN          reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    WHILE           reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    DO              reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    BREAK           reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    FOR             reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    IF              reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    PRINTF          reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    SCANF           reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    CONST           reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    ID              reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    INCREMENT       reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    DECREMENT       reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    INT             reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    FLOAT           reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    DOUBLE          reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    CHAR            reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    BOOL            reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    LONG            reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    VOID            reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)
    R_BRACE         reduce using rule 42 (else_if_statements -> else_if_statement else_if_statements .)


state 179

    (40) else_if_statement -> ELSE IF . L_BRACKET logical_expression R_BRACKET statements_block

    L_BRACKET       shift and go to state 190


state 180

    (74) assign_expression -> ID assign_op value_expression .
    (70) logical_expression -> value_expression . comparison_op value_expression
    (71) logical_expression -> value_expression .
    (107) comparison_op -> . EQUAL
    (108) comparison_op -> . NOT_EQUAL
    (109) comparison_op -> . GREATER
    (110) comparison_op -> . GREATER_EQUAL
    (111) comparison_op -> . LESSER
    (112) comparison_op -> . LESSER_EQUAL

  ! reduce/reduce conflict for SEMICOLON resolved using rule 71 (logical_expression -> value_expression .)
  ! reduce/reduce conflict for R_BRACKET resolved using rule 71 (logical_expression -> value_expression .)
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
    SEMICOLON       reduce using rule 71 (logical_expression -> value_expression .)
    QUESTION_MARK   reduce using rule 71 (logical_expression -> value_expression .)
    AND             reduce using rule 71 (logical_expression -> value_expression .)
    OR              reduce using rule 71 (logical_expression -> value_expression .)
    R_BRACKET       reduce using rule 71 (logical_expression -> value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

  ! SEMICOLON       [ reduce using rule 74 (assign_expression -> ID assign_op value_expression .) ]
  ! R_BRACKET       [ reduce using rule 74 (assign_expression -> ID assign_op value_expression .) ]
  ! EQUAL           [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER         [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER          [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 71 (logical_expression -> value_expression .) ]

    comparison_op                  shift and go to state 58

state 181

    (31) return_statement -> RETURN value_expression SEMICOLON .

    COMMENT         reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    SEMICOLON       reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    RETURN          reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    WHILE           reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    DO              reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    BREAK           reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    FOR             reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    IF              reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    PRINTF          reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    SCANF           reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    CONST           reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    ID              reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    INCREMENT       reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    DECREMENT       reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    INT             reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    FLOAT           reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    DOUBLE          reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    CHAR            reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    BOOL            reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    LONG            reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    VOID            reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)
    R_BRACE         reduce using rule 31 (return_statement -> RETURN value_expression SEMICOLON .)


state 182

    (34) while_loop_statement -> WHILE L_BRACKET logical_expression . R_BRACKET statements_block
    (68) logical_expression -> logical_expression . bool_op logical_expression
    (54) value_expression -> logical_expression .
    (73) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (105) bool_op -> . AND
    (106) bool_op -> . OR

  ! shift/reduce conflict for R_BRACKET resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    R_BRACKET       shift and go to state 191
    EQUAL           reduce using rule 54 (value_expression -> logical_expression .)
    NOT_EQUAL       reduce using rule 54 (value_expression -> logical_expression .)
    GREATER         reduce using rule 54 (value_expression -> logical_expression .)
    GREATER_EQUAL   reduce using rule 54 (value_expression -> logical_expression .)
    LESSER          reduce using rule 54 (value_expression -> logical_expression .)
    LESSER_EQUAL    reduce using rule 54 (value_expression -> logical_expression .)
    QUESTION_MARK   shift and go to state 72
    AND             shift and go to state 73
    OR              shift and go to state 74

  ! R_BRACKET       [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! QUESTION_MARK   [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! AND             [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! OR              [ reduce using rule 54 (value_expression -> logical_expression .) ]

    bool_op                        shift and go to state 71

state 183

    (35) do_while_loop_statement -> DO statements_block WHILE . L_BRACKET logical_expression R_BRACKET SEMICOLON

    L_BRACKET       shift and go to state 192


state 184

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem . opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block
    (77) opt_logical_expression -> . logical_expression
    (78) opt_logical_expression -> . empty
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (130) empty -> .
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    NEGATION        shift and go to state 47
    SEMICOLON       reduce using rule 130 (empty -> .)
    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    opt_logical_expression         shift and go to state 193
    logical_expression             shift and go to state 194
    empty                          shift and go to state 195
    value_expression               shift and go to state 86
    math_expression                shift and go to state 36
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 185

    (38) decl_stat_or_sem -> SEMICOLON .

    NEGATION        reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    L_BRACKET       reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    MINUS           reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    INTEGER         reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    DECIMAL         reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    CHARACTER       reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    ID              reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    STRING          reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    TRUE            reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    FALSE           reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)
    SEMICOLON       reduce using rule 38 (decl_stat_or_sem -> SEMICOLON .)


state 186

    (37) decl_stat_or_sem -> declaration_statement .

    NEGATION        reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    L_BRACKET       reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    MINUS           reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    INTEGER         reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    DECIMAL         reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    CHARACTER       reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    ID              reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    STRING          reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    TRUE            reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    FALSE           reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)
    SEMICOLON       reduce using rule 37 (decl_stat_or_sem -> declaration_statement .)


state 187

    (39) if_statement -> IF L_BRACKET logical_expression . R_BRACKET statements_block
    (68) logical_expression -> logical_expression . bool_op logical_expression
    (54) value_expression -> logical_expression .
    (73) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (105) bool_op -> . AND
    (106) bool_op -> . OR

  ! shift/reduce conflict for R_BRACKET resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    R_BRACKET       shift and go to state 196
    EQUAL           reduce using rule 54 (value_expression -> logical_expression .)
    NOT_EQUAL       reduce using rule 54 (value_expression -> logical_expression .)
    GREATER         reduce using rule 54 (value_expression -> logical_expression .)
    GREATER_EQUAL   reduce using rule 54 (value_expression -> logical_expression .)
    LESSER          reduce using rule 54 (value_expression -> logical_expression .)
    LESSER_EQUAL    reduce using rule 54 (value_expression -> logical_expression .)
    QUESTION_MARK   shift and go to state 72
    AND             shift and go to state 73
    OR              shift and go to state 74

  ! R_BRACKET       [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! QUESTION_MARK   [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! AND             [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! OR              [ reduce using rule 54 (value_expression -> logical_expression .) ]

    bool_op                        shift and go to state 71

state 188

    (48) print_statement -> PRINTF L_BRACKET value_expression . R_BRACKET
    (70) logical_expression -> value_expression . comparison_op value_expression
    (71) logical_expression -> value_expression .
    (107) comparison_op -> . EQUAL
    (108) comparison_op -> . NOT_EQUAL
    (109) comparison_op -> . GREATER
    (110) comparison_op -> . GREATER_EQUAL
    (111) comparison_op -> . LESSER
    (112) comparison_op -> . LESSER_EQUAL

  ! shift/reduce conflict for R_BRACKET resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for LESSER_EQUAL resolved as shift
    R_BRACKET       shift and go to state 197
    QUESTION_MARK   reduce using rule 71 (logical_expression -> value_expression .)
    AND             reduce using rule 71 (logical_expression -> value_expression .)
    OR              reduce using rule 71 (logical_expression -> value_expression .)
    EQUAL           shift and go to state 59
    NOT_EQUAL       shift and go to state 60
    GREATER         shift and go to state 61
    GREATER_EQUAL   shift and go to state 62
    LESSER          shift and go to state 63
    LESSER_EQUAL    shift and go to state 64

  ! R_BRACKET       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! EQUAL           [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! NOT_EQUAL       [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER         [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER          [ reduce using rule 71 (logical_expression -> value_expression .) ]
  ! LESSER_EQUAL    [ reduce using rule 71 (logical_expression -> value_expression .) ]

    comparison_op                  shift and go to state 58

state 189

    (49) scan_statement -> SCANF L_BRACKET AMPERSAND . ID R_BRACKET

    ID              shift and go to state 198


state 190

    (40) else_if_statement -> ELSE IF L_BRACKET . logical_expression R_BRACKET statements_block
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    NEGATION        shift and go to state 47
    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    logical_expression             shift and go to state 199
    value_expression               shift and go to state 86
    math_expression                shift and go to state 36
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 191

    (34) while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 89

    statements_block               shift and go to state 200

state 192

    (35) do_while_loop_statement -> DO statements_block WHILE L_BRACKET . logical_expression R_BRACKET SEMICOLON
    (68) logical_expression -> . logical_expression bool_op logical_expression
    (69) logical_expression -> . NEGATION logical_expression
    (70) logical_expression -> . value_expression comparison_op value_expression
    (71) logical_expression -> . value_expression
    (53) value_expression -> . math_expression
    (54) value_expression -> . logical_expression
    (55) value_expression -> . function_expression
    (56) value_expression -> . value
    (57) value_expression -> . trinary_mark_expression
    (58) value_expression -> . L_BRACKET value_expression R_BRACKET
    (61) math_expression -> . math_expression math_op math_expression
    (62) math_expression -> . MINUS math_expression
    (63) math_expression -> . INTEGER
    (64) math_expression -> . DECIMAL
    (65) math_expression -> . CHARACTER
    (66) math_expression -> . ID
    (67) math_expression -> . L_BRACKET math_expression R_BRACKET
    (72) function_expression -> . ID L_BRACKET opt_listed_values R_BRACKET
    (88) value -> . INTEGER
    (89) value -> . DECIMAL
    (90) value -> . CHARACTER
    (91) value -> . STRING
    (92) value -> . TRUE
    (93) value -> . FALSE
    (94) value -> . ID
    (95) value -> . ID L_SQUARE_BRACKET value_expression R_SQUARE_BRACKET
    (73) trinary_mark_expression -> . logical_expression QUESTION_MARK value_expression COLON value_expression

    NEGATION        shift and go to state 47
    L_BRACKET       shift and go to state 41
    MINUS           shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    CHARACTER       shift and go to state 45
    ID              shift and go to state 46
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    logical_expression             shift and go to state 201
    value_expression               shift and go to state 86
    math_expression                shift and go to state 36
    function_expression            shift and go to state 38
    value                          shift and go to state 39
    trinary_mark_expression        shift and go to state 40

state 193

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression . SEMICOLON opt_assign_expression R_BRACKET statements_block

    SEMICOLON       shift and go to state 202


state 194

    (77) opt_logical_expression -> logical_expression .
    (68) logical_expression -> logical_expression . bool_op logical_expression
    (54) value_expression -> logical_expression .
    (73) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (105) bool_op -> . AND
    (106) bool_op -> . OR

  ! reduce/reduce conflict for SEMICOLON resolved using rule 54 (value_expression -> logical_expression .)
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    EQUAL           reduce using rule 54 (value_expression -> logical_expression .)
    NOT_EQUAL       reduce using rule 54 (value_expression -> logical_expression .)
    GREATER         reduce using rule 54 (value_expression -> logical_expression .)
    GREATER_EQUAL   reduce using rule 54 (value_expression -> logical_expression .)
    LESSER          reduce using rule 54 (value_expression -> logical_expression .)
    LESSER_EQUAL    reduce using rule 54 (value_expression -> logical_expression .)
    SEMICOLON       reduce using rule 54 (value_expression -> logical_expression .)
    QUESTION_MARK   shift and go to state 72
    AND             shift and go to state 73
    OR              shift and go to state 74

  ! SEMICOLON       [ reduce using rule 77 (opt_logical_expression -> logical_expression .) ]
  ! QUESTION_MARK   [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! AND             [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! OR              [ reduce using rule 54 (value_expression -> logical_expression .) ]

    bool_op                        shift and go to state 71

state 195

    (78) opt_logical_expression -> empty .

    SEMICOLON       reduce using rule 78 (opt_logical_expression -> empty .)


state 196

    (39) if_statement -> IF L_BRACKET logical_expression R_BRACKET . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 89

    statements_block               shift and go to state 203

state 197

    (48) print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .

    COMMENT         reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    SEMICOLON       reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    RETURN          reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    WHILE           reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    DO              reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    BREAK           reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    FOR             reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    IF              reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    PRINTF          reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    SCANF           reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    CONST           reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    ID              reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    INCREMENT       reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    DECREMENT       reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    INT             reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    FLOAT           reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    DOUBLE          reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    CHAR            reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    BOOL            reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    LONG            reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    VOID            reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)
    R_BRACE         reduce using rule 48 (print_statement -> PRINTF L_BRACKET value_expression R_BRACKET .)


state 198

    (49) scan_statement -> SCANF L_BRACKET AMPERSAND ID . R_BRACKET

    R_BRACKET       shift and go to state 204


state 199

    (40) else_if_statement -> ELSE IF L_BRACKET logical_expression . R_BRACKET statements_block
    (68) logical_expression -> logical_expression . bool_op logical_expression
    (54) value_expression -> logical_expression .
    (73) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (105) bool_op -> . AND
    (106) bool_op -> . OR

  ! shift/reduce conflict for R_BRACKET resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    R_BRACKET       shift and go to state 205
    EQUAL           reduce using rule 54 (value_expression -> logical_expression .)
    NOT_EQUAL       reduce using rule 54 (value_expression -> logical_expression .)
    GREATER         reduce using rule 54 (value_expression -> logical_expression .)
    GREATER_EQUAL   reduce using rule 54 (value_expression -> logical_expression .)
    LESSER          reduce using rule 54 (value_expression -> logical_expression .)
    LESSER_EQUAL    reduce using rule 54 (value_expression -> logical_expression .)
    QUESTION_MARK   shift and go to state 72
    AND             shift and go to state 73
    OR              shift and go to state 74

  ! R_BRACKET       [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! QUESTION_MARK   [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! AND             [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! OR              [ reduce using rule 54 (value_expression -> logical_expression .) ]

    bool_op                        shift and go to state 71

state 200

    (34) while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .

    COMMENT         reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    SEMICOLON       reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    RETURN          reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    WHILE           reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    DO              reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    BREAK           reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    FOR             reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    IF              reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    PRINTF          reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    SCANF           reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    CONST           reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    ID              reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    INCREMENT       reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    DECREMENT       reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    INT             reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    FLOAT           reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    DOUBLE          reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    CHAR            reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    BOOL            reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    LONG            reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    VOID            reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)
    R_BRACE         reduce using rule 34 (while_loop_statement -> WHILE L_BRACKET logical_expression R_BRACKET statements_block .)


state 201

    (35) do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression . R_BRACKET SEMICOLON
    (68) logical_expression -> logical_expression . bool_op logical_expression
    (54) value_expression -> logical_expression .
    (73) trinary_mark_expression -> logical_expression . QUESTION_MARK value_expression COLON value_expression
    (105) bool_op -> . AND
    (106) bool_op -> . OR

  ! shift/reduce conflict for R_BRACKET resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    R_BRACKET       shift and go to state 206
    EQUAL           reduce using rule 54 (value_expression -> logical_expression .)
    NOT_EQUAL       reduce using rule 54 (value_expression -> logical_expression .)
    GREATER         reduce using rule 54 (value_expression -> logical_expression .)
    GREATER_EQUAL   reduce using rule 54 (value_expression -> logical_expression .)
    LESSER          reduce using rule 54 (value_expression -> logical_expression .)
    LESSER_EQUAL    reduce using rule 54 (value_expression -> logical_expression .)
    QUESTION_MARK   shift and go to state 72
    AND             shift and go to state 73
    OR              shift and go to state 74

  ! R_BRACKET       [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! QUESTION_MARK   [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! AND             [ reduce using rule 54 (value_expression -> logical_expression .) ]
  ! OR              [ reduce using rule 54 (value_expression -> logical_expression .) ]

    bool_op                        shift and go to state 71

state 202

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON . opt_assign_expression R_BRACKET statements_block
    (79) opt_assign_expression -> . assign_expression
    (80) opt_assign_expression -> . empty
    (74) assign_expression -> . ID assign_op value_expression
    (75) assign_expression -> . unary_op ID
    (76) assign_expression -> . ID unary_op
    (130) empty -> .
    (103) unary_op -> . INCREMENT
    (104) unary_op -> . DECREMENT

    ID              shift and go to state 210
    R_BRACKET       reduce using rule 130 (empty -> .)
    INCREMENT       shift and go to state 138
    DECREMENT       shift and go to state 139

    opt_assign_expression          shift and go to state 207
    assign_expression              shift and go to state 208
    empty                          shift and go to state 209
    unary_op                       shift and go to state 137

state 203

    (39) if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .

    ELSE            reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    COMMENT         reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    SEMICOLON       reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    RETURN          reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    WHILE           reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    DO              reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    BREAK           reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    FOR             reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    IF              reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    PRINTF          reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    SCANF           reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    CONST           reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    ID              reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    INCREMENT       reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    DECREMENT       reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    INT             reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    FLOAT           reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    DOUBLE          reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    CHAR            reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    BOOL            reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    LONG            reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    VOID            reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)
    R_BRACE         reduce using rule 39 (if_statement -> IF L_BRACKET logical_expression R_BRACKET statements_block .)


state 204

    (49) scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .

    COMMENT         reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    SEMICOLON       reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    RETURN          reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    WHILE           reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    DO              reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    BREAK           reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    FOR             reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    IF              reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    PRINTF          reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    SCANF           reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    CONST           reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    ID              reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    INCREMENT       reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    DECREMENT       reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    INT             reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    FLOAT           reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    DOUBLE          reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    CHAR            reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    BOOL            reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    LONG            reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    VOID            reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)
    R_BRACE         reduce using rule 49 (scan_statement -> SCANF L_BRACKET AMPERSAND ID R_BRACKET .)


state 205

    (40) else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 89

    statements_block               shift and go to state 211

state 206

    (35) do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET . SEMICOLON

    SEMICOLON       shift and go to state 212


state 207

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression . R_BRACKET statements_block

    R_BRACKET       shift and go to state 213


state 208

    (79) opt_assign_expression -> assign_expression .

    R_BRACKET       reduce using rule 79 (opt_assign_expression -> assign_expression .)


state 209

    (80) opt_assign_expression -> empty .

    R_BRACKET       reduce using rule 80 (opt_assign_expression -> empty .)


state 210

    (74) assign_expression -> ID . assign_op value_expression
    (76) assign_expression -> ID . unary_op
    (113) assign_op -> . ASSIGN
    (114) assign_op -> . PLUS_ASSIGN
    (115) assign_op -> . MINUS_ASSIGN
    (116) assign_op -> . MUL_ASSIGN
    (117) assign_op -> . DIV_ASSIGN
    (118) assign_op -> . MOD_ASSIGN
    (103) unary_op -> . INCREMENT
    (104) unary_op -> . DECREMENT

    ASSIGN          shift and go to state 155
    PLUS_ASSIGN     shift and go to state 156
    MINUS_ASSIGN    shift and go to state 157
    MUL_ASSIGN      shift and go to state 158
    DIV_ASSIGN      shift and go to state 159
    MOD_ASSIGN      shift and go to state 160
    INCREMENT       shift and go to state 138
    DECREMENT       shift and go to state 139

    assign_op                      shift and go to state 153
    unary_op                       shift and go to state 154

state 211

    (40) else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .

    ELSE            reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    COMMENT         reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    SEMICOLON       reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    RETURN          reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    WHILE           reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    DO              reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    BREAK           reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    FOR             reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    IF              reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    PRINTF          reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    SCANF           reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    CONST           reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    ID              reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    INCREMENT       reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    DECREMENT       reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    INT             reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    FLOAT           reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    DOUBLE          reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    CHAR            reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    BOOL            reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    LONG            reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    VOID            reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)
    R_BRACE         reduce using rule 40 (else_if_statement -> ELSE IF L_BRACKET logical_expression R_BRACKET statements_block .)


state 212

    (35) do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .

    COMMENT         reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    RETURN          reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    WHILE           reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    DO              reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    BREAK           reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    FOR             reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    IF              reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    PRINTF          reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    SCANF           reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    CONST           reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    ID              reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    INCREMENT       reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    DECREMENT       reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    INT             reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    FLOAT           reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    DOUBLE          reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    CHAR            reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    BOOL            reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    LONG            reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    VOID            reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)
    R_BRACE         reduce using rule 35 (do_while_loop_statement -> DO statements_block WHILE L_BRACKET logical_expression R_BRACKET SEMICOLON .)


state 213

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET . statements_block
    (15) statements_block -> . L_BRACE opt_statements R_BRACE

    L_BRACE         shift and go to state 89

    statements_block               shift and go to state 214

state 214

    (36) for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .

    COMMENT         reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    SEMICOLON       reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    RETURN          reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    WHILE           reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    DO              reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    BREAK           reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    FOR             reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    IF              reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    PRINTF          reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    SCANF           reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    CONST           reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    ID              reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    INCREMENT       reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    DECREMENT       reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    INT             reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    FLOAT           reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    DOUBLE          reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    CHAR            reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    BOOL            reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    LONG            reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    VOID            reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)
    R_BRACE         reduce using rule 36 (for_loop_statement -> FOR L_BRACKET decl_stat_or_sem opt_logical_expression SEMICOLON opt_assign_expression R_BRACKET statements_block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 0 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 0 resolved as shift
WARNING: shift/reduce conflict for LONG in state 0 resolved as shift
WARNING: shift/reduce conflict for VOID in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 3 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 3 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 3 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 3 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 3 resolved as shift
WARNING: shift/reduce conflict for LONG in state 3 resolved as shift
WARNING: shift/reduce conflict for VOID in state 3 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 34 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 34 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 34 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 34 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 34 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 34 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 37 resolved as shift
WARNING: shift/reduce conflict for AND in state 37 resolved as shift
WARNING: shift/reduce conflict for OR in state 37 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 55 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 55 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 55 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 55 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 55 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 55 resolved as shift
WARNING: shift/reduce conflict for R_BRACKET in state 75 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 75 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 75 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 75 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 75 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 75 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 75 resolved as shift
WARNING: shift/reduce conflict for R_BRACKET in state 76 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 77 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 77 resolved as shift
WARNING: shift/reduce conflict for MUL in state 77 resolved as shift
WARNING: shift/reduce conflict for DIV in state 77 resolved as shift
WARNING: shift/reduce conflict for MOD in state 77 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 85 resolved as shift
WARNING: shift/reduce conflict for AND in state 85 resolved as shift
WARNING: shift/reduce conflict for OR in state 85 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 86 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 86 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 86 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 86 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 86 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 86 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 94 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 94 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 94 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 94 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 94 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 94 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 95 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 95 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 95 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 95 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 95 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 95 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 96 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 96 resolved as shift
WARNING: shift/reduce conflict for MUL in state 96 resolved as shift
WARNING: shift/reduce conflict for DIV in state 96 resolved as shift
WARNING: shift/reduce conflict for MOD in state 96 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 97 resolved as shift
WARNING: shift/reduce conflict for AND in state 97 resolved as shift
WARNING: shift/reduce conflict for OR in state 97 resolved as shift
WARNING: shift/reduce conflict for COLON in state 98 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 98 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 98 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 98 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 98 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 98 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 98 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 105 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 105 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 105 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 105 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 105 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 105 resolved as shift
WARNING: shift/reduce conflict for R_SQUARE_BRACKET in state 106 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 106 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 106 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 123 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 151 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 163 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 163 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 163 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 163 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 163 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 163 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 163 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 172 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 173 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 173 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 180 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 180 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 180 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 180 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 180 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 180 resolved as shift
WARNING: shift/reduce conflict for R_BRACKET in state 182 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 182 resolved as shift
WARNING: shift/reduce conflict for AND in state 182 resolved as shift
WARNING: shift/reduce conflict for OR in state 182 resolved as shift
WARNING: shift/reduce conflict for R_BRACKET in state 187 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 187 resolved as shift
WARNING: shift/reduce conflict for AND in state 187 resolved as shift
WARNING: shift/reduce conflict for OR in state 187 resolved as shift
WARNING: shift/reduce conflict for R_BRACKET in state 188 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 188 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 188 resolved as shift
WARNING: shift/reduce conflict for LESSER_EQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 194 resolved as shift
WARNING: shift/reduce conflict for AND in state 194 resolved as shift
WARNING: shift/reduce conflict for OR in state 194 resolved as shift
WARNING: shift/reduce conflict for R_BRACKET in state 199 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 199 resolved as shift
WARNING: shift/reduce conflict for AND in state 199 resolved as shift
WARNING: shift/reduce conflict for OR in state 199 resolved as shift
WARNING: shift/reduce conflict for R_BRACKET in state 201 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 201 resolved as shift
WARNING: shift/reduce conflict for AND in state 201 resolved as shift
WARNING: shift/reduce conflict for OR in state 201 resolved as shift
WARNING: reduce/reduce conflict in state 34 resolved using rule (opt_value_expression -> value_expression)
WARNING: rejected rule (logical_expression -> value_expression) in state 34
WARNING: reduce/reduce conflict in state 43 resolved using rule (math_expression -> INTEGER)
WARNING: rejected rule (value -> INTEGER) in state 43
WARNING: reduce/reduce conflict in state 44 resolved using rule (math_expression -> DECIMAL)
WARNING: rejected rule (value -> DECIMAL) in state 44
WARNING: reduce/reduce conflict in state 45 resolved using rule (math_expression -> CHARACTER)
WARNING: rejected rule (value -> CHARACTER) in state 45
WARNING: reduce/reduce conflict in state 46 resolved using rule (math_expression -> ID)
WARNING: rejected rule (value -> ID) in state 46
WARNING: reduce/reduce conflict in state 55 resolved using rule (declaration_value_expression -> value_expression)
WARNING: rejected rule (logical_expression -> value_expression) in state 55
WARNING: reduce/reduce conflict in state 85 resolved using rule (value_expression -> logical_expression)
WARNING: rejected rule (logical_expression -> NEGATION logical_expression) in state 85
WARNING: reduce/reduce conflict in state 94 resolved using rule (declaration_value_expression -> value_expression)
WARNING: rejected rule (listed_values -> value_expression) in state 94
WARNING: reduce/reduce conflict in state 94 resolved using rule (declaration_value_expression -> value_expression)
WARNING: rejected rule (logical_expression -> value_expression) in state 94
WARNING: reduce/reduce conflict in state 94 resolved using rule (logical_expression -> value_expression)
WARNING: rejected rule (listed_values -> value_expression) in state 94
WARNING: reduce/reduce conflict in state 95 resolved using rule (logical_expression -> value_expression comparison_op value_expression)
WARNING: rejected rule (logical_expression -> value_expression) in state 95
WARNING: reduce/reduce conflict in state 97 resolved using rule (value_expression -> logical_expression)
WARNING: rejected rule (logical_expression -> logical_expression bool_op logical_expression) in state 97
WARNING: reduce/reduce conflict in state 105 resolved using rule (logical_expression -> value_expression)
WARNING: rejected rule (listed_values -> value_expression) in state 105
WARNING: reduce/reduce conflict in state 173 resolved using rule (logical_expression -> value_expression)
WARNING: rejected rule (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression) in state 173
WARNING: reduce/reduce conflict in state 180 resolved using rule (logical_expression -> value_expression)
WARNING: rejected rule (assign_expression -> ID assign_op value_expression) in state 180
WARNING: reduce/reduce conflict in state 194 resolved using rule (value_expression -> logical_expression)
WARNING: rejected rule (opt_logical_expression -> logical_expression) in state 194
WARNING: Rule (value -> INTEGER) is never reduced
WARNING: Rule (value -> DECIMAL) is never reduced
WARNING: Rule (value -> CHARACTER) is never reduced
WARNING: Rule (value -> ID) is never reduced
WARNING: Rule (logical_expression -> NEGATION logical_expression) is never reduced
WARNING: Rule (listed_values -> value_expression) is never reduced
WARNING: Rule (logical_expression -> logical_expression bool_op logical_expression) is never reduced
WARNING: Rule (trinary_mark_expression -> logical_expression QUESTION_MARK value_expression COLON value_expression) is never reduced
WARNING: Rule (assign_expression -> ID assign_op value_expression) is never reduced
WARNING: Rule (opt_logical_expression -> logical_expression) is never reduced
